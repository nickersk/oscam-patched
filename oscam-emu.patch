diff --git a/.gitignore b/.gitignore
index 9182d5c..d6d6585 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,3 +15,15 @@ webif/is_defined.txt
 # Testing program
 tests.bin
 tests.bin.debug
+
+# OSCam-Emu files
+.vscode
+cscrypt/viades.c
+cscrypt/viades.h
+dre2overcrypt.c
+dre2overcrypt.h
+via3surenc.c
+via3surenc.h
+SoftCam.Key
+git-svn-diff.sh
+oscam-emu.patch
diff --git a/CMakeLists.txt b/CMakeLists.txt
index d53c734..d10c2e1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -101,6 +101,7 @@ include_directories (
     ${CMAKE_CURRENT_SOURCE_DIR}/csctapi
     ${CMAKE_CURRENT_SOURCE_DIR}/cscrypt
     ${CMAKE_CURRENT_SOURCE_DIR}/minilzo
+    ${CMAKE_CURRENT_SOURCE_DIR}/ffdecsa
     ${CMAKE_CURRENT_SOURCE_DIR}/extapi/cygwin
     /usr/include/w32api
     ${OPTIONAL_INCLUDE_DIR}
@@ -110,6 +111,7 @@ include_directories (
     ${CMAKE_CURRENT_SOURCE_DIR}/csctapi
     ${CMAKE_CURRENT_SOURCE_DIR}/cscrypt
     ${CMAKE_CURRENT_SOURCE_DIR}/minilzo
+    ${CMAKE_CURRENT_SOURCE_DIR}/ffdecsa
     ${OPTIONAL_INCLUDE_DIR}
     )
 endif (OSCamOperatingSystem MATCHES "Windows/Cygwin")
@@ -420,6 +422,13 @@ endif (HAVE_PCSC)
 # Manage config.h based on command line parameters
 # Manipulate config file based on given parameters and read unset parameters
 
+execute_process (COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/config.sh --enabled WITH_EMU OUTPUT_VARIABLE CONFIG_WITH_EMU OUTPUT_STRIP_TRAILING_WHITESPACE)
+if (CONFIG_WITH_EMU MATCHES "Y" AND NOT WITH_EMU EQUAL 1)
+	add_definitions ("-DWITH_EMU")
+	set (WITH_EMU "1")
+	message(STATUS "  EMU is added by config compiling with EMU")
+endif(CONFIG_WITH_EMU MATCHES "Y" AND NOT WITH_EMU EQUAL 1)
+
 execute_process (COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/config.sh --show-valid OUTPUT_VARIABLE config_vars_string OUTPUT_STRIP_TRAILING_WHITESPACE)
 string(REGEX MATCHALL "[A-Z0-9_]+" config_vars ${config_vars_string})
 
@@ -449,6 +458,7 @@ execute_process (COMMAND make --no-print-directory --quiet -C ${CMAKE_CURRENT_SO
 add_subdirectory (csctapi)
 add_subdirectory (minilzo)
 add_subdirectory (cscrypt)
+add_subdirectory (ffdecsa)
 
 #----------------------- file groups ------------------------------
 execute_process (COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/config.sh --enabled MODULE_CAMD33 OUTPUT_VARIABLE CAMD33 OUTPUT_STRIP_TRAILING_WHITESPACE)
@@ -494,11 +504,30 @@ add_library (${csreaders} STATIC ${csreaders_srcs} ${csreaders_hdrs})
 set (csoscam "csoscam")
 add_library (${csoscam} STATIC ${csoscam_srcs} ${csoscam_hdrs})
 
+#------------------------------------------------------------------------
+
+if (NOT OSCamOperatingSystem MATCHES "Mac OS X")
+if (NOT DEFINED ENV{ANDROID_NDK})
+if (NOT DEFINED ENV{ANDROID_STANDALONE_TOOLCHAIN})
+    if (WITH_EMU)
+        if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/SoftCam.Key)
+            execute_process (COMMAND cp ${CMAKE_CURRENT_SOURCE_DIR}/SoftCam.Key ${CMAKE_CURRENT_BINARY_DIR}/SoftCam.Key)
+        else (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/SoftCam.Key)
+            execute_process (COMMAND touch ${CMAKE_CURRENT_BINARY_DIR}/SoftCam.Key)
+        endif (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/SoftCam.Key)
+    execute_process (COMMAND ${CMAKE_LINKER} -r -o SoftCam.Key.o -z noexecstack --format=binary SoftCam.Key WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+    execute_process (COMMAND ${CMAKE_OBJCOPY} --rename-section .data=.rodata,alloc,load,readonly,data,contents ${CMAKE_CURRENT_BINARY_DIR}/SoftCam.Key.o)
+    set (softcamkey_data "${CMAKE_CURRENT_BINARY_DIR}/SoftCam.Key.o")
+endif (WITH_EMU)
+endif (NOT DEFINED ENV{ANDROID_STANDALONE_TOOLCHAIN})
+endif (NOT DEFINED ENV{ANDROID_NDK})
+endif (NOT OSCamOperatingSystem MATCHES "Mac OS X")
+
 #----------------------- the executable ------------------------------
 
 set (exe_name "oscam")
-add_executable (${exe_name} ${exe_srcs} ${exe_hdrs})
-target_link_libraries (${exe_name} ${csoscam} ${csmodules} ${csreaders} csctapi cscrypt minilzo)
+add_executable (${exe_name} ${exe_srcs} ${exe_hdrs} ${softcamkey_data})
+target_link_libraries (${exe_name} ${csoscam} ${csmodules} ${csreaders} csctapi cscrypt minilzo ffdecsa)
 if(HAVE_LIBRT AND HAVE_LIBUSB)
    if (LIBUSBDIR)
 	set (libusb_link "imp_libusb")
@@ -653,6 +682,11 @@ add_definitions ("-D'CS_SVN_VERSION=\"${CS_SVN_VERSION}\"'")
 execute_process(COMMAND ${CMAKE_C_COMPILER} -dumpmachine COMMAND tr -d '\n' OUTPUT_VARIABLE CS_TARGET)
 add_definitions ("-D'CS_TARGET=\"${CS_TARGET}\"'")
 #----------------------- global compile and link options ------------------------------
+#enable sse2 on x86
+if (CMAKE_SYSTEM_PROCESSOR MATCHES "(x86)|(X86)|(amd64)|(AMD64)")
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -msse -msse2 -msse3")
+endif (CMAKE_SYSTEM_PROCESSOR MATCHES "(x86)|(X86)|(amd64)|(AMD64)")
+
 # disable warning about unused but set variables in gcc 4.6+
 if (CMAKE_COMPILER_IS_GNUCC)
     execute_process(COMMAND ${CMAKE_C_COMPILER} -dumpversion OUTPUT_VARIABLE GCC_VERSION)
@@ -735,8 +769,6 @@ if( HAVE_LIBRT OR HAVE_LIBRT_STATIC)
     endif (HAVE_LIBUSB)
 endif( HAVE_LIBRT OR HAVE_LIBRT_STATIC)
 
-#--------------------------------------------------------------------------------
-
 #----------------------- installation -----------------------------
 
 file (GLOB config_files "${CMAKE_CURRENT_SOURCE_DIR}/Distribution/oscam.*")
@@ -825,4 +857,8 @@ endif(STATIC_LIBUSB EQUAL 1)
  endif(STATICLIBUSB AND NOT LIBUSBDIR)
 endif (HAVE_LIBUSB)
 
+if (WITH_EMU)
+	message(STATUS "  Compile with EMU support")
+endif (WITH_EMU)
+
 message (STATUS "")
diff --git a/Makefile b/Makefile
index aca3c6f..8677284 100644
--- a/Makefile
+++ b/Makefile
@@ -62,9 +62,18 @@ CC_OPTS = -O2 -ggdb -pipe -ffunction-sections -fdata-sections
 
 CC = $(CROSS_DIR)$(CROSS)gcc
 STRIP = $(CROSS_DIR)$(CROSS)strip
+LD = $(CROSS_DIR)$(CROSS)ld
+OBJCOPY = $(CROSS_DIR)$(CROSS)objcopy
 
 LDFLAGS = -Wl,--gc-sections
 
+TARGETHELP := $(shell $(CC) --target-help 2>&1)
+ifneq (,$(findstring sse2,$(TARGETHELP)))
+override CFLAGS += -fexpensive-optimizations -mmmx -msse -msse2 -msse3
+else
+override CFLAGS += -fexpensive-optimizations
+endif
+
 # The linker for powerpc have bug that prevents --gc-sections from working
 # Check for the linker version and if it matches disable --gc-sections
 # For more information about the bug see:
@@ -271,6 +280,32 @@ SRC-$(CONFIG_CS_CACHEEX) += module-cccam-cacheex.c
 SRC-$(CONFIG_MODULE_CCCAM) += module-cccam.c
 SRC-$(CONFIG_MODULE_CCCSHARE) += module-cccshare.c
 SRC-$(CONFIG_MODULE_CONSTCW) += module-constcw.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-osemu.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-streamserver.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-biss.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-cryptoworks.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-director.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-drecrypt.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-irdeto.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-nagravision.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-powervu.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-viaccess.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-videoguard.c
+SRC-$(CONFIG_WITH_EMU) += ffdecsa/ffdecsa.c
+UNAME := $(shell uname -s)
+ifneq ($(UNAME),Darwin)
+ifndef ANDROID_NDK
+ifndef ANDROID_STANDALONE_TOOLCHAIN
+ifeq "$(CONFIG_WITH_EMU)" "y"
+TOUCH_SK := $(shell touch SoftCam.Key)
+$(shell $(LD) -r -o "SoftCam.Key.o" -z noexecstack --format=binary "SoftCam.Key")
+$(shell $(OBJCOPY) --rename-section .data=.rodata,alloc,load,readonly,data,contents "SoftCam.Key.o")
+EXTRA_LIBS += SoftCam.Key.o
+endif
+endif
+endif
+endif
 SRC-$(CONFIG_CS_CACHEEX) += module-csp.c
 SRC-$(CONFIG_CW_CYCLE_CHECK) += module-cw-cycle-check.c
 SRC-$(CONFIG_WITH_AZBOX) += module-dvbapi-azbox.c
@@ -371,7 +406,7 @@ SRC := $(subst config.c,$(OBJDIR)/config.c,$(SRC))
 # starts the compilation.
 all:
 	@./config.sh --use-flags "$(USE_FLAGS)" --objdir "$(OBJDIR)" --make-config.mak
-	@-mkdir -p $(OBJDIR)/cscrypt $(OBJDIR)/csctapi $(OBJDIR)/minilzo $(OBJDIR)/webif
+	@-mkdir -p $(OBJDIR)/cscrypt $(OBJDIR)/csctapi $(OBJDIR)/minilzo $(OBJDIR)/ffdecsa $(OBJDIR)/webif
 	@-printf "\
 +-------------------------------------------------------------------------------\n\
 | OSCam ver: $(VER) rev: $(SVN_REV) target: $(TARGET)\n\
diff --git a/config.h b/config.h
index a3fb35e..0014922 100644
--- a/config.h
+++ b/config.h
@@ -1,6 +1,7 @@
 #ifndef CONFIG_H_
 #define CONFIG_H_
 
+#define WITH_EMU 1
 #define WEBIF 1
 #define WEBIF_LIVELOG 1
 #define WEBIF_JQUERY 1
diff --git a/config.sh b/config.sh
index 57d9025..8b2c030 100755
--- a/config.sh
+++ b/config.sh
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-addons="WEBIF WEBIF_LIVELOG WEBIF_JQUERY TOUCH WITH_SSL HAVE_DVBAPI WITH_NEUTRINO READ_SDT_CHARSETS IRDETO_GUESSING CS_ANTICASC WITH_DEBUG MODULE_MONITOR WITH_LB CS_CACHEEX CW_CYCLE_CHECK LCDSUPPORT LEDSUPPORT CLOCKFIX IPV6SUPPORT"
+addons="WEBIF WEBIF_LIVELOG WEBIF_JQUERY TOUCH WITH_SSL HAVE_DVBAPI WITH_NEUTRINO READ_SDT_CHARSETS IRDETO_GUESSING CS_ANTICASC WITH_DEBUG MODULE_MONITOR WITH_LB CS_CACHEEX CW_CYCLE_CHECK LCDSUPPORT LEDSUPPORT CLOCKFIX IPV6SUPPORT WITH_EMU"
 protocols="MODULE_CAMD33 MODULE_CAMD35 MODULE_CAMD35_TCP MODULE_NEWCAMD MODULE_CCCAM MODULE_CCCSHARE MODULE_GBOX MODULE_RADEGAST MODULE_SCAM MODULE_SERIAL MODULE_CONSTCW MODULE_PANDORA MODULE_GHTTP"
 readers="READER_NAGRA READER_NAGRA_MERLIN READER_IRDETO READER_CONAX READER_CRYPTOWORKS READER_SECA READER_VIACCESS READER_VIDEOGUARD READER_DRE READER_TONGFANG READER_BULCRYPT READER_GRIFFIN READER_DGCRYPT"
 card_readers="CARDREADER_PHOENIX CARDREADER_INTERNAL CARDREADER_SC8IN1 CARDREADER_MP35 CARDREADER_SMARGO CARDREADER_DB2COM CARDREADER_STAPI CARDREADER_STAPI5 CARDREADER_STINGER CARDREADER_DRECAS"
@@ -25,6 +25,7 @@ CONFIG_CW_CYCLE_CHECK=y
 # CONFIG_LEDSUPPORT=n
 CONFIG_CLOCKFIX=y
 # CONFIG_IPV6SUPPORT=n
+CONFIG_WITH_EMU=y
 # CONFIG_MODULE_CAMD33=n
 CONFIG_MODULE_CAMD35=y
 CONFIG_MODULE_CAMD35_TCP=y
@@ -292,12 +293,15 @@ get_opts() {
 
 update_deps() {
 	# Calculate dependencies
-	enabled_any $(get_opts readers) $(get_opts card_readers) && enable_opt WITH_CARDREADER >/dev/null
-	disabled_all $(get_opts readers) $(get_opts card_readers) && disable_opt WITH_CARDREADER >/dev/null
+	enabled_any $(get_opts readers) $(get_opts card_readers) WITH_EMU && enable_opt WITH_CARDREADER >/dev/null
+	disabled_all $(get_opts readers) $(get_opts card_readers) WITH_EMU && disable_opt WITH_CARDREADER >/dev/null
 	disabled WEBIF && disable_opt WEBIF_LIVELOG >/dev/null
 	disabled WEBIF && disable_opt WEBIF_JQUERY >/dev/null
 	enabled MODULE_CCCSHARE && enable_opt MODULE_CCCAM >/dev/null
 	enabled_any CARDREADER_DB2COM CARDREADER_MP35 CARDREADER_SC8IN1 CARDREADER_STINGER && enable_opt CARDREADER_PHOENIX >/dev/null
+	enabled WITH_EMU && enable_opt READER_VIACCESS >/dev/null
+	enabled WITH_EMU && enable_opt READER_DRE >/dev/null
+	enabled WITH_EMU && enable_opt MODULE_NEWCAMD >/dev/null
 }
 
 list_config() {
@@ -347,9 +351,9 @@ list_config() {
 	not_have_flag USE_LIBCRYPTO && echo "CONFIG_LIB_AES=y" || echo "# CONFIG_LIB_AES=n"
 	enabled MODULE_CCCAM && echo "CONFIG_LIB_RC6=y" || echo "# CONFIG_LIB_RC6=n"
 	not_have_flag USE_LIBCRYPTO && enabled MODULE_CCCAM && echo "CONFIG_LIB_SHA1=y" || echo "# CONFIG_LIB_SHA1=n"
-	enabled_any READER_DRE MODULE_SCAM READER_VIACCESS READER_NAGRA_MERLIN && echo "CONFIG_LIB_DES=y" || echo "# CONFIG_LIB_DES=n"
-	enabled_any MODULE_CCCAM READER_NAGRA READER_NAGRA_MERLIN READER_SECA && echo "CONFIG_LIB_IDEA=y" || echo "# CONFIG_LIB_IDEA=n"
-	not_have_flag USE_LIBCRYPTO && enabled_any READER_CONAX READER_CRYPTOWORKS READER_NAGRA READER_NAGRA_MERLIN && echo "CONFIG_LIB_BIGNUM=y" || echo "# CONFIG_LIB_BIGNUM=n"
+	enabled_any READER_DRE MODULE_SCAM READER_VIACCESS READER_NAGRA_MERLIN WITH_EMU && echo "CONFIG_LIB_DES=y" || echo "# CONFIG_LIB_DES=n"
+	enabled_any MODULE_CCCAM READER_NAGRA READER_NAGRA_MERLIN READER_SECA WITH_EMU && echo "CONFIG_LIB_IDEA=y" || echo "# CONFIG_LIB_IDEA=n"
+	not_have_flag USE_LIBCRYPTO && enabled_any READER_CONAX READER_CRYPTOWORKS READER_NAGRA READER_NAGRA_MERLIN WITH_EMU && echo "CONFIG_LIB_BIGNUM=y" || echo "# CONFIG_LIB_BIGNUM=n"
 	enabled READER_NAGRA_MERLIN && echo "CONFIG_LIB_MDC2=y" || echo "# CONFIG_LIB_MDC2=n"
 	enabled READER_NAGRA_MERLIN && echo "CONFIG_LIB_FAST_AES=y" || echo "# CONFIG_LIB_FAST_AES=n"
 	enabled READER_NAGRA_MERLIN && echo "CONFIG_LIB_SHA256=y" || echo "# CONFIG_LIB_SHA256=n"
@@ -465,6 +469,7 @@ menu_addons() {
 		LEDSUPPORT			"LED support"							$(check_test "LEDSUPPORT") \
 		CLOCKFIX			"Clockfix (disable on old systems!)"	$(check_test "CLOCKFIX") \
 		IPV6SUPPORT			"IPv6 support (experimental)"			$(check_test "IPV6SUPPORT") \
+		WITH_EMU			"Emulator support"						$(check_test "WITH_EMU") \
 		2> ${tempfile}
 
 	opt=${?}
@@ -701,7 +706,11 @@ do
 		revision=`(svnversion -n . 2>/dev/null || printf 0) | sed 's/.*://; s/[^0-9]*$//; s/^$/0/'`
 		if [ "$revision" = "0" ]
 		then
-			which git > /dev/null 2>&1 && revision=`git log -10 --pretty=%B | grep git-svn-id | head -n 1 | sed -n -e 's/^.*trunk@\([0-9]*\) .*$/\1/p'`
+			which git > /dev/null 2>&1 && revision=`git describe --abbrev=0 --tags --always | sed -n -e 's/^oscam\(.*\)emu/\1/p'`
+		fi
+		if [ -z "$revision" ]
+		then
+			which git > /dev/null 2>&1 && revision=`git log -25 --pretty=%B | grep git-svn-id | head -n 1 | sed -n -e 's/^.*trunk@\([0-9]*\) .*$/\1/p'`
 		fi
 		echo $revision
 		break
diff --git a/csctapi/cardreaders.h b/csctapi/cardreaders.h
index 8b6c309..35f38c6 100644
--- a/csctapi/cardreaders.h
+++ b/csctapi/cardreaders.h
@@ -14,5 +14,6 @@ extern const struct s_cardreader cardreader_smartreader;
 extern const struct s_cardreader cardreader_stapi;
 extern const struct s_cardreader cardreader_stinger;
 extern const struct s_cardreader cardreader_drecas;
+extern const struct s_cardreader cardreader_emu;
 
 #endif
diff --git a/globals.h b/globals.h
index bda11b3..6735b07 100644
--- a/globals.h
+++ b/globals.h
@@ -392,9 +392,9 @@ typedef unsigned char uchar;
 #define CS_ECM_RINGBUFFER_MAX 0x10       // max size for ECM last responsetimes ringbuffer. Keep this set to power of 2 values!
 
 // Support for multiple CWs per channel and other encryption algos
-//#define WITH_EXTENDED_CW 1
+#define WITH_EXTENDED_CW 1
 
-#if defined(READER_DRE) || defined(READER_DRECAS) || defined(READER_VIACCESS)
+#if defined(READER_DRE) || defined(READER_DRECAS) || defined(READER_VIACCESS) || defined(WITH_EMU)
 #define MAX_ECM_SIZE          1024
 #define MAX_EMM_SIZE          1024
 #else
@@ -402,7 +402,7 @@ typedef unsigned char uchar;
 #define MAX_EMM_SIZE          512
 #endif
 
-#define CS_EMMCACHESIZE       512       //nr of EMMs that each reader will cache
+#define CS_EMMCACHESIZE       1024      //nr of EMMs that each reader will cache
 #define MSGLOGSIZE            64        //size of string buffer for a ecm to return messages
 
 #define D_TRACE               0x0001    // Generate very detailed error/trace messages per routine
@@ -434,6 +434,7 @@ typedef unsigned char uchar;
 #define R_SMART               0x7       // Smartreader+
 #define R_PCSC                0x8       // PCSC
 #define R_DRECAS              0x9       // Reader DRECAS
+#define R_EMU                 0x17      // Reader EMU
 ///////////////////////////// proxy readers after R_CS378X
 #define R_CAMD35              0x20      // Reader cascading camd 3.5x
 #define R_CAMD33              0x21      // Reader cascading camd 3.3x
@@ -861,6 +862,13 @@ typedef struct s_entitlement                      // contains entitlement Info
 	uint32_t        class;                          // the class needed for some systems
 	time_t          start;                          // startdate
 	time_t          end;                            // enddate
+#ifdef WITH_EMU
+	bool            isKey;
+	bool            isData;
+	char            name[8];
+	uint8_t         *key;
+	uint32_t        keyLength;
+#endif
 } S_ENTITLEMENT;
 
 struct s_client;
@@ -985,6 +993,7 @@ struct s_cardsystem
 	void (*post_process)(struct s_reader *);
 	int32_t (*get_emm_type)(struct emm_packet_t *, struct s_reader *);
 	int32_t (*get_emm_filter)(struct s_reader *, struct s_csystem_emm_filter **, uint32_t *);
+	int32_t (*get_emm_filter_adv)(struct s_reader *, struct s_csystem_emm_filter **, uint32_t *, uint16_t, uint32_t, uint16_t);
 	int32_t (*get_tunemm_filter)(struct s_reader *, struct s_csystem_emm_filter **, uint32_t *);
 };
 
@@ -1778,6 +1787,14 @@ struct s_reader                                   //contains device info, reader
 #endif
 #ifdef MODULE_GHTTP
 	uint8_t         ghttp_use_ssl;
+#endif
+#ifdef WITH_EMU
+	FTAB            emu_auproviders;                // AU providers for Emu reader
+	int8_t          emu_datecodedenabled;           // date-coded keys for BISS
+	char            *extee36;                       // path to "ee36.bin" - Set by the user via the webif
+	char            *extee56;                       // path to "ee56.bin" - Set by the user via the webif
+	uint8_t         dre36_force_group;
+	uint8_t         dre56_force_group;
 #endif
 	uint8_t         cnxlastecm;                     // == 0 - last ecm has not been paired ecm, > 0 last ecm has been paired ecm
 	LLIST           *emmstat;                       //emm stats
@@ -2229,6 +2246,7 @@ struct s_config
 	int8_t          dvbapi_read_sdt;
 	int8_t          dvbapi_write_sdt_prov;
 	int8_t          dvbapi_extended_cw_api;
+	int8_t          dvbapi_extended_cw_pids;        // pid limiter
 #endif
 
 #ifdef CS_ANTICASC
@@ -2276,6 +2294,18 @@ struct s_config
 	struct s_ip     *scam_allowed;
 #endif
 
+#ifdef WITH_EMU
+	char            *emu_stream_source_host;
+	int32_t         emu_stream_source_port;
+	char            *emu_stream_source_auth_user;
+	char            *emu_stream_source_auth_password;
+	int32_t         emu_stream_relay_port;
+	uint32_t        emu_stream_ecm_delay;
+	int8_t          emu_stream_relay_enabled;
+	int8_t          emu_stream_emm_enabled;
+	CAIDTAB         emu_stream_relay_ctab;          // use the stream server for these caids
+#endif
+
 	int32_t         max_cache_time;                 //seconds ecms are stored in ecmcwcache
 	int32_t         max_hitcache_time;              //seconds hits are stored in cspec_hitcache (to detect dyn wait_time)
 
@@ -2433,6 +2463,8 @@ const char *boxtype_get(void);
 const char *boxname_get(void);
 static inline bool caid_is_fake(uint16_t caid) { return caid == 0xffff; }
 static inline bool caid_is_biss(uint16_t caid) { return caid >> 8 == 0x26; }
+static inline bool caid_is_biss_static(uint16_t caid) { return caid == 0x2600 || caid == 0x2602; } // static cw, fake ecm
+static inline bool caid_is_biss_dynamic(uint16_t caid) { return caid == 0x2610; } // dynamic cw, ecm and emm
 static inline bool caid_is_seca(uint16_t caid) { return caid >> 8 == 0x01; }
 static inline bool caid_is_viaccess(uint16_t caid) { return caid >> 8 == 0x05; }
 static inline bool caid_is_irdeto(uint16_t caid) { return caid >> 8 == 0x06; }
@@ -2447,4 +2479,8 @@ static inline bool caid_is_bulcrypt(uint16_t caid) { return caid == 0x5581 || ca
 static inline bool caid_is_dre(uint16_t caid) { return caid == 0x4AE0 || caid == 0x4AE1 || caid == 0x2710;}
 const char *get_cardsystem_desc_by_caid(uint16_t caid);
 
+#ifdef WITH_EMU
+FILTER* get_emu_prids_for_caid(struct s_reader *rdr, uint16_t caid);
+#endif
+
 #endif
diff --git a/module-dvbapi.c b/module-dvbapi.c
index 1a30af9..81f79bf 100644
--- a/module-dvbapi.c
+++ b/module-dvbapi.c
@@ -1548,7 +1548,14 @@ void dvbapi_start_emm_filter(int32_t demux_index)
 			}
 			if(match)
 			{
-				csystem = get_cardsystem_by_caid(caid);
+				if(rdr->typ == R_EMU)
+				{
+					csystem = rdr->csystem;
+				}
+				else
+				{
+					csystem = get_cardsystem_by_caid(caid);	
+				}
 				if(csystem)
 				{
 					if(caid != ncaid)
@@ -1567,7 +1574,14 @@ void dvbapi_start_emm_filter(int32_t demux_index)
 					}
 					else if (csystem->get_emm_filter)
 					{
-						csystem->get_emm_filter(rdr, &dmx_filter, &filter_count);
+						if(rdr->typ == R_EMU)
+						{
+							csystem->get_emm_filter_adv(rdr, &dmx_filter, &filter_count, caid, provid, demux[demux_index].program_number);
+						}
+						else
+						{
+							csystem->get_emm_filter(rdr, &dmx_filter, &filter_count);
+						}
 					}
 				}
 				else
@@ -2152,6 +2166,8 @@ int32_t dvbapi_start_descrambling(int32_t demux_id, int32_t pid, int8_t checked,
 	er->vpid   = demux[demux_id].ECMpids[pid].VPID;
 	er->pmtpid = demux[demux_id].pmtpid;
 	er->onid   = demux[demux_id].onid;
+	er->tsid   = demux[demux_id].tsid;
+	er->ens    = demux[demux_id].enigma_namespace;
 	er->msgid  = msgid;
 
 #ifdef WITH_STAPI5
@@ -2186,22 +2202,33 @@ int32_t dvbapi_start_descrambling(int32_t demux_id, int32_t pid, int8_t checked,
 		// BISS or FAKE CAID
 		// ecm stream pid is fake, so send out one fake ecm request
 		// special treatment: if we asked the cw first without starting a filter the cw request will be killed due to no ecmfilter started
-		if(caid_is_fake(demux[demux_id].ECMpids[pid].CAID) || caid_is_biss(demux[demux_id].ECMpids[pid].CAID))
+		if(caid_is_fake(demux[demux_id].ECMpids[pid].CAID) || caid_is_biss_static(demux[demux_id].ECMpids[pid].CAID))
 		{
 			int32_t j, n;
-			er->ecmlen = 5;
+			er->ecmlen = 7;
 			er->ecm[0] = 0x80; // to pass the cache check it must be 0x80 or 0x81
 			er->ecm[1] = 0x00;
-			er->ecm[2] = 0x02;
+			er->ecm[2] = 0x04;
 			i2b_buf(2, er->srvid, er->ecm + 3);
+			i2b_buf(2, er->pmtpid, er->ecm + 5);
 
-			for(j = 0, n = 5; j < demux[demux_id].STREAMpidcount; j++, n += 2)
+			for(j = 0, n = 7; j < demux[demux_id].STREAMpidcount; j++, n += 2)
 			{
 				i2b_buf(2, demux[demux_id].STREAMpids[j], er->ecm + n);
 				er->ecm[2] += 2;
 				er->ecmlen += 2;
 			}
 
+			er->ens &= 0x0FFFFFFF; // clear top 4 bits (in case of DVB-T/C or garbage), prepare for flagging
+			er->ens |= 0xA0000000; // flag to emu: this is the namespace, not a pid
+
+			i2b_buf(2, er->tsid, er->ecm + 3 + er->ecm[2]);     // place tsid after the last stream pid
+			i2b_buf(2, er->onid, er->ecm + 3 + er->ecm[2] + 2); // place onid right after tsid
+			i2b_buf(4, er->ens, er->ecm + 3 + er->ecm[2] + 4);  // place namespace at the end of the ecm
+
+			er->ecm[2] += 8;
+			er->ecmlen += 8;
+
 			cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X ANY CHID PMTPID %04X VPID %04X", demux_id, pid,
 				   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
 				   demux[demux_id].pmtpid, demux[demux_id].ECMpids[pid].VPID);
@@ -3429,6 +3456,7 @@ int32_t dvbapi_parse_capmt(unsigned char *buffer, uint32_t length, int32_t connf
 {
 	uint32_t i = 0, start_descrambling = 0;
 	int32_t j = 0;
+	int32_t max_pids = 64;
 	int32_t demux_id = -1;
 	uint16_t demux_index, adapter_index, pmtpid;
 	uint32_t ca_mask;
@@ -3592,13 +3620,19 @@ int32_t dvbapi_parse_capmt(unsigned char *buffer, uint32_t length, int32_t connf
 	uint32_t es_info_length = 0, vpid = 0;
 	struct s_dvbapi_priority *addentry;
 
+	// pid limiter for PowerVu
+	if(caid_is_powervu(demux[demux_id].ECMpids[0].CAID))
+	{
+		max_pids = cfg.dvbapi_extended_cw_pids;
+	}
+
 	for(i = program_info_length + program_info_start; i + 4 < length; i += es_info_length + 5)
 	{
-		uint8_t stream_type = buffer[i], type = STREAM_UNDEFINED;
+		uint8_t stream_type = buffer[i], type = STREAM_AUDIO; // default to audio - quick fix for missing audio when recording
 		uint16_t elementary_pid = b2i(2, buffer + i + 1)&0x1FFF;
 		es_info_length = b2i(2, buffer + i +3)&0x0FFF;
 
-		if(demux[demux_id].STREAMpidcount < ECM_PIDS)
+		if(demux[demux_id].STREAMpidcount < max_pids) // was "ECM_PIDS" (pid limiter)
 		{
 			cs_log_dbg(D_DVBAPI,"Demuxer %d found %s stream (type: %02X pid: %04X)", demux_id, get_stream_type_txt(stream_type), stream_type, elementary_pid);
 
@@ -4656,6 +4690,7 @@ void dvbapi_process_input(int32_t demux_id, int32_t filter_num, uchar *buffer, i
 	if(filtertype == TYPE_ECM)
 	{
 		uint32_t chid = 0x10000;
+		int8_t pvu_skip = 0;
 		ECM_REQUEST *er;
 
 		if(len != 0) // len = 0 receiver encountered an internal bufferoverflow!
@@ -4682,9 +4717,24 @@ void dvbapi_process_input(int32_t demux_id, int32_t filter_num, uchar *buffer, i
 				return;
 			}
 
-			if(curpid->table == buffer[0] && !caid_is_irdeto(curpid->CAID)) // wait for odd / even ecm change (only not for irdeto!)
+			if(caid_is_powervu(curpid->CAID))
 			{
+				pvu_skip = 1;
+
+				if(sctlen - 11 > buffer[9])
+				{
+					if(buffer[11 + buffer[9]] > curpid->pvu_counter
+						|| (curpid->pvu_counter == 255 && buffer[11 + buffer[9]] == 0)
+						|| ((curpid->pvu_counter - buffer[11 + buffer[9]]) > 5))
+					{
+						curpid->pvu_counter = buffer[11 + buffer[9]];
+						pvu_skip = 0;
+					}
+				}
+			}
 
+			if((curpid->table == buffer[0] && !caid_is_irdeto(curpid->CAID)) || pvu_skip) // wait for odd / even ecm change (only not for irdeto!)
+			{
 				if(!(er = get_ecmtask()))
 				{
 					return;
@@ -4966,6 +5016,38 @@ void dvbapi_process_input(int32_t demux_id, int32_t filter_num, uchar *buffer, i
 			return;
 		}
 
+#ifdef WITH_EMU
+		if(caid_is_director(demux[demux_id].demux_fd[filter_num].caid))
+		{
+			uint32_t i;
+			uint32_t emmhash;
+
+			if(sctlen < 4)
+			{
+				return;
+			}
+
+			for(i=0; i+2<sctlen; i++)
+			{
+				if(buffer[i] == 0xF0 && (buffer[i+2] == 0xE1 || buffer[i+2] == 0xE4))
+				{
+					emmhash = (buffer[3]<<8) | buffer[sctlen-2];
+
+					if(demux[demux_id].demux_fd[filter_num].cadata == emmhash)
+					{
+						return;
+					}
+
+					demux[demux_id].demux_fd[filter_num].cadata = emmhash;
+
+					dvbapi_process_emm(demux_id, filter_num, buffer, sctlen);
+					return;
+				}
+			}
+			return;
+		}
+#endif
+
 		// Fix to handle more than one irdeto emm packet
 		uchar *pbuf = buffer;
 		int32_t done = 0;
@@ -6502,6 +6584,9 @@ void dvbapi_send_dcw(struct s_client *client, ECM_REQUEST *er)
 
 		delayer(er, delay);
 
+#ifdef WITH_EMU
+		if(!chk_ctab_ex(er->caid, &cfg.emu_stream_relay_ctab) || !cfg.emu_stream_relay_enabled)
+#endif
 		switch(selected_api)
 		{
 #if defined(WITH_STAPI) || defined(WITH_STAPI5)
@@ -6531,30 +6616,28 @@ void dvbapi_send_dcw(struct s_client *client, ECM_REQUEST *er)
 				if(er->cw_ex.mode == CW_MODE_MULTIPLE_CW)
 				{
 					int32_t key_pos_a = 0;
-					uint8_t *cw;
-
 					demux[i].ECMpids[j].useMultipleIndices = 1;
 
 					for(k = 0; k < demux[i].STREAMpidcount; k++)
 					{
 						if(demux[i].STREAMpidsType[k] == STREAM_VIDEO)
 						{
-							cw = er->cw;
+							dvbapi_write_cw(i, er->cw, j, k, er->cw_ex.algo, er->cw_ex.algo_mode, er->msgid);
 						}
 						else if(demux[i].STREAMpidsType[k] == STREAM_AUDIO)
 						{
-							cw = er->cw_ex.audio[key_pos_a];
-							if(key_pos_a < 3)
+							if(key_pos_a < 4)
 							{
+								dvbapi_write_cw(i, er->cw_ex.audio[key_pos_a], j, k, er->cw_ex.algo, er->cw_ex.algo_mode, er->msgid);
 								key_pos_a++;
 							}
 						}
-						else // Data
-						{
-							cw = er->cw_ex.data;
-						}
-
-						dvbapi_write_cw(i, cw, j, k, er->cw_ex.algo, er->cw_ex.algo_mode, er->msgid);
+						// Every channel that uses the extended cw has unencrypted subtitle streams,
+						// so disable CW writing to save indices for audio streams and recordings.
+						//else // Data
+						//{
+						//	dvbapi_write_cw(i, er->cw_ex.data, j, k, er->cw_ex.algo, er->cw_ex.algo_mode, er->msgid);
+						//}
 					}
 				}
 				else
diff --git a/module-dvbapi.h b/module-dvbapi.h
index 31f4d19..cf9667e 100644
--- a/module-dvbapi.h
+++ b/module-dvbapi.h
@@ -141,6 +141,7 @@ struct s_ecmpids
 	int8_t useMultipleIndices;
 	uint32_t streams;
 	uint32_t cadata;
+	int16_t pvu_counter;
 };
 
 typedef struct filter_s
@@ -163,6 +164,9 @@ typedef struct filter_s
 	uint32_t    SlotHandle[10];
 	uint32_t    BufferHandle[10];
 #endif
+#ifdef WITH_EMU
+	uint32_t cadata;
+#endif
 } FILTERTYPE;
 
 struct s_emmpids
diff --git a/module-emulator-biss.c b/module-emulator-biss.c
new file mode 100644
index 0000000..649bfde
--- /dev/null
+++ b/module-emulator-biss.c
@@ -0,0 +1,546 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "module-emulator-osemu.h"
+#include "oscam-string.h"
+
+static void BissUnifyOrbitals(uint32_t *namespace)
+{
+	// Unify orbitals to produce same namespace among users
+	// Set positions according to http://satellites-xml.org
+
+	uint16_t pos = (*namespace & 0x0FFF0000) >> 16;
+
+	switch (pos)
+	{
+		case 29: // Rascom QAF 1R
+		case 31: // Eutelsat 3B
+		{
+			pos = 30;
+			break;
+		}
+
+		case 49:
+		case 50: // SES 5
+		{
+			pos = 48; // Astra 4A
+			break;
+		}
+
+		case 215:
+		{
+			pos = 216; // Eutelsat 21B
+			break;
+		}
+
+		case 285: // Astra 2E
+		{
+			pos = 282; // Astra 2F/2G
+			break;
+		}
+
+		case 328: // Intelsat 28
+		case 329:
+		case 331: // Eutelsat 33C
+		{
+			pos = 330;
+			break;
+		}
+
+		case 359: // Eutelsat 36B
+		case 361: // Express AMU1
+		{
+			pos = 360;
+			break;
+		}
+
+		case 451: // Intelsat 904
+		{
+			pos = 450; // Intelsat 12
+			break;
+		}
+
+		case 550:
+		case 551: // G-Sat 8/16
+		{
+			pos = 549; // Yamal 402
+			break;
+		}
+
+		case 748:
+		case 749: // ABS 2A
+		{
+			pos = 750;
+			break;
+		}
+
+		case 848: // Horizons 2
+		case 852: // Intelsat 15
+		{
+			pos = 850;
+			break;
+		}
+
+		case 914: // Mesasat 3a
+		{
+			pos = 915; // Mesasat 3/3b
+			break;
+		}
+
+		case 934: // G-Sat 17
+		case 936: // Insat 4B
+		{
+			pos = 935; // G-Sat 15
+			break;
+		}
+
+		case 3600 - 911: // Nimiq 6
+		{
+			pos = 3600 - 910; // Galaxy 17
+			break;
+		}
+
+		case 3600 - 870: // SES 2
+		case 3600 - 872: // TKSat 1
+		{
+			pos = 3600 - 871;
+			break;
+		}
+
+		case 3600 - 432: // Sky Brasil 1
+		case 3600 - 430: // Intelsat 11
+		{
+			pos = 3600 - 431;
+			break;
+		}
+
+		case 3600 - 376: // Telstar 11N
+		case 3600 - 374: // NSS 10
+		{
+			pos = 3600 - 375;
+			break;
+		}
+
+		case 3600 - 359: // Hispasat 36W-1
+		{
+			pos = 3600 - 360; // Eutelsat 36 West A
+			break;
+		}
+
+		case 3600 - 81: // Eutelsat 8 West B
+		{
+			pos = 3600 - 80;
+			break;
+		}
+
+		case 3600 - 73: // Eutelsat 7 West A
+		case 3600 - 72:
+		case 3600 - 71:
+		{
+			pos = 3600 - 70; // Nilesat 201
+			break;
+		}
+
+		case 3600 - 10: // Intelsat 10-02
+		case 3600 - 9: // Thor 6
+		case 3600 - 7: // Thor 7
+		case 3600 - 6: // Thor 7
+		{
+			pos = 3600 - 8; // Thor 5
+			break;
+		}
+	}
+
+	*namespace = (*namespace & 0xF000FFFF) | (pos << 16);
+}
+
+static void BissAnnotate(char *buf, uint8_t len, const uint8_t *ecm, uint16_t ecmLen, uint32_t hash, int8_t isNamespaceHash, int8_t datecoded)
+{
+	// Extract useful information to append to the "Example key ..." message.
+	//
+	// For feeds, the orbital position & frequency are usually embedded in the namespace.
+	// See https://github.com/openatv/enigma2/blob/master/lib/dvb/frontend.cpp#L496
+	// hash = (sat.orbital_position << 16);
+	// hash |= ((sat.frequency/1000)&0xFFFF)|((sat.polarisation&1) << 15);
+	//
+	// If the onid & tsid appear to be a unique DVB identifier, enigma2 strips the frequency
+	// from our namespace. See https://github.com/openatv/enigma2/blob/master/lib/dvb/scan.cpp#L59
+	// In that case, our annotation contains the onid:tsid:sid triplet in lieu of frequency.
+	//
+	// For the universal case, we print the number of elementary stream pids & pmtpid.
+	// The sid and current time are included for all. Examples:
+	//
+	// F 1A2B3C4D 00000000 XXXXXXXXXXXXXXXX ; 110.5W 12345H sid:0001 added: 2017-10-17 @ 13:14:15 // namespace
+	// F 1A2B3C4D 20180123 XXXXXXXXXXXXXXXX ;  33.5E  ABCD:9876:1234 added: 2017-10-17 @ 13:14:15 // stripped namespace
+	// F 1A2B3C4D 20180123 XXXXXXXXXXXXXXXX ; av:5 pmt:0134 sid:0001 added: 2017-10-17 @ 13:14:15 // universal
+
+	uint8_t pidcount;
+	uint16_t frequency, degrees, pmtpid, srvid, tsid, onid;
+	uint32_t ens;
+	char compass, polarisation, timeStr1[9], timeStr2[19];
+
+	if (datecoded)
+	{
+		Date2Str(timeStr1, sizeof(timeStr1), 4, 3);
+	}
+	else
+	{
+		snprintf(timeStr1, sizeof(timeStr1), "00000000");
+	}
+
+	Date2Str(timeStr2, sizeof(timeStr2), 0, 2);
+
+	if (isNamespaceHash) // Namespace hash
+	{
+		ens = b2i(4, ecm + ecmLen - 4); // Namespace will be the last 4 bytes of the ecm
+		degrees = (ens >> 16) & 0x0FFF; // Remove not-a-pid flag
+
+		if (degrees > 1800)
+		{
+			degrees = 3600 - degrees;
+			compass = 'W';
+		}
+		else
+		{
+			compass = 'E';
+		}
+
+		if (0 == (ens & 0xFFFF)) // Stripped namespace hash
+		{
+			srvid = b2i(2, ecm + 3);
+			tsid = b2i(2, ecm + ecmLen - 8);
+			onid = b2i(2, ecm + ecmLen - 6);
+			// Printing degree sign "\u00B0" requires c99 standard
+			snprintf(buf, len, "F %08X %s XXXXXXXXXXXXXXXX ; %5.1f%c  %04X:%04X:%04X added: %s",
+								hash, timeStr1, degrees / 10.0, compass, onid, tsid, srvid, timeStr2);
+		}
+		else // Full namespace hash
+		{
+			srvid = b2i(2, ecm + 3);
+			frequency = ens & 0x7FFF; // Remove polarity bit
+			polarisation = ens & 0x8000 ? 'V' : 'H';
+			// Printing degree sign "\u00B0" requires c99 standard
+			snprintf(buf, len, "F %08X %s XXXXXXXXXXXXXXXX ; %5.1f%c %5d%c sid:%04X added: %s",
+								hash, timeStr1, degrees / 10.0, compass, frequency, polarisation, srvid, timeStr2);
+		}
+	}
+	else // Universal hash
+	{
+		srvid = b2i(2, ecm + 3);
+		pmtpid = b2i(2, ecm + 5);
+		pidcount = (ecmLen - 15) / 2; // video + audio pids count
+		snprintf(buf, len, "F %08X %s XXXXXXXXXXXXXXXX ; av:%d pmt:%04X sid:%04X added: %s",
+							hash, timeStr1, pidcount, pmtpid, srvid, timeStr2);
+	}
+}
+
+static int8_t BissIsCommonHash(uint32_t hash)
+{
+	// Check universal hash against a number of commnon universal
+	// hashes in order to warn users about potential key clashes
+
+	switch (hash)
+	{
+		case 0xBAFCD9FD: // 0001 0020 0200 1010 1020 (most common hash)
+			return 1;
+		case 0xA6A4FBD4: // 0001 0800 0200 1010 1020
+			return 1;
+		case 0xEFAB7A4D: // 0001 0800 1010 1020 0200
+			return 1;
+		case 0x83FA15D1: // 0001 0020 0134 0100 0101
+			return 1;
+		case 0x58934C38: // 0001 0800 1010 1020 1030 0200
+			return 1;
+		case 0x2C3CEC17: // 0001 0020 0134 0100
+			return 1;
+		case 0x73DF7F7E: // 0001 0020 0200 1010 1020 1030
+			return 1;
+		case 0xAFA85BC8: // 0001 0020 0021 0022 0023
+			return 1;
+		case 0x8C51F31D: // 0001 0800 0200 1010 1020 1030 1040
+			return 1;
+		case 0xE2F9BD29: // 0001 0800 0200 1010 1020 1030
+			return 1;
+		case 0xB9EBE0FF: // 0001 0100 0200 1010 1020 (less common hash)
+			return 1;
+		default:
+			return 0;
+	}
+}
+
+static int8_t BissIsValidNamespace(uint32_t namespace)
+{
+	// Note to developers:
+	// If we ever have a satellite at 0.0E, edit to allow stripped namespace
+	// '0xA0000000' with an additional test on tsid and onid being != 0
+
+	uint16_t orbital, frequency;
+
+	orbital = (namespace >> 16) & 0x0FFF;
+	frequency = namespace & 0x7FFF;
+
+	if ((namespace & 0xA0000000) != 0xA0000000) return 0;   // Value isn't flagged as namespace
+	if (namespace == 0xA0000000) return 0;                  // Empty namespace
+	if (orbital > 3599) return 0;                           // Allow only DVB-S
+	if (frequency == 0) return 1;                           // Stripped namespace
+	if (frequency >= 3400 && frequency <= 4200) return 1;   // Super extended C band
+	if (frequency >= 10700 && frequency <= 12750) return 1; // Ku band Europe
+
+	return 0;
+}
+
+static int8_t BissGetKey(uint32_t provider, uint8_t *key, int8_t dateCoded, int8_t printMsg)
+{
+	// If date-coded keys are enabled in the webif, this function evaluates the expiration date
+	// of the keys found. Expired keys are not sent to the calling function. If date-coded keys
+	// are disabled, then all keys found are sent without any evaluation. It takes the "provider"
+	// as input and outputs the "key". Returns 0 (Key not found, or expired) or 1 (Key found).
+
+	// printMsg: 0 => No message
+	// printMsg: 1 => Print message only if key is found
+	// printMsg: 2 => Always print message, regardless if key is found or not
+
+	char keyExpDate[9] = "00000000";
+
+	if (FindKey('F', provider, 0, keyExpDate, key, 8, 0, 0, 0, NULL)) // Key found
+	{
+		if (dateCoded) // Date-coded keys are enabled, evaluate expiration date
+		{
+			char currentDate[9];
+			Date2Str(currentDate, sizeof(currentDate), 0, 3);
+
+			if (strncmp("00000000", keyExpDate, 9) == 0 || strncmp(currentDate, keyExpDate, 9) < 0) // Evergreen or not expired
+			{
+				if (printMsg == 1 || printMsg == 2) cs_log("Key found: F %08X %s", provider, keyExpDate);
+				return 1;
+			}
+			else // Key expired
+			{
+				key = NULL; // Make sure we don't send any expired key
+				if (printMsg == 2) cs_log("Key expired: F %08X %s", provider, keyExpDate);
+				return 0;
+			}
+		}
+		else // Date-coded keys are disabled, don't evaluate expiration date
+		{
+			if (printMsg == 1 || printMsg == 2) cs_log("Key found: F %08X %s", provider, keyExpDate);
+			return 1;
+		}
+	}
+	else // Key not found
+	{
+		if (printMsg == 2) cs_log("Key not found: F %08X", provider);
+		return 0;
+	}
+}
+
+int8_t Biss1Mode1Ecm(struct s_reader *rdr, uint16_t caid, const uint8_t *ecm, uint8_t *dw, uint16_t srvid, uint16_t ecmpid)
+{
+	// Oscam's fake ecm consists of [sid] [pmtpid] [pid1] [pid2] ... [pidx] [tsid] [onid] [namespace]
+	//
+	// On enigma boxes tsid, onid and namespace should be non zero, while on non-enigma
+	// boxes they are usually all zero.
+	// The emulator creates a unique channel hash using srvid and enigma namespace or
+	// srvid, tsid, onid and namespace (in case of namespace without frequency) and
+	// another weaker (not unique) hash based on every pid of the channel. This universal
+	// hash should be available on all types of stbs (enigma and non-enigma).
+
+	// Flags inside [namespace]
+	//
+	// emu r748- : no namespace, no flag
+	// emu r749  : 0x80000000 (full namespase), 0xC0000000 (stripped namespace, injected with tsid^onid^ecmpid^0x1FFF)
+	// emu r752+ : 0xA0000000 (pure namespace, either full, stripped, or null)
+
+	// Key searches are made in order:
+	// Highest priority / tightest test first
+	// Lowest priority / loosest test last
+	//
+	// 1st: namespace hash (only on enigma boxes)
+	// 2nd: universal hash (all box types with emu r752+)
+	// 3rd: valid tsid, onid combination
+	// 4th: faulty ecmpid (other than 0x1FFF)
+	// 5th: reverse order pid (audio, video, pmt pids)
+	// 6th: standard BISS ecmpid (0x1FFF)
+	// 7th: default "All Feeds" key
+
+	// If enabled in the webif, a date based key search can be performed. If the expiration
+	// date has passed, the key is not sent from BissGetKey(). This search method is only
+	// used in the namespace hash, universal hash and the default "All Feeds" key.
+
+	uint32_t i, ens = 0, hash = 0;
+	uint16_t pid = 0, ecmLen = GetEcmLen(ecm);
+	uint8_t ecmCopy[ecmLen];
+	char tmpBuffer1[17], tmpBuffer2[90] = "0", tmpBuffer3[90] = "0";
+
+	// First try using the unique namespace hash (enigma only)
+	if (ecmLen >= 13) // ecmLen >= 13, allow patching the ecmLen for r749 ecms
+	{
+		memcpy(ecmCopy, ecm, ecmLen);
+		ens = b2i(4, ecm + ecmLen - 4); // Namespace will be the last 4 bytes
+
+		if (BissIsValidNamespace(ens)) // An r752+ extended ecm with valid namespace
+		{
+			BissUnifyOrbitals(&ens);
+			i2b_buf(4, ens, ecmCopy + ecmLen - 4);
+
+			for (i = 0; i < 5; i++) // Find key matching hash made with frequency modified to: f+0, then f-1, f+1, f-2, lastly f+2
+			{
+				ecmCopy[ecmLen - 1] = (i & 1) ? ecmCopy[ecmLen - 1] - i : ecmCopy[ecmLen - 1] + i; // frequency +/- 1, 2 MHz
+
+				if (0 != (ens & 0xFFFF)) // Full namespace - Calculate hash with srvid and namespace only
+				{
+					i2b_buf(2, srvid, ecmCopy + ecmLen - 6); // Put [srvid] right before [namespace]
+					hash = crc32(caid, ecmCopy + ecmLen - 6, 6);
+				}
+				else // Namespace without frequency - Calculate hash with srvid, tsid, onid and namespace
+				{
+					i2b_buf(2, srvid, ecmCopy + ecmLen - 10); // Put [srvid] right before [tsid] [onid] [namespace] sequence
+					hash = crc32(caid, ecmCopy + ecmLen - 10, 10);
+				}
+
+				if (BissGetKey(hash, dw, rdr->emu_datecodedenabled, i == 0 ? 2 : 1)) // Do not print "key not found" for frequency off by 1, 2
+				{
+					memcpy(dw + 8, dw, 8);
+					return 0;
+				}
+
+				if (i == 0) // No key found matching our hash: create example SoftCam.Key BISS line for the live log
+				{
+					BissAnnotate(tmpBuffer2, sizeof(tmpBuffer2), ecmCopy, ecmLen, hash, 1, rdr->emu_datecodedenabled);
+				}
+
+				if (0 == (ens & 0xFFFF)) // Namespace without frequency - Do not iterate
+				{
+					break;
+				}
+			}
+		}
+
+		if ((ens & 0xA0000000) == 0x80000000) // r749 ecms only (exclude r752+ ecms)
+		{
+			cs_log("Hey! Network buddy, you need to upgrade your OSCam-Emu");
+			ecmCopy[ecmLen] = 0xA0; // Patch ecm to look like r752+
+			ecmLen += 4;
+		}
+	}
+
+	// Try using the universal channel hash (namespace not available)
+	if (ecmLen >= 17) // ecmLen >= 17, length of r749 ecms has been patched to match r752+ ecms
+	{
+		ens = b2i(4, ecmCopy + ecmLen - 4); // Namespace will be last 4 bytes
+
+		if ((ens & 0xE0000000) == 0xA0000000) // We have an r752+ style ecm which contains pmtpid
+		{
+			memcpy(ecmCopy, ecm, ecmLen - 8); // Make a new ecmCopy from the original ecm as the old ecmCopy may be altered in namespace hash (skip [tsid] [onid] [namespace])
+			hash = crc32(caid, ecmCopy + 3, ecmLen - 3 - 8); // ecmCopy doesn't have [tsid] [onid] [namespace] part
+
+			if (BissGetKey(hash, dw, rdr->emu_datecodedenabled, 2)) // Key found
+			{
+				memcpy(dw + 8, dw, 8);
+				return 0;
+			}
+
+			// No key found matching our hash: create example SoftCam.Key BISS line for the live log
+			BissAnnotate(tmpBuffer3, sizeof(tmpBuffer3), ecmCopy, ecmLen, hash, 0, rdr->emu_datecodedenabled);
+		}
+	}
+
+	// Try using only [tsid][onid] (useful when many channels on a transpoder use the same key)
+	if (ecmLen >= 17) // ecmLen >= 17, length of r749 ecms has been patched to match r752+ ecms
+	{
+		ens = b2i(4, ecmCopy + ecmLen - 4); // Namespace will be last 4 bytes
+
+		// We have an r752+ style ecm with stripped namespace, thus a valid [tsid][onid] combo to use as provider
+		if ((ens & 0xE000FFFF) == 0xA0000000 && BissGetKey(b2i(4, ecm + ecmLen - 8), dw, 0, 2))
+		{
+			memcpy(dw + 8, dw, 8);
+			return 0;
+		}
+
+		if ((ens & 0xE0000000) == 0xA0000000) // Strip [tsid] [onid] [namespace] on r752+ ecms
+		{
+			ecmLen -= 8;
+		}
+	}
+
+	// Try using ecmpid if it seems to be faulty (should be 0x1FFF always for BISS)
+	if (ecmpid != 0x1FFF && ecmpid != 0)
+	{
+		if (BissGetKey((srvid << 16) | ecmpid, dw, 0, 2))
+		{
+			memcpy(dw + 8, dw, 8);
+			return 0;
+		}
+	}
+
+	// Try to get the pid from oscam's fake ecm (only search [pid1] [pid2] ... [pidx] to be compatible with emu r748-)
+	if (ecmLen >= 7) // Use >= 7 for radio channels with just one (audio) pid
+	{
+		// Reverse search order: last pid in list first
+		// Better identifies channels where they share identical video pid but have variable counts of audio pids
+		for (i = ecmLen - 2; i >= 5; i -= 2)
+		{
+			pid = b2i(2, ecm + i);
+
+			if (BissGetKey((srvid << 16) | pid, dw, 0, 2))
+			{
+				memcpy(dw + 8, dw, 8);
+				return 0;
+			}
+		}
+	}
+
+	// Try using the standard BISS ecm pid
+	if (ecmpid == 0x1FFF || ecmpid == 0)
+	{
+		if (BissGetKey((srvid << 16) | 0x1FFF, dw, 0, 2))
+		{
+			memcpy(dw + 8, dw, 8);
+			return 0;
+		}
+	}
+
+	// Default BISS key for events with many feeds sharing same key
+	if (ecmpid != 0 && BissGetKey(0xA11FEED5, dw, rdr->emu_datecodedenabled, 2)) // Limit to local ecms, block netwotk ecms
+	{
+		memcpy(dw + 8, dw, 8);
+		cs_hexdump(0, dw, 8, tmpBuffer1, sizeof(tmpBuffer1));
+		cs_log("No specific match found. Using 'All Feeds' key: %s", tmpBuffer1);
+		return 0;
+	}
+
+	// Print example key lines for available hash search methods, if no key is found
+	if (strncmp(tmpBuffer2, "0", 2)) cs_log("Example key based on namespace hash: %s", tmpBuffer2);
+	if (strncmp(tmpBuffer3, "0", 2)) cs_log("Example key based on universal hash: %s", tmpBuffer3);
+
+	// Check if universal hash is common and warn user
+	if (BissIsCommonHash(hash)) cs_log("Feed has commonly used pids, universal hash clashes in SoftCam.Key are likely!");
+
+	return 2;
+}
+
+int8_t BissEcm(struct s_reader *rdr, uint16_t caid, const uint8_t *ecm, uint8_t *dw, uint16_t srvid, uint16_t ecmpid)
+{
+	switch (caid)
+	{
+		case 0x2600:
+			return Biss1Mode1Ecm(rdr, caid, ecm, dw, srvid, ecmpid);
+
+		case 0x2602:
+			cs_log("Unsupported Biss 2 Mode 1/E ecm (caid %04X) - Please report!", caid);
+			return EMU_NOT_SUPPORTED;
+
+		case 0x2610:
+			cs_log("Unsupported Biss 2 Mode CA ecm (caid %04X) - Please report!", caid);
+			return EMU_NOT_SUPPORTED;
+
+		default:
+			cs_log("Unknown Biss caid %04X - Please report!", caid);
+			return EMU_NOT_SUPPORTED;
+	}
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-biss.h b/module-emulator-biss.h
new file mode 100644
index 0000000..8c227cb
--- /dev/null
+++ b/module-emulator-biss.h
@@ -0,0 +1,10 @@
+#ifndef MODULE_EMULATOR_BISS_H
+#define MODULE_EMULATOR_BISS_H
+
+#ifdef WITH_EMU
+
+int8_t BissEcm(struct s_reader *rdr, uint16_t caid, const uint8_t *ecm, uint8_t *dw, uint16_t srvid, uint16_t ecmpid);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_BISS_H
diff --git a/module-emulator-cryptoworks.c b/module-emulator-cryptoworks.c
new file mode 100644
index 0000000..3b68054
--- /dev/null
+++ b/module-emulator-cryptoworks.c
@@ -0,0 +1,522 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "cscrypt/des.h"
+#include "module-emulator-osemu.h"
+
+// Cryptoworks EMU
+static int8_t GetCwKey(uint8_t *buf,uint32_t ident, uint8_t keyIndex, uint32_t keyLength, uint8_t isCriticalKey)
+{
+
+	char keyName[EMU_MAX_CHAR_KEYNAME];
+	uint32_t tmp;
+
+	if((ident >> 4) == 0xD02A) {
+		keyIndex &=0xFE; // map to even number key indexes
+	}
+	if((ident >> 4) == 0xD00C) {
+		ident = 0x0D00C0; // map provider C? to C0
+	}
+	else if(keyIndex == 6 && ((ident >> 8) == 0x0D05)) {
+		ident = 0x0D0504; // always use provider 04 system key
+	}
+
+	tmp = keyIndex;
+	snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%.2X", tmp);
+	if(FindKey('W', ident, 0, keyName, buf, keyLength, isCriticalKey, 0, 0, NULL)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static const uint8_t cw_sbox1[64] = {
+	0xD8,0xD7,0x83,0x3D,0x1C,0x8A,0xF0,0xCF,0x72,0x4C,0x4D,0xF2,0xED,0x33,0x16,0xE0,
+	0x8F,0x28,0x7C,0x82,0x62,0x37,0xAF,0x59,0xB7,0xE0,0x00,0x3F,0x09,0x4D,0xF3,0x94,
+	0x16,0xA5,0x58,0x83,0xF2,0x4F,0x67,0x30,0x49,0x72,0xBF,0xCD,0xBE,0x98,0x81,0x7F,
+	0xA5,0xDA,0xA7,0x7F,0x89,0xC8,0x78,0xA7,0x8C,0x05,0x72,0x84,0x52,0x72,0x4D,0x38
+};
+static const uint8_t cw_sbox2[64] = {
+	0xD8,0x35,0x06,0xAB,0xEC,0x40,0x79,0x34,0x17,0xFE,0xEA,0x47,0xA3,0x8F,0xD5,0x48,
+	0x0A,0xBC,0xD5,0x40,0x23,0xD7,0x9F,0xBB,0x7C,0x81,0xA1,0x7A,0x14,0x69,0x6A,0x96,
+	0x47,0xDA,0x7B,0xE8,0xA1,0xBF,0x98,0x46,0xB8,0x41,0x45,0x9E,0x5E,0x20,0xB2,0x35,
+	0xE4,0x2F,0x9A,0xB5,0xDE,0x01,0x65,0xF8,0x0F,0xB2,0xD2,0x45,0x21,0x4E,0x2D,0xDB
+};
+static const uint8_t cw_sbox3[64] = {
+	0xDB,0x59,0xF4,0xEA,0x95,0x8E,0x25,0xD5,0x26,0xF2,0xDA,0x1A,0x4B,0xA8,0x08,0x25,
+	0x46,0x16,0x6B,0xBF,0xAB,0xE0,0xD4,0x1B,0x89,0x05,0x34,0xE5,0x74,0x7B,0xBB,0x44,
+	0xA9,0xC6,0x18,0xBD,0xE6,0x01,0x69,0x5A,0x99,0xE0,0x87,0x61,0x56,0x35,0x76,0x8E,
+	0xF7,0xE8,0x84,0x13,0x04,0x7B,0x9B,0xA6,0x7A,0x1F,0x6B,0x5C,0xA9,0x86,0x54,0xF9
+};
+static const uint8_t cw_sbox4[64] = {
+	0xBC,0xC1,0x41,0xFE,0x42,0xFB,0x3F,0x10,0xB5,0x1C,0xA6,0xC9,0xCF,0x26,0xD1,0x3F,
+	0x02,0x3D,0x19,0x20,0xC1,0xA8,0xBC,0xCF,0x7E,0x92,0x4B,0x67,0xBC,0x47,0x62,0xD0,
+	0x60,0x9A,0x9E,0x45,0x79,0x21,0x89,0xA9,0xC3,0x64,0x74,0x9A,0xBC,0xDB,0x43,0x66,
+	0xDF,0xE3,0x21,0xBE,0x1E,0x16,0x73,0x5D,0xA2,0xCD,0x8C,0x30,0x67,0x34,0x9C,0xCB
+};
+static const uint8_t AND_bit1[8] = {0x00,0x40,0x04,0x80,0x21,0x10,0x02,0x08};
+static const uint8_t AND_bit2[8] = {0x80,0x08,0x01,0x40,0x04,0x20,0x10,0x02};
+static const uint8_t AND_bit3[8] = {0x82,0x40,0x01,0x10,0x00,0x20,0x04,0x08};
+static const uint8_t AND_bit4[8] = {0x02,0x10,0x04,0x40,0x80,0x08,0x01,0x20};
+
+static void CW_SWAP_KEY(uint8_t *key)
+{
+	uint8_t k[8];
+	memcpy(k, key, 8);
+	memcpy(key, key + 8, 8);
+	memcpy(key + 8, k, 8);
+}
+
+static void CW_SWAP_DATA(uint8_t *k)
+{
+	uint8_t d[4];
+	memcpy(d, k + 4, 4);
+	memcpy(k + 4 ,k ,4);
+	memcpy(k, d, 4);
+}
+
+static void CW_DES_ROUND(uint8_t *d, uint8_t *k)
+{
+	uint8_t aa[44] = {1,0,3,1,2,2,3,2,1,3,1,1,3,0,1,2,3,1,3,2,2,0,7,6,5,4,7,6,5,7,6,5,6,7,5,7,5,7,6,6,7,5,4,4};
+	uint8_t bb[44] = {0x80,0x08,0x10,0x02,0x08,0x40,0x01,0x20,0x40,0x80,0x04,0x10,0x04,0x01,0x01,0x02,0x20,0x20,0x02,0x01,
+					  0x80,0x04,0x02,0x02,0x08,0x02,0x10,0x80,0x01,0x20,0x08,0x80,0x01,0x08,0x40,0x01,0x02,0x80,0x10,0x40,0x40,0x10,0x08,0x01
+					 };
+	uint8_t ff[4] = {0x02,0x10,0x04,0x04};
+	uint8_t l[24] = {0,2,4,6,7,5,3,1,4,5,6,7,7,6,5,4,7,4,5,6,4,7,6,5};
+
+	uint8_t des_td[8], i, o, n, c = 1, m = 0, r = 0, *a = aa, *b = bb, *f = ff, *p1 = l, *p2 = l+8, *p3 = l+16;
+
+	for (m = 0; m < 2; m++) {
+		for(i = 0; i < 4; i++) {
+			des_td[*p1++] =
+				(m) ? ((d[*p2++]*2) & 0x3F) | ((d[*p3++] & 0x80) ? 0x01 : 0x00): (d[*p2++]/2) | ((d[*p3++] & 0x01) ? 0x80 : 0x00);
+		}
+	}
+
+	for (i = 0; i < 8; i++) {
+		c = (c) ? 0 : 1;
+		r = (c) ? 6 : 7;
+		n = (i) ? i-1 : 1;
+		o = (c) ? ((k[n] & *f++) ? 1 : 0) : des_td[n];
+		for (m = 1; m < r; m++) {
+			o = (c) ? (o*2) | ((k[*a++] & *b++) ? 0x01 : 0x00) : (o/2) | ((k[*a++] & *b++) ? 0x80 : 0x00);
+		}
+		n = (i) ? n+1 : 0;
+		des_td[n] = (c) ? des_td[n] ^ o : (o ^ des_td[n] )/4;
+	}
+
+	for( i = 0; i < 8; i++) {
+		d[0] ^= (AND_bit1[i] & cw_sbox1[des_td[i]]);
+		d[1] ^= (AND_bit2[i] & cw_sbox2[des_td[i]]);
+		d[2] ^= (AND_bit3[i] & cw_sbox3[des_td[i]]);
+		d[3] ^= (AND_bit4[i] & cw_sbox4[des_td[i]]);
+	}
+
+	CW_SWAP_DATA(d);
+}
+
+static void CW_48_Key(uint8_t *inkey, uint8_t *outkey, uint8_t algotype)
+{
+	uint8_t Round_Counter, i = 8, *key128 = inkey, *key48 = inkey + 0x10;
+	Round_Counter = 7 - (algotype & 7);
+
+	memset(outkey, 0, 16);
+	memcpy(outkey, key48, 6);
+
+	for( ; i > Round_Counter; i--) {
+		if (i > 1) {
+			outkey[i-2] = key128[i];
+		}
+	}
+}
+
+static void CW_LS_DES_KEY(uint8_t *key,uint8_t Rotate_Counter)
+{
+	uint8_t round[] = {1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,1};
+	uint8_t i, n;
+	uint16_t k[8];
+
+	n = round[Rotate_Counter];
+
+	for (i = 0; i < 8; i++) {
+		k[i] = key[i];
+	}
+
+	for (i = 1; i < n + 1; i++) {
+		k[7] = (k[7]*2) | ((k[4] & 0x008) ? 1 : 0);
+		k[6] = (k[6]*2) | ((k[7] & 0xF00) ? 1 : 0);
+		k[7] &=0xff;
+		k[5] = (k[5]*2) | ((k[6] & 0xF00) ? 1 : 0);
+		k[6] &=0xff;
+		k[4] = ((k[4]*2) | ((k[5] & 0xF00) ? 1 : 0)) & 0xFF;
+		k[5] &= 0xff;
+		k[3] = (k[3]*2) | ((k[0] & 0x008) ? 1 : 0);
+		k[2] = (k[2]*2) | ((k[3] & 0xF00) ? 1 : 0);
+		k[3] &= 0xff;
+		k[1] = (k[1]*2) | ((k[2] & 0xF00) ? 1 : 0);
+		k[2] &= 0xff;
+		k[0] = ((k[0]*2) | ((k[1] & 0xF00) ? 1 : 0)) & 0xFF;
+		k[1] &= 0xff;
+	}
+	for (i = 0; i < 8; i++) {
+		key[i] = (uint8_t) k[i];
+	}
+}
+
+static void CW_RS_DES_KEY(uint8_t *k, uint8_t Rotate_Counter)
+{
+	uint8_t i,c;
+	for (i = 1; i < Rotate_Counter+1; i++) {
+		c = (k[3] & 0x10) ? 0x80 : 0;
+		k[3] /= 2;
+		if (k[2] & 1) {
+			k[3] |= 0x80;
+		}
+		k[2] /= 2;
+		if (k[1] & 1) {
+			k[2] |= 0x80;
+		}
+		k[1] /= 2;
+		if (k[0] & 1) {
+			k[1] |= 0x80;
+		}
+		k[0] /= 2;
+		k[0] |= c ;
+		c = (k[7] & 0x10) ? 0x80 : 0;
+		k[7] /= 2;
+		if (k[6] & 1) {
+			k[7] |= 0x80;
+		}
+		k[6] /= 2;
+		if (k[5] & 1) {
+			k[6] |= 0x80;
+		}
+		k[5] /= 2;
+		if (k[4] & 1) {
+			k[5] |= 0x80;
+		}
+		k[4] /= 2;
+		k[4] |= c;
+	}
+}
+
+static void CW_RS_DES_SUBKEY(uint8_t *k, uint8_t Rotate_Counter)
+{
+	uint8_t round[] = {1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1};
+	CW_RS_DES_KEY(k, round[Rotate_Counter]);
+}
+
+static void CW_PREP_KEY(uint8_t *key )
+{
+	uint8_t DES_key[8],j;
+	int32_t Round_Counter = 6,i,a;
+	key[7] = 6;
+	memset(DES_key, 0 , 8);
+	do {
+		a = 7;
+		i = key[7];
+		j = key[Round_Counter];
+		do {
+			DES_key[i] = ( (DES_key[i] * 2) | ((j & 1) ? 1: 0) ) & 0xFF;
+			j /=2;
+			i--;
+			if (i < 0) {
+				i = 6;
+			}
+			a--;
+		}
+		while (a >= 0);
+		key[7] = i;
+		Round_Counter--;
+	}
+	while ( Round_Counter >= 0 );
+	a = DES_key[4];
+	DES_key[4] = DES_key[6];
+	DES_key[6] = a;
+	DES_key[7] = (DES_key[3] * 16) & 0xFF;
+	memcpy(key,DES_key,8);
+	CW_RS_DES_KEY(key,4);
+}
+
+static void CW_L2DES(uint8_t *data, uint8_t *key, uint8_t algo)
+{
+	uint8_t i, k0[22], k1[22];
+	memcpy(k0,key,22);
+	memcpy(k1,key,22);
+	CW_48_Key(k0, k1,algo);
+	CW_PREP_KEY(k1);
+	for (i = 0; i< 2; i++) {
+		CW_LS_DES_KEY( k1,15);
+		CW_DES_ROUND( data ,k1);
+	}
+}
+
+static void CW_R2DES(uint8_t *data, uint8_t *key, uint8_t algo)
+{
+	uint8_t i, k0[22],k1[22];
+	memcpy(k0,key,22);
+	memcpy(k1,key,22);
+	CW_48_Key(k0, k1, algo);
+	CW_PREP_KEY(k1);
+	for (i = 0; i< 2; i++) {
+		CW_LS_DES_KEY(k1,15);
+	}
+	for (i = 0; i< 2; i++) {
+		CW_DES_ROUND( data ,k1);
+		CW_RS_DES_SUBKEY(k1,1);
+	}
+	CW_SWAP_DATA(data);
+}
+
+static void CW_DES(uint8_t *data, uint8_t *inkey, uint8_t m)
+{
+	uint8_t key[22], i;
+	memcpy(key, inkey + 9, 8);
+	CW_PREP_KEY( key );
+	for (i = 16; i > 0; i--) {
+		if (m == 1) {
+			CW_LS_DES_KEY(key, (uint8_t) (i-1));
+		}
+		CW_DES_ROUND( data ,key);
+		if (m == 0) {
+			CW_RS_DES_SUBKEY(key, (uint8_t) (i-1));
+		}
+	}
+}
+
+static void CW_DEC_ENC(uint8_t *d, uint8_t *k, uint8_t a,uint8_t m)
+{
+	uint8_t n = m & 1;
+	CW_L2DES(d , k, a);
+	CW_DES (d , k, n);
+	CW_R2DES(d , k, a);
+	if (m & 2) {
+		CW_SWAP_KEY(k);
+	}
+}
+
+static uint8_t CryptoworksProcessNano80(uint8_t *data, uint32_t caid, int32_t provider, uint8_t *opKey, uint8_t nanoLength, uint8_t nano80Algo)
+{
+	int32_t i, j;
+	uint8_t key[16], desKey[16], t[8], dat1[8], dat2[8], k0D00C000[16];
+	if(nanoLength < 11) {
+		return 0;
+	}
+	if(caid == 0x0D00 && provider != 0xA0 && !GetCwKey(k0D00C000, 0x0D00C0, 0, 16, 1)) {
+		return 0;
+	}
+
+	if(nano80Algo > 1) {
+		return 0;
+	}
+
+	memset(t, 0, 8);
+	memcpy(dat1, data, 8);
+
+	if(caid == 0x0D00 && provider != 0xA0) {
+		memcpy(key, k0D00C000, 16);
+	}
+	else {
+		memcpy(key, opKey, 16);
+	}
+	_3DES(data, key);
+	memcpy(desKey, data, 8);
+
+	memcpy(data, dat1, 8);
+	if(caid == 0x0D00 && provider != 0xA0) {
+		memcpy(key, &k0D00C000[8], 8);
+		memcpy(&key[8], k0D00C000, 8);
+	}
+	else {
+		memcpy(key, &opKey[8], 8);
+		memcpy(&key[8], opKey, 8);
+	}
+	_3DES(data, key);
+	memcpy(&desKey[8], data, 8);
+
+	for(i=8; i+7<nanoLength; i+=8) {
+		memcpy(dat1, &data[i], 8);
+		memcpy(dat2, dat1, 8);
+		memcpy(key, desKey, 16);
+		_3DES(dat1, key);
+		for(j=0; j<8; j++) {
+			dat1[j] ^= t[j];
+		}
+		memcpy(&data[i], dat1, 8);
+		memcpy(t, dat2, 8);
+	}
+
+	return data[10] + 5;
+}
+
+static void CryptoworksSignature(const uint8_t *data, uint32_t length, uint8_t *key, uint8_t *signature)
+{
+	uint32_t i, sigPos;
+	int8_t algo, first;
+
+	algo = data[0] & 7;
+	if(algo == 7) {
+		algo = 6;
+	}
+	memset(signature, 0, 8);
+	first = 1;
+	sigPos = 0;
+	for(i=0; i<length; i++) {
+		signature[sigPos] ^= data[i];
+		sigPos++;
+
+		if(sigPos > 7) {
+			if (first) {
+				CW_L2DES(signature, key, algo);
+			}
+			CW_DES(signature, key, 1);
+
+			sigPos = 0;
+			first = 0;
+		}
+	}
+	if(sigPos > 0) {
+		CW_DES(signature, key, 1);
+	}
+	CW_R2DES(signature, key, algo);
+}
+
+static void CryptoworksDecryptDes(uint8_t *data, uint8_t algo, uint8_t *key)
+{
+	int32_t i;
+	uint8_t k[22], t[8];
+
+	algo &= 7;
+	if(algo<7) {
+		CW_DEC_ENC(data, key, algo, 0);
+	}
+	else {
+		memcpy(k, key, 22);
+		for(i=0; i<3; i++) {
+			CW_DEC_ENC(data, k, algo, i&1);
+			memcpy(t,k,8);
+			memcpy(k,k+8,8);
+			memcpy(k+8,t,8);
+		}
+	}
+}
+
+int8_t CryptoworksECM(uint32_t caid, uint8_t *ecm, uint8_t *cw)
+{
+	uint32_t ident;
+	uint8_t keyIndex = 0, nanoLength, newEcmLength, key[22], signature[8], nano80Algo = 1;
+	int32_t provider = -1;
+	uint16_t i, j, ecmLen = GetEcmLen(ecm);
+
+	if(ecmLen < 8) {
+		return 1;
+	}
+	if(ecm[7] != ecmLen - 8) {
+		return 1;
+	}
+
+	memset(key, 0, 22);
+
+	for(i = 8; i+1 < ecmLen; i += ecm[i+1] + 2) {
+		if(ecm[i] == 0x83 && i+2 < ecmLen) {
+			provider = ecm[i+2] & 0xFC;
+			keyIndex = ecm[i+2] & 3;
+			keyIndex = keyIndex ? 1 : 0;
+		}
+		else if(ecm[i] == 0x84 && i+3 < ecmLen) {
+			//nano80Provider = ecm[i+2] & 0xFC;
+			//nano80KeyIndex = ecm[i+2] & 3;
+			//nano80KeyIndex = nano80KeyIndex ? 1 : 0;
+			nano80Algo = ecm[i+3];
+		}
+	}
+
+	if(provider < 0) {
+		switch(caid) {
+		case 0x0D00:
+			provider = 0xC0;
+			break;
+		case 0x0D02:
+			provider = 0xA0;
+			break;
+		case 0x0D03:
+			provider = 0x04;
+			break;
+		case 0x0D05:
+			provider = 0x04;
+			break;
+		default:
+			return 1;
+		}
+	}
+
+	ident = (caid << 8) | provider;
+	if(!GetCwKey(key, ident, keyIndex, 16, 1)) {
+		return 2;
+	}
+	if(!GetCwKey(&key[16], ident, 6, 6, 1)) {
+		return 2;
+	}
+
+	for(i = 8; i+1 < ecmLen; i += ecm[i+1] + 2) {
+		if(ecm[i] == 0x80 && i+2+7 < ecmLen && i+2+ecm[i+1] <= ecmLen
+				&& (provider == 0xA0 || provider == 0xC0 || provider == 0xC4 || provider == 0xC8)) {
+			nanoLength = ecm[i+1];
+			newEcmLength = CryptoworksProcessNano80(ecm+i+2, caid, provider, key, nanoLength, nano80Algo);
+			if(newEcmLength == 0 || newEcmLength > ecmLen-(i+2+3)) {
+				return 1;
+			}
+			ecm[i+2+3] = 0x81;
+			ecm[i+2+4] = 0x70;
+			ecm[i+2+5] = newEcmLength;
+			ecm[i+2+6] = 0x81;
+			ecm[i+2+7] = 0xFF;
+			return CryptoworksECM(caid, ecm+i+2+3, cw);
+		}
+	}
+
+	if(ecmLen - 15 < 1) {
+		return 1;
+	}
+	CryptoworksSignature(ecm + 5, ecmLen - 15, key, signature);
+	for(i = 8; i+1 < ecmLen; i += ecm[i+1]+2) {
+		switch(ecm[i]) {
+		case 0xDA:
+		case 0xDB:
+		case 0xDC:
+			if(i+2+ecm[i+1] > ecmLen) {
+				break;
+			}
+			for(j=0; j+7<ecm[i+1]; j+=8) {
+				CryptoworksDecryptDes(&ecm[i+2+j], ecm[5], key);
+			}
+			break;
+		case 0xDF:
+			if(i+2+8 > ecmLen) {
+				break;
+			}
+			if(memcmp(&ecm[i+2], signature, 8)) {
+				return 6;
+			}
+			break;
+		}
+	}
+
+	for(i = 8; i+1 < ecmLen; i += ecm[i+1]+2) {
+		switch(ecm[i]) {
+		case 0xDB:
+			if(i+2+ecm[i+1] <= ecmLen && ecm[i+1] == 16) {
+				memcpy(cw, &ecm[i+2], 16);
+				return 0;
+			}
+			break;
+		}
+	}
+
+	return 5;
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-cryptoworks.h b/module-emulator-cryptoworks.h
new file mode 100644
index 0000000..c72a2dc
--- /dev/null
+++ b/module-emulator-cryptoworks.h
@@ -0,0 +1,10 @@
+#ifndef MODULE_EMULATOR_CRYPTOWORKS_H
+#define MODULE_EMULATOR_CRYPTOWORKS_H
+
+#ifdef WITH_EMU
+
+int8_t CryptoworksECM(uint32_t caid, uint8_t *ecm, uint8_t *cw);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_CRYPTOWORKS_H
diff --git a/module-emulator-director.c b/module-emulator-director.c
new file mode 100644
index 0000000..826ad7f
--- /dev/null
+++ b/module-emulator-director.c
@@ -0,0 +1,636 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "cscrypt/des.h"
+#include "module-emulator-osemu.h"
+#include "oscam-aes.h"
+#include "oscam-string.h"
+
+/*************************************************************************************************/
+
+// Shared functions
+
+static uint16_t DirectorChecksum(uint8_t *data, uint8_t length)
+{
+	/*
+	 * ECM and EMM checksum calculation
+	 * 1. Combine data in 2 byte groups
+	 * 2. Add them together
+	 * 3. Multiply result by itself (power of 7)
+	 * 4. XOR with fixed value 0x17E3
+	*/
+
+	uint8_t i;
+	uint16_t checksum = 0;
+
+	for (i = 0; i < length; i += 2)
+	{
+		checksum += (data[i] << 8) | data[i + 1];
+	}
+
+	checksum = checksum * checksum * checksum * checksum * checksum * checksum * checksum;
+	checksum ^= 0x17E3;
+
+	return checksum;
+}
+
+static inline int8_t DirectorGetKey(uint32_t keyIndex, char *keyName, uint8_t *key, uint32_t keyLength)
+{
+	/*
+	 * keyIndex meaning for:
+	 * ecm keys --> entitlementId
+	 * emm keys --> aeskeyIndex
+	 * aes keys --> keyIndex
+	 *
+	 * keyName meaning for:
+	 * ecm keys --> "01"
+	 * emm keys --> "MK" or "MK01"
+	 * aes keys --> "AES"
+	*/
+
+	return FindKey('T', keyIndex, 0, keyName, key, keyLength, 1, 0, 0, NULL);
+}
+
+/*************************************************************************************************/
+
+/*
+ * Director ECM emulator
+ * Supported versions: v4, v5, v6 (not working correctly)
+*/
+
+int8_t DirectorEcm(uint8_t *ecm, uint8_t *dw)
+{
+	uint8_t nanoType, nanoLength;
+	uint8_t* nanoData;
+	uint32_t pos = 3;
+	uint32_t entitlementId;
+	uint32_t ks[32];
+	uint8_t ecmKey[8];
+	uint16_t ecmLen = GetEcmLen(ecm);
+
+	if (ecmLen < 5)
+	{
+		return EMU_NOT_SUPPORTED;
+	}
+
+	do
+	{
+		nanoType = ecm[pos];
+		nanoLength = ecm[pos + 1];
+
+		if (pos + 2 + nanoLength > ecmLen)
+		{
+			break;
+		}
+
+		nanoData = ecm + pos + 2;
+
+		// ECM validation
+		uint16_t payloadChecksum = (nanoData[nanoLength - 2] << 8) | nanoData[nanoLength - 1];
+		uint16_t calculatedChecksum = DirectorChecksum(nanoData, nanoLength - 2);
+
+		if (calculatedChecksum != payloadChecksum)
+		{
+			cs_log_dbg(D_READER, "ECM checksum error (%.4X instead of %.4X)", calculatedChecksum, payloadChecksum);
+			return EMU_CHECKSUM_ERROR;
+		}
+		// End of ECM validation
+
+		switch (nanoType)
+		{
+			case 0xEC: // Director v6 (September 2017)
+			{
+				if (nanoLength != 0x28)
+				{
+					cs_log_dbg(D_READER, "WARNING: nanoType EC length (%d) != %d", nanoLength, 0x28);
+					break;
+				}
+
+				entitlementId = b2i(4, nanoData);
+				cs_log_dbg(D_READER, "INFO: Using entitlement id %.4X", entitlementId);
+
+				if (!DirectorGetKey(entitlementId, "01", ecmKey, 8))
+				{
+					return EMU_KEY_NOT_FOUND;
+				}
+
+				// Step 1 - Decrypt DES CBC with ecmKey and iv = { 0 } (equal to nanoED)
+				uint8_t encryptedData[32] = { 0 };
+				memcpy(encryptedData, nanoData + 6, 32);
+
+				uint8_t iv[8] = { 0 };
+				des_cbc_decrypt(encryptedData, iv, ecmKey, 32);
+
+				uint8_t nanoMode = nanoData[5];
+
+				if ((nanoMode & 0x20) == 0) // Old algo
+				{
+					// Step 2 - Create CW (equal to nano ED)
+					dw[0] = encryptedData[0x05];
+					dw[1] = encryptedData[0x19];
+					dw[2] = encryptedData[0x1D];
+					dw[3] = (dw[0] + dw[1] + dw[2]) & 0xFF;
+					dw[4] = encryptedData[0x0B];
+					dw[5] = encryptedData[0x12];
+					dw[6] = encryptedData[0x1A];
+					dw[7] = (dw[4] + dw[5] + dw[6]) & 0xFF;
+					dw[8] = encryptedData[0x16];
+					dw[9] = encryptedData[0x03];
+					dw[10] = encryptedData[0x11];
+					dw[11] = (dw[8] + dw[9] + dw[10]) & 0xFF;
+					dw[12] = encryptedData[0x18];
+					dw[13] = encryptedData[0x10];
+					dw[14] = encryptedData[0x0E];
+					dw[15] = (dw[12] + dw[13] + dw[14]) & 0xFF;
+
+					return EMU_OK;
+				}
+				else // New algo (overencryption with AES)
+				{
+					// Step 2 - Prepare data for AES (it is like the creation of CW in nanoED but swapped each 8 bytes)
+					uint8_t dataEC[16] = { 0 };
+
+					dataEC[0] = encryptedData[0x02];
+					dataEC[1] = encryptedData[0x0E];
+					dataEC[2] = encryptedData[0x10];
+					dataEC[3] = encryptedData[0x18];
+					dataEC[4] = encryptedData[0x09];
+					dataEC[5] = encryptedData[0x11];
+					dataEC[6] = encryptedData[0x03];
+					dataEC[7] = encryptedData[0x16];
+
+					dataEC[8] = encryptedData[0x13];
+					dataEC[9] = encryptedData[0x1A];
+					dataEC[10] = encryptedData[0x12];
+					dataEC[11] = encryptedData[0x0B];
+					dataEC[12] = encryptedData[0x04];
+					dataEC[13] = encryptedData[0x1D];
+					dataEC[14] = encryptedData[0x19];
+					dataEC[15] = encryptedData[0x05];
+
+					// Step 3 - Decrypt AES CBC with new aesKey and iv 2EBD816A5E749A708AE45ADDD84333DE
+					uint8_t aesKeyIndex = nanoMode & 0x1F; // 32 possible AES keys
+					uint8_t aesKey[16] = { 0 };
+
+					char tmpBuffer[33];
+					cs_hexdump(0, aesKey, 16, tmpBuffer, sizeof(tmpBuffer));
+					cs_log_dbg(D_READER, "INFO: Using AES key index: %02X, value: %s", aesKeyIndex, tmpBuffer);
+
+					if (!DirectorGetKey(aesKeyIndex, "AES", aesKey, 16))
+					{
+						return EMU_KEY_NOT_FOUND;
+					}
+
+					struct aes_keys aes;
+					aes_set_key(&aes, (char *)aesKey);
+
+					uint8_t ivAes[16] = { 0x2E, 0xBD, 0x81, 0x6A, 0x5E, 0x74, 0x9A, 0x70, 0x8A, 0xE4, 0x5A, 0xDD, 0xD8, 0x43, 0x33, 0xDE };
+					aes_cbc_decrypt(&aes, dataEC, 16, ivAes);
+
+					// Step 4 - Create CW (a simple swap)
+					uint8_t offset;
+					for (offset = 0; offset < 16; offset++)
+					{
+						dw[offset] = dataEC[15 - offset];
+					}
+
+					return EMU_OK;
+				}
+			}
+
+			case 0xED: // Director v5 (September 2016)
+			{
+				if (nanoLength != 0x26)
+				{
+					cs_log_dbg(D_READER, "WARNING: nanoType ED length (%d) != %d", nanoLength, 0x26);
+					break;
+				}
+
+				entitlementId = b2i(4, nanoData);
+				cs_log_dbg(D_READER, "INFO: Using entitlement id %.4X", entitlementId);
+
+				if (!DirectorGetKey(entitlementId, "01", ecmKey, 8))
+				{
+					return EMU_KEY_NOT_FOUND;
+				}
+
+				uint8_t encryptedData[32] = { 0 };
+				memcpy(encryptedData, nanoData + 4, 32);
+
+				uint8_t iv[8] = { 0 };
+				des_cbc_decrypt(encryptedData, iv, ecmKey, 32);
+
+				dw[0] = encryptedData[0x05];
+				dw[1] = encryptedData[0x19];
+				dw[2] = encryptedData[0x1D];
+				dw[3] = (dw[0] + dw[1] + dw[2]) & 0xFF;
+				dw[4] = encryptedData[0x0B];
+				dw[5] = encryptedData[0x12];
+				dw[6] = encryptedData[0x1A];
+				dw[7] = (dw[4] + dw[5] + dw[6]) & 0xFF;
+				dw[8] = encryptedData[0x16];
+				dw[9] = encryptedData[0x03];
+				dw[10] = encryptedData[0x11];
+				dw[11] = (dw[8] + dw[9] + dw[10]) & 0xFF;
+				dw[12] = encryptedData[0x18];
+				dw[13] = encryptedData[0x10];
+				dw[14] = encryptedData[0x0E];
+				dw[15] = (dw[12] + dw[13] + dw[14]) & 0xFF;
+
+				return EMU_OK;
+			}
+
+			case 0xEE: // Director v4
+			{
+				if (nanoLength != 0x16)
+				{
+					cs_log_dbg(D_READER, "WARNING: nanoType EE length (%d) != %d", nanoLength, 0x16);
+					break;
+				}
+
+				entitlementId = b2i(4, nanoData);
+				cs_log_dbg(D_READER, "INFO: Using entitlement id %.4X", entitlementId);
+
+				if (!DirectorGetKey(entitlementId, "01", ecmKey, 8))
+				{
+					return EMU_KEY_NOT_FOUND;
+				}
+
+				memcpy(dw, nanoData + 4 + 8, 8); // even
+				memcpy(dw + 8, nanoData + 4, 8); // odd
+
+				des_set_key(ecmKey, ks);
+
+				des(dw, ks, 0);
+				des(dw + 8, ks, 0);
+
+				return EMU_OK;
+			}
+
+			default:
+				cs_log_dbg(D_READER, "WARNING: nanoType %.2X not supported", nanoType);
+				return EMU_NOT_SUPPORTED;
+		}
+
+		pos += 2 + nanoLength;
+
+	} while (pos < ecmLen);
+
+	return EMU_NOT_SUPPORTED;
+}
+
+/*************************************************************************************************/
+
+/*
+ * Director EMM emulator
+ * Supported versions: v4, v5, v6 (same as v5)
+*/
+
+static uint8_t MixTable[] =
+{
+	0x12, 0x78, 0x4B, 0x19, 0x13, 0x80, 0x2F, 0x84, 0x86, 0x4C, 0x09, 0x53, 0x15, 0x79, 0x6B, 0x49,
+	0x10, 0x4D, 0x33, 0x43, 0x18, 0x37, 0x83, 0x38, 0x82, 0x1B, 0x6E, 0x24, 0x2A, 0x85, 0x3C, 0x3D,
+	0x5A, 0x58, 0x55, 0x5D, 0x20, 0x41, 0x65, 0x51, 0x0C, 0x45, 0x63, 0x7F, 0x0F, 0x46, 0x21, 0x7C,
+	0x2C, 0x61, 0x7E, 0x0A, 0x42, 0x57, 0x35, 0x16, 0x87, 0x3B, 0x4F, 0x40, 0x34, 0x22, 0x26, 0x74,
+	0x32, 0x69, 0x44, 0x7A, 0x6A, 0x6D, 0x0D, 0x56, 0x23, 0x2B, 0x5C, 0x72, 0x76, 0x36, 0x28, 0x25,
+	0x2E, 0x52, 0x5B, 0x6C, 0x7D, 0x30, 0x0B, 0x5E, 0x47, 0x1F, 0x7B, 0x31, 0x3E, 0x11, 0x77, 0x1E,
+	0x60, 0x75, 0x54, 0x27, 0x50, 0x17, 0x70, 0x59, 0x1A, 0x2D, 0x4A, 0x67, 0x3A, 0x5F, 0x68, 0x08,
+	0x4E, 0x3F, 0x29, 0x6F, 0x81, 0x71, 0x39, 0x64, 0x48, 0x66, 0x73, 0x14, 0x0E, 0x1D, 0x62, 0x1C
+};
+
+/*
+static void DirectorRotateBytes(uint8_t *in, int8_t n)
+{
+	if (n > 1)
+	{
+		uint8_t *e = in + n - 1;
+		do
+		{
+			uint8_t temp = *in;
+			*in++ = *e;
+			*e-- = temp;
+		}
+		while (in < e);
+	}
+}
+*/
+
+static void DirectorDecryptEcmKey(uint8_t *emmKey, uint8_t *tagData, uint8_t *ecmKey)
+{
+	uint8_t temp, *e, *payLoad, iv[8] = { 0 };
+
+	//DirectorRotateBytes(emmKey, 8);
+
+	e = emmKey + 8 - 1;
+	do
+	{
+		temp = *emmKey;
+		*emmKey++ = *e;
+		*e-- = temp;
+	}
+	while (emmKey < e);
+
+	payLoad = tagData + 4 + 5;
+	des_cbc_decrypt(payLoad, iv, emmKey, 16);
+
+	ecmKey[0] = payLoad[0x0F];
+	ecmKey[1] = payLoad[0x01];
+	ecmKey[2] = payLoad[0x0B];
+	ecmKey[3] = payLoad[0x03];
+	ecmKey[4] = payLoad[0x0E];
+	ecmKey[5] = payLoad[0x04];
+	ecmKey[6] = payLoad[0x0A];
+	ecmKey[7] = payLoad[0x08];
+}
+
+static int8_t DirectorParseEmmNanoTags(uint8_t* data, uint32_t length, uint8_t keyIndex, uint32_t *keysAdded)
+{
+	uint8_t tagType, tagLength, *tagData, blockIndex, emmKey[8], tagDataDecrypted[16][8];
+	uint32_t pos = 0, entitlementId, ks[32];
+	int32_t i, k;
+	char keyValue[17];
+
+	if (length < 2)
+	{
+		return EMU_NOT_SUPPORTED;
+	}
+
+	while (pos < length)
+	{
+		tagType = data[pos];
+		tagLength = data[pos+1];
+
+		if (pos + 2 + tagLength > length)
+		{
+			return EMU_CORRUPT_DATA;
+		}
+
+		tagData = data + pos + 2;
+
+		switch (tagType)
+		{
+			case 0xE4: // EMM_TAG_SECURITY_TABLE_DESCRIPTOR (ram emm keys)
+			{
+				uint8_t tagMode = data[pos + 2];
+
+				switch (tagMode)
+				{
+					case 0x01: // keySet 01 (MK01)
+					{
+						if (tagLength != 0x8A)
+						{
+							cs_log_dbg(D_READER, "WARNING: nanoTag E4 length (%d) != %d", tagLength, 0x8A);
+							return EMU_NOT_SUPPORTED;
+						}
+
+						if (!DirectorGetKey(keyIndex, "MK01", emmKey, 8))
+						{
+							return EMU_KEY_NOT_FOUND;
+						}
+
+						uint8_t iv[8] = { 0 };
+						uint8_t* tagPayload = tagData + 2;
+						des_cbc_decrypt(tagPayload, iv, emmKey, 136);
+
+						for (k = 0; k < 16; k++) // loop 16 keys
+						{
+							for (i = 0; i < 8; i++) // loop 8 bytes of key
+							{
+								tagDataDecrypted[k][i] = tagPayload[MixTable[8 * k + i]];
+							}
+						}
+
+						blockIndex = tagData[1] & 0x03;
+
+						SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+						for (i = 0; i < 16; i++)
+						{
+							SetKey('T', (blockIndex << 4) + i, "MK01", tagDataDecrypted[i], 8, 0, NULL, NULL);
+						}
+						SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+					}
+					break;
+
+					case 0xFF: // keySet FF (MK)
+					{
+						if (tagLength != 0x82)
+						{
+							cs_log_dbg(D_READER, "WARNING: nanoTag E4 length (%d) != %d", tagLength, 0x82);
+							return EMU_NOT_SUPPORTED;
+						}
+
+						if (!DirectorGetKey(keyIndex, "MK", emmKey, 8))
+						{
+							return EMU_KEY_NOT_FOUND;
+						}
+
+						des_set_key(emmKey, ks);
+
+						for (i = 0; i < 16; i++)
+						{
+							des(tagData + 2 + (i * 8), ks, 0);
+						}
+
+						blockIndex = tagData[1] & 0x03;
+
+						SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+						for (i = 0; i < 16; i++)
+						{
+							SetKey('T', (blockIndex << 4) + i, "MK", tagData + 2 + (i * 8), 8, 0, NULL, NULL);
+						}
+						SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+					}
+					break;
+
+					default:
+						cs_log_dbg(D_READER, "WARNING: nanoTag E4 mode %.2X not supported", tagMode);
+						return EMU_NOT_SUPPORTED;
+				}
+				break;
+			}
+
+			case 0xE1: // EMM_TAG_EVENT_ENTITLEMENT_DESCRIPTOR (ecm keys)
+			{
+				uint8_t tagMode = data[pos + 2 + 4];
+
+				switch (tagMode)
+				{
+					case 0x00: // ecm keys from mode FF
+					{
+						if (tagLength != 0x12)
+						{
+							cs_log_dbg(D_READER, "WARNING: nanoTag E1 length (%d) != %d", tagLength, 0x12);
+							return EMU_NOT_SUPPORTED;
+						}
+
+						entitlementId = b2i(4, tagData);
+
+						if (!DirectorGetKey(keyIndex, "MK", emmKey, 8))
+						{
+							return EMU_KEY_NOT_FOUND;
+						}
+
+						des_set_key(emmKey, ks);
+						des(tagData + 4 + 5, ks, 0);
+
+						if ((tagData + 4 + 5 + 7) != 0x00) // check if key looks valid (last byte 0x00)
+						{
+							cs_log_dbg(D_READER, "Key rejected from EMM (looks invalid)");
+							return EMU_KEY_REJECTED;
+						}
+
+						SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+						if (UpdateKey('T', entitlementId, "01", tagData + 4 + 5, 8, 1, NULL))
+						{
+							(*keysAdded)++;
+							cs_hexdump(0, tagData + 4 + 5, 8, keyValue, sizeof(keyValue));
+							cs_log("Key found in EMM: T %.8X 01 %s", entitlementId, keyValue);
+						}
+						SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+					}
+					break;
+
+					case 0x01: // ecm keys from mode 01
+					{
+						if (tagLength != 0x1A)
+						{
+							cs_log_dbg(D_READER, "WARNING: nanoTag E1 length (%d) != %d", tagLength, 0x1A);
+							return EMU_NOT_SUPPORTED;
+						}
+
+						entitlementId = b2i(4, tagData);
+
+						if (!DirectorGetKey(keyIndex, "MK01", emmKey, 8))
+						{
+							return EMU_KEY_NOT_FOUND;
+						}
+
+						uint8_t ecmKey[8] = { 0 };
+						DirectorDecryptEcmKey(emmKey, tagData, ecmKey);
+
+						if (ecmKey[7] != 0x00) // check if key looks valid (last byte 0x00)
+						{
+							cs_log_dbg(D_READER, "Key rejected from EMM (looks invalid)");
+							return EMU_KEY_REJECTED;
+						}
+
+						SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+						if (UpdateKey('T', entitlementId, "01", ecmKey, 8, 1, NULL))
+						{
+							(*keysAdded)++;
+							cs_hexdump(0, ecmKey, 8, keyValue, sizeof(keyValue));
+							cs_log("Key found in EMM: T %.8X 01 %s", entitlementId, keyValue);
+						}
+						SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+					}
+					break;
+
+					default:
+						cs_log_dbg(D_READER, "WARNING: nanoTag E1 mode %.2X not supported", tagMode);
+						return EMU_NOT_SUPPORTED;
+				}
+				break;
+			}
+
+			default:
+				cs_log_dbg(D_READER, "WARNING: nanoTag %.2X not supported", tagType);
+				return EMU_NOT_SUPPORTED;
+		}
+
+		pos += 2 + tagLength;
+	}
+
+	return EMU_OK;
+}
+
+static int8_t DirectorParseEmmNanoData(uint8_t* data, uint32_t* nanoLength, uint32_t maxLength, uint8_t keyIndex, uint32_t *keysAdded)
+{
+	uint32_t pos = 0;
+	uint16_t sectionLength;
+	int8_t ret = EMU_OK;
+
+	if (maxLength < 2)
+	{
+		(*nanoLength) = 0;
+		return EMU_NOT_SUPPORTED;
+	}
+
+	sectionLength = ((data[pos] << 8) | data[pos + 1]) & 0x0FFF;
+
+	if (pos + 2 + sectionLength > maxLength)
+	{
+		(*nanoLength) = pos;
+		return EMU_CORRUPT_DATA;
+	}
+
+	ret = DirectorParseEmmNanoTags(data + pos + 2, sectionLength, keyIndex, keysAdded);
+
+	pos += 2 + sectionLength;
+
+	(*nanoLength) = pos;
+	return ret;
+}
+
+int8_t DirectorEmm(uint8_t *emm, uint32_t *keysAdded)
+{
+	uint8_t keyIndex, ret = EMU_OK;
+	uint16_t emmLen = GetEcmLen(emm);
+	uint32_t pos = 3;
+	uint32_t permissionDataType;
+	uint32_t nanoLength = 0;
+
+	while (pos < emmLen && !ret)
+	{
+		permissionDataType = emm[pos];
+
+		switch (permissionDataType)
+		{
+			case 0x00:
+				break;
+
+			case 0x01:
+				pos += 0x0A;
+				break;
+
+			case 0x02:
+				pos += 0x26;
+				break;
+
+			default:
+				cs_log_dbg(D_READER, "ERROR: unknown permissionDataType %.2X (pos: %d)", permissionDataType, pos);
+				return EMU_NOT_SUPPORTED;
+		}
+
+		if (pos + 6 >= emmLen)
+		{
+			return EMU_CORRUPT_DATA;
+		}
+
+		keyIndex = emm[pos + 1];
+
+		// EMM validation
+		// Copy payload checksum bytes and then set them to zero,
+		// so they do not affect the calculated checksum.
+		uint16_t payloadChecksum = (emm[pos + 2] << 8) | emm[pos + 3];
+		memset(emm + pos + 2, 0, 2);
+		uint16_t calculatedChecksum = DirectorChecksum(emm + 3, emmLen - 3);
+
+		if (calculatedChecksum != payloadChecksum)
+		{
+			cs_log_dbg(D_READER, "EMM checksum error (%.4X instead of %.4X)", calculatedChecksum, payloadChecksum);
+			return EMU_CHECKSUM_ERROR;
+		}
+		// End of EMM validation
+
+		pos += 0x04;
+		ret = DirectorParseEmmNanoData(emm + pos, &nanoLength, emmLen - pos, keyIndex, keysAdded);
+		pos += nanoLength;
+	}
+
+	return ret;
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-director.h b/module-emulator-director.h
new file mode 100644
index 0000000..afffd3f
--- /dev/null
+++ b/module-emulator-director.h
@@ -0,0 +1,11 @@
+#ifndef MODULE_EMULATOR_DIRECTOR_H
+#define MODULE_EMULATOR_DIRECTOR_H
+
+#ifdef WITH_EMU
+
+int8_t DirectorEcm(uint8_t *ecm, uint8_t *dw);
+int8_t DirectorEmm(uint8_t *emm, uint32_t *keysAdded);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_DIRECTOR_H
diff --git a/module-emulator-drecrypt.c b/module-emulator-drecrypt.c
new file mode 100644
index 0000000..b53987d
--- /dev/null
+++ b/module-emulator-drecrypt.c
@@ -0,0 +1,535 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "cscrypt/des.h"
+#include "module-emulator-osemu.h"
+#include "oscam-string.h"
+#include "reader-dre-common.h"
+
+// Drecrypt EMU
+static void DREover(const uint8_t *ECMdata, uint8_t *dw)
+{
+	uint8_t key[8];
+	uint32_t key_schedule[32];
+
+	if (ECMdata[2] >= (43 + 4) && ECMdata[40] == 0x3A && ECMdata[41] == 0x4B)
+	{
+		if (!FindKey('D', ECMdata[42] & 0x0F, 0, "OVER", key, 8, 1, 0, 0, NULL))
+		{
+			return;
+		}
+
+		des_set_key(key, key_schedule);
+
+		des(dw, key_schedule, 0); // even dw post-process
+		des(dw + 8, key_schedule, 0); // odd dw post-process
+	}
+}
+
+static uint32_t DreGostDec(uint32_t inData)
+{
+	static uint8_t Sbox[128] =
+	{
+		0x0E,0x04,0x0D,0x01,0x02,0x0F,0x0B,0x08,0x03,0x0A,0x06,0x0C,0x05,0x09,0x00,0x07,
+		0x0F,0x01,0x08,0x0E,0x06,0x0B,0x03,0x04,0x09,0x07,0x02,0x0D,0x0C,0x00,0x05,0x0A,
+		0x0A,0x00,0x09,0x0E,0x06,0x03,0x0F,0x05,0x01,0x0D,0x0C,0x07,0x0B,0x04,0x02,0x08,
+		0x07,0x0D,0x0E,0x03,0x00,0x06,0x09,0x0A,0x01,0x02,0x08,0x05,0x0B,0x0C,0x04,0x0F,
+		0x02,0x0C,0x04,0x01,0x07,0x0A,0x0B,0x06,0x08,0x05,0x03,0x0F,0x0D,0x00,0x0E,0x09,
+		0x0C,0x01,0x0A,0x0F,0x09,0x02,0x06,0x08,0x00,0x0D,0x03,0x04,0x0E,0x07,0x05,0x0B,
+		0x04,0x0B,0x02,0x0E,0x0F,0x00,0x08,0x0D,0x03,0x0C,0x09,0x07,0x05,0x0A,0x06,0x01,
+		0x0D,0x02,0x08,0x04,0x06,0x0F,0x0B,0x01,0x0A,0x09,0x03,0x0E,0x05,0x00,0x0C,0x07
+	};
+	uint8_t i, j;
+
+	for(i = 0; i < 8; i++)
+	{
+		j = (inData >> 28) & 0x0F;
+		inData = (inData << 4) | (Sbox[i * 16 + j] & 0x0F);
+	}
+
+	inData = (inData << 11) | (inData >> 21);
+
+	return (inData);
+}
+
+static void DrecryptDecrypt(uint8_t *Data, uint8_t *Key) // DRE GOST 28147-89 CORE
+{
+	int i, j;
+	uint32_t L_part = 0, R_part = 0, temp = 0;
+
+	for(i = 0; i < 4; i++) L_part = (L_part << 8) | (Data[i] & 0xFF), R_part = (R_part << 8) | (Data[i + 4] & 0xFF);
+
+	for(i = 0; i < 4; i++)
+	{
+		temp = ((Key[i*8+0] & 0xFF) << 24) | ((Key[i*8+1] & 0xFF) << 16) | ((Key[i*8+2] & 0xFF) << 8) | (Key[i*8+3] & 0xFF);
+		R_part ^= DreGostDec(temp + L_part);
+		temp = ((Key[i*8+4] & 0xFF) << 24) | ((Key[i*8+5] & 0xFF) << 16) | ((Key[i*8+6] & 0xFF) << 8) | (Key[i*8+7] & 0xFF);
+		L_part ^= DreGostDec(temp + R_part);
+	}
+
+	for(j = 0; j < 3; j++)
+	{
+		for(i = 3; i >= 0; i--)
+		{
+			temp = ((Key[i*8+4] & 0xFF) << 24) | ((Key[i*8+5] & 0xFF) << 16) | ((Key[i*8+6] & 0xFF) << 8) | (Key[i*8+7] & 0xFF);
+			R_part ^= DreGostDec(temp + L_part);
+			temp = ((Key[i*8+0] & 0xFF) << 24) | ((Key[i*8+1] & 0xFF) << 16) | ((Key[i*8+2] & 0xFF) << 8) | (Key[i*8+3] & 0xFF);
+			L_part ^= DreGostDec(temp + R_part);
+		}
+	}
+
+	for(i = 0; i < 4; i++) Data[i] = (R_part >> i*8) & 0xFF, Data[i+4] = (L_part >> i*8) & 0xFF;
+}
+
+static void DrecryptPostCw(uint8_t* ccw)
+{
+	uint32_t i, j;
+	uint8_t tmp[4];
+
+	for(i = 0; i < 4; i++)
+	{
+		for(j = 0; j < 4; j++)
+		{
+			tmp[j] = ccw[3 - j];
+		}
+
+		for(j = 0; j < 4; j++)
+		{
+			ccw[j] = tmp[j];
+		}
+
+		ccw += 4;
+	}
+}
+
+static void DrecryptSwap(uint8_t* ccw)
+{
+	uint32_t tmp1, tmp2;
+
+	memcpy(&tmp1, ccw, 4);
+	memcpy(&tmp2, ccw + 4, 4);
+
+	memcpy(ccw, ccw + 8, 8);
+
+	memcpy(ccw + 8 , &tmp1, 4);
+	memcpy(ccw + 8 + 4, &tmp2, 4);
+}
+
+int8_t Drecrypt2ECM(uint32_t provId, uint8_t *ecm, uint8_t *dw)
+{
+	uint8_t ecmDataLen, ccw[16], key[32];
+	uint16_t ecmLen, overcryptId;
+	char keyName[EMU_MAX_CHAR_KEYNAME];
+
+	ecmLen = GetEcmLen(ecm);
+
+	if (ecmLen < 3)
+	{
+		return 1; // Not supported
+	}
+
+	ecmDataLen = ecm[2];
+
+	if (ecmLen < ecmDataLen + 3)
+	{
+		return 4; // Corrupt data
+	}
+
+	switch (provId & 0xFF)
+	{
+		case 0x11:
+		{
+			if (ecm[3] == 0x56)
+			{
+				snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%02X%02X", ecm[6], ecm[5]);
+
+				if (!FindKey('D', 0x4AE111, 0, keyName, key, 32, 1, 0, 0, NULL))
+				{
+					return 2;
+				}
+			}
+			else
+			{
+				snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%02X%02X", ecm[6], ecm[3]);
+
+				if (!FindKey('D', 0x4AE111, 0, keyName, key, 32, 1, 0, 0, NULL))
+				{
+					return 2;
+				}
+			}
+
+			break;
+		}
+
+		case 0x14:
+		{
+			snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%02X%02X", ecm[6], ecm[5]);
+
+			if (!FindKey('D', 0x4AE114, 0, keyName, key, 32, 1, 0, 0, NULL))
+			{
+				return 2;
+			}
+
+			break;
+		}
+
+		default:
+			return 1;
+	}
+
+	memcpy(ccw, ecm + 13, 16);
+
+	DrecryptPostCw(key);
+	DrecryptPostCw(key + 16);
+
+	DrecryptDecrypt(ccw, key);
+	DrecryptDecrypt(ccw + 8, key);
+
+	if (ecm[2] >= 46 && ecm[43] == 1 && provId == 0x11)
+	{
+		DrecryptSwap(ccw);
+		overcryptId = b2i(2, &ecm[44]);
+
+		Drecrypt2OverCW(overcryptId, ccw);
+
+		if (isValidDCW(ccw) && isValidDCW(ccw + 8))
+		{
+			memcpy(dw, ccw, 16);
+			return 0;
+		}
+
+		return 8; // ICG error
+	}
+
+	DREover(ecm, ccw);
+
+	if (isValidDCW(ccw) && isValidDCW(ccw + 8))
+	{
+		DrecryptSwap(ccw);
+		memcpy(dw, ccw, 16);
+		return 0;
+	}
+
+	return 1;
+}
+
+// Drecrypt EMM EMU
+static int8_t DrecryptGetEmmKey(uint8_t *buf, uint32_t keyIdent, uint16_t keyName, uint8_t isCriticalKey)
+{
+	char keyStr[EMU_MAX_CHAR_KEYNAME];
+	snprintf(keyStr, EMU_MAX_CHAR_KEYNAME, "MK%04X", keyName);
+	return FindKey('D', keyIdent, 0, keyStr, buf, 32, isCriticalKey, 0, 0, NULL);
+}
+
+static void DrecryptWriteEebin(const char *path, const char *name)
+{
+	char tmp[256];
+	FILE *file = NULL;
+	uint8_t i, buffer[64][32];
+	uint32_t prvid;
+
+	// Set path
+	if (path != NULL)
+	{
+		snprintf(tmp, 256, "%s%s", path, name);
+	}
+	else // No path set, use SoftCam.Keys's path
+	{
+		snprintf(tmp, 256, "%s%s", emu_keyfile_path, name);
+	}
+
+	if ((file = fopen(tmp, "wb")) != NULL)
+	{
+		cs_log("Writing key file: %s", tmp);
+	}
+	else
+	{
+		cs_log("Error writing key file: %s", tmp);
+		return;
+	}
+
+	// Load keys from db to buffer
+	prvid = (strncmp(name, "ee36.bin", 9) == 0) ? 0x4AE111 : 0x4AE114;
+
+	for (i = 0; i < 32; i++) // Load "3B" type keys
+	{
+		snprintf(tmp, 5, "3B%02X", i);
+		if (!FindKey('D', prvid, 0, tmp, buffer[i], 32, 0, 0, 0, NULL))
+		{
+			memset(buffer[i], 0xFF, 32);
+		}
+	}
+
+	for (i = 0; i < 32; i++) // Load "56" type keys
+	{
+		snprintf(tmp, 5, "56%02X", i);
+		if (!FindKey('D', prvid, 0, tmp, buffer[32 + i], 32, 0, 0, 0, NULL))
+		{
+			memset(buffer[32 + i], 0xFF, 32);
+		}
+	}
+
+	// Write buffer to ee.bin file
+	fwrite(buffer, 1, sizeof(buffer), file);
+	fclose(file);
+}
+
+static int8_t DrecryptProcessEMM(struct s_reader *rdr, uint32_t provId, uint8_t *emm, uint32_t *keysAdded)
+{
+	uint32_t i, keyIdent;
+	uint16_t keyName, emmLen, emmDataLen;
+	uint8_t emmKey[32], curECMkey3B[32], curECMkey56[32];
+	uint8_t keynum = 0, keyidx = 0, keyclass = 0, key1offset, key2offset;
+	char newKeyName[EMU_MAX_CHAR_KEYNAME], curKeyName[EMU_MAX_CHAR_KEYNAME], keyValue[100];
+
+	emmDataLen = GetEcmLen(emm);
+	emmLen = ((emm[1] & 0xF) << 8) | emm[2];
+
+	if (emmDataLen < emmLen + 3)
+	{
+		return 4; // Corrupt data
+	}
+
+	if (emm[0] == 0x91)
+	{
+		Drecrypt2OverEMM(emm);
+		return 0;
+	}
+	else if (emm[0] == 0x82)
+	{
+		ReasmEMM82(emm);
+		return 0;
+	}
+	else if (emm[0] != 0x86)
+	{
+		return 1; // Not supported
+	}
+
+	// Emm type 0x86 only
+	switch (emm[4])
+	{
+		case 0x02:
+			keynum = 0x2C;
+			keyidx = 0x30;
+			keyclass = 0x26;
+			key1offset = 0x35;
+			key2offset = 0x6D;
+			break;
+
+		case 0x4D:
+			keynum = 0x61;
+			keyidx = 0x60;
+			keyclass = 0x05;
+			key1offset = 0x62;
+			key2offset = 0x8B;
+			break;
+
+		default:
+			return 1; // Not supported
+	}
+
+	switch (provId & 0xFF)
+	{
+		case 0x11:
+		{
+			snprintf(curKeyName, EMU_MAX_CHAR_KEYNAME, "3B%02X", emm[keyclass]);
+			FindKey('D', 0x4AE111, 0, curKeyName, curECMkey3B, 32, 0, 0, 0, NULL);
+
+			snprintf(curKeyName, EMU_MAX_CHAR_KEYNAME, "56%02X", emm[keyclass]);
+			FindKey('D', 0x4AE111, 0, curKeyName, curECMkey56, 32, 0, 0, 0, NULL);
+
+			break;
+		}
+
+		case 0x14:
+		{
+			snprintf(curKeyName, EMU_MAX_CHAR_KEYNAME, "3B%02X", emm[keyclass]);
+			FindKey('D', 0x4AE114, 0, curKeyName, curECMkey3B, 32, 0, 0, 0, NULL);
+
+			snprintf(curKeyName, EMU_MAX_CHAR_KEYNAME, "56%02X", emm[keyclass]);
+			FindKey('D', 0x4AE114, 0, curKeyName, curECMkey56, 32, 0, 0, 0, NULL);
+
+			break;
+		}
+
+		default:
+			return 9; // Wrong provider
+	}
+
+	keyIdent = (0x4AE1 << 8) | provId;
+	keyName = (emm[3] << 8) | emm[keynum];
+
+	if (!DrecryptGetEmmKey(emmKey, keyIdent, keyName, 1))
+	{
+		return 2;
+	}
+
+	// Key #1
+	for (i = 0; i < 4; i++)
+	{
+		DrecryptDecrypt(&emm[key1offset + (i * 8)], emmKey);
+	}
+
+	// Key #2
+	for (i = 0; i < 4; i++)
+	{
+		DrecryptDecrypt(&emm[key2offset + (i * 8)], emmKey);
+	}
+
+	// Key #1
+	keyName = emm[keyidx] << 8 | emm[keyclass];
+	snprintf(newKeyName, EMU_MAX_CHAR_KEYNAME, "%.4X", keyName);
+
+	if (memcmp(&emm[key1offset], emm[keyidx] == 0x3b ? curECMkey3B : curECMkey56, 32) != 0)
+	{
+		memcpy(emm[keyidx] == 0x3b ? curECMkey3B : curECMkey56, &emm[key1offset], 32);
+		SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+		SetKey('D', keyIdent, newKeyName, &emm[key1offset], 32, 0, NULL, NULL);
+		SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+		(*keysAdded)++;
+
+		cs_hexdump(0, &emm[key1offset], 32, keyValue, sizeof(keyValue));
+		cs_log("Key found in EMM: D %.6X %s %s class %02X", keyIdent, newKeyName, keyValue, emm[keyclass]);
+	}
+	else
+	{
+		cs_log("Key %.6X %s already exists", keyIdent, newKeyName);
+	}
+
+	// Key #2
+	keyName = (emm[keyidx] == 0x56 ? 0x3B00 : 0x5600) | emm[keyclass];
+	snprintf(newKeyName, EMU_MAX_CHAR_KEYNAME, "%.4X", keyName);
+
+	if (memcmp(&emm[key2offset], emm[keyidx] == 0x3b ? curECMkey56 : curECMkey3B, 32) != 0)
+	{
+		memcpy(emm[keyidx] == 0x3b ? curECMkey56 : curECMkey3B, &emm[key2offset], 32);
+		SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+		SetKey('D', keyIdent, newKeyName, &emm[key2offset], 32, 0, NULL, NULL);
+		SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+		(*keysAdded)++;
+
+		cs_hexdump(0, &emm[key2offset], 32, keyValue, sizeof(keyValue));
+		cs_log("Key found in EMM: D %.6X %s %s class %02X", keyIdent, newKeyName, keyValue, emm[keyclass]);
+	}
+	else
+	{
+		cs_log("Key %.6X %s already exists", keyIdent, newKeyName);
+	}
+
+	if (*keysAdded > 0) // Write new ecm keys to ee.bin file
+	{
+		switch (provId & 0xFF)
+		{
+			case 0x11:
+				DrecryptWriteEebin(rdr->extee36, "ee36.bin");
+				break;
+
+			case 0x14:
+				DrecryptWriteEebin(rdr->extee56, "ee56.bin");
+				break;
+
+			default:
+				cs_log("Provider %02X doesn't have a matching ee.bin file", provId & 0xFF);
+				break;
+		}
+	}
+
+	return 0;
+}
+
+int8_t Drecrypt2EMM(struct s_reader *rdr, uint32_t provId, uint8_t *emm, uint32_t *keysAdded)
+{
+	int8_t result = DrecryptProcessEMM(rdr, provId, emm, keysAdded);
+
+	if (result == 2)
+	{
+		uint8_t keynum = 0, emmkey;
+		uint32_t i;
+		KeyDataContainer *KeyDB = GetKeyContainer('D');
+
+		if (KeyDB == NULL)
+		{
+			return result;
+		}
+
+		for (i = 0; i < KeyDB->keyCount; i++)
+		{
+			if (KeyDB->EmuKeys[i].provider != ((0x4AE1 << 8) | provId))
+			{
+				continue;
+			}
+
+			if (strlen(KeyDB->EmuKeys[i].keyName) < 6)
+			{
+				continue;
+			}
+
+			if (memcmp(KeyDB->EmuKeys[i].keyName, "MK", 2))
+			{
+				continue;
+			}
+
+			CharToBin(&keynum, KeyDB->EmuKeys[i].keyName + 4, 2);
+			emmkey = (emm[4] == 0x4D) ? emm[0x61] : emm[0x2C];
+
+			if (keynum == emmkey)
+			{
+				if (provId == 0x11)
+				{
+					CharToBin(&rdr->dre36_force_group, KeyDB->EmuKeys[i].keyName + 2, 2);
+				}
+				else
+				{
+					CharToBin(&rdr->dre56_force_group, KeyDB->EmuKeys[i].keyName + 2, 2);
+				}
+
+				break;
+			}
+		}
+	}
+
+	return result;
+}
+
+int8_t GetDrecryptHexserials(uint16_t caid, uint32_t provid, uint8_t *hexserials, int32_t length, int32_t *count)
+{
+	uint32_t i;
+	KeyDataContainer *KeyDB = GetKeyContainer('D');
+
+	if (KeyDB == NULL)
+	{
+		return 0;
+	}
+
+	(*count) = 0;
+
+	for (i = 0; i < KeyDB->keyCount && (*count) < length; i++)
+	{
+
+		if (KeyDB->EmuKeys[i].provider != ((caid << 8) | provid))
+		{
+			continue;
+		}
+
+		if (strlen(KeyDB->EmuKeys[i].keyName) < 6)
+		{
+			continue;
+		}
+
+		if (memcmp(KeyDB->EmuKeys[i].keyName, "MK", 2))
+		{
+			continue;
+		}
+
+		CharToBin(&hexserials[(*count)], KeyDB->EmuKeys[i].keyName + 2, 2);
+
+		(*count)++;
+	}
+
+	return 1;
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-drecrypt.h b/module-emulator-drecrypt.h
new file mode 100644
index 0000000..78e5b71
--- /dev/null
+++ b/module-emulator-drecrypt.h
@@ -0,0 +1,15 @@
+#ifndef MODULE_EMULATOR_DRECRYPT_H
+#define MODULE_EMULATOR_DRECRYPT_H
+
+#ifdef WITH_EMU
+
+int8_t Drecrypt2ECM(uint32_t provId, uint8_t *ecm, uint8_t *dw);
+int8_t Drecrypt2EMM(struct s_reader *rdr, uint32_t provId, uint8_t *emm, uint32_t *keysAdded);
+
+// hexserials must be of type "uint8_t hexserials[length]"
+// returns 0 on error, 1 on success
+int8_t GetDrecryptHexserials(uint16_t caid, uint32_t provid, uint8_t *hexserials, int32_t length, int32_t* count);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_DRECRYPT_H
diff --git a/module-emulator-irdeto.c b/module-emulator-irdeto.c
new file mode 100644
index 0000000..e5dddee
--- /dev/null
+++ b/module-emulator-irdeto.c
@@ -0,0 +1,597 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "cscrypt/des.h"
+#include "module-emulator-osemu.h"
+#include "oscam-string.h"
+
+static inline void xxor(uint8_t *data, int32_t len, const uint8_t *v1, const uint8_t *v2)
+{
+	uint32_t i;
+	switch(len)
+	{
+	case 16:
+		for(i = 0; i < 16; ++i)
+		{
+			data[i] = v1[i] ^ v2[i];
+		}
+		break;
+	case 8:
+		for(i = 0; i < 8; ++i)
+		{
+			data[i] = v1[i] ^ v2[i];
+		}
+		break;
+	case 4:
+		for(i = 0; i < 4; ++i)
+		{
+			data[i] = v1[i] ^ v2[i];
+		}
+		break;
+	default:
+		while(len--)
+		{
+			*data++ = *v1++ ^ *v2++;
+		}
+		break;
+	}
+}
+
+// Irdeto EMU
+static int8_t IrdetoGetKey(uint8_t *buf, uint32_t ident, char keyName, uint32_t keyIndex,
+							uint8_t isCriticalKey, uint32_t *keyRef)
+{
+	char keyStr[EMU_MAX_CHAR_KEYNAME];
+
+	if (*keyRef > 0xFF)
+	{
+		return 0;
+	}
+
+	snprintf(keyStr, EMU_MAX_CHAR_KEYNAME, "%c%X", keyName, keyIndex);
+
+	if (FindKey('I', ident, 0, keyStr, buf, 16, *keyRef > 0 ? 0 : isCriticalKey, *keyRef, 0, NULL))
+	{
+		(*keyRef)++;
+		return 1;
+	}
+
+	return 0;
+}
+
+static void Irdeto2Encrypt(uint8_t *data, const uint8_t *seed, const uint8_t *key, int32_t len)
+{
+	int32_t i;
+	const uint8_t *tmp = seed;
+	uint32_t ks1[32], ks2[32];
+
+	des_set_key(key, ks1);
+	des_set_key(key + 8, ks2);
+
+	len &= ~7;
+
+	for (i = 0; i + 7 < len; i += 8)
+	{
+		xxor(&data[i], 8, &data[i], tmp);
+		tmp = &data[i];
+		des(&data[i], ks1, 1);
+		des(&data[i], ks2, 0);
+		des(&data[i], ks1, 1);
+	}
+}
+
+static void Irdeto2Decrypt(uint8_t *data, const uint8_t *seed, const uint8_t *key, int32_t len)
+{
+	int32_t i, n = 0;
+	uint8_t buf[2][8];
+	uint32_t ks1[32], ks2[32];
+
+	des_set_key(key, ks1);
+	des_set_key(key + 8, ks2);
+
+	len &= ~7;
+
+	memcpy(buf[n], seed, 8);
+
+	for (i = 0; i + 7 < len; i += 8, data += 8, n ^= 1)
+	{
+		memcpy(buf[1 - n], data, 8);
+		des(data, ks1, 0);
+		des(data, ks2, 1);
+		des(data, ks1, 0);
+		xxor(data, 8, data, buf[n]);
+	}
+}
+
+static int8_t Irdeto2CalculateHash(const uint8_t *key, const uint8_t *iv, const uint8_t *data, int32_t len)
+{
+	int32_t l, y;
+	uint8_t cbuff[8];
+	uint32_t ks1[32], ks2[32];
+
+	des_set_key(key, ks1);
+	des_set_key(key + 8, ks2);
+
+	memset(cbuff, 0, sizeof(cbuff));
+
+	len -= 8;
+
+	for (y = 0; y < len; y += 8)
+	{
+		if (y < len - 8)
+		{
+			xxor(cbuff, 8, cbuff, &data[y]);
+		}
+		else
+		{
+			l = len - y;
+			xxor(cbuff, l, cbuff, &data[y]);
+			xxor(cbuff + l, 8 - l, cbuff + l, iv + 8);
+		}
+
+		des(cbuff, ks1, 1);
+		des(cbuff, ks2, 0);
+		des(cbuff, ks1, 1);
+	}
+
+	return memcmp(cbuff, &data[len], 8) == 0;
+}
+
+int8_t Irdeto2ECM(uint16_t caid, uint8_t *oecm, uint8_t *dw)
+{
+	uint8_t keyNr = 0, length, end, key[16], okeySeed[16], keySeed[16], keyIV[16], tmp[16];
+	uint8_t ecmCopy[EMU_MAX_ECM_LEN], *ecm = oecm;
+	uint16_t ecmLen = GetEcmLen(ecm);
+	uint32_t key0Ref, keySeedRef, keyIVRef, ident, i, j, l;
+
+	if (ecmLen < 12)
+	{
+		return 1;
+	}
+
+	length = ecm[11];
+	keyNr = ecm[9];
+	ident = ecm[8] | caid << 8;
+
+	if (ecmLen < length + 12)
+	{
+		return 1;
+	}
+
+	key0Ref = 0;
+
+	while (IrdetoGetKey(key, ident, '0', keyNr, 1, &key0Ref))
+	{
+		keySeedRef = 0;
+
+		while (IrdetoGetKey(okeySeed, ident, 'M', 1, 1, &keySeedRef))
+		{
+			keyIVRef = 0;
+
+			while (IrdetoGetKey(keyIV, ident, 'M', 2, 1, &keyIVRef))
+			{
+				memcpy(keySeed, okeySeed, 16);
+				memcpy(ecmCopy, oecm, ecmLen);
+
+				ecm = ecmCopy;
+				memset(tmp, 0, 16);
+				Irdeto2Encrypt(keySeed, tmp, key, 16);
+
+				ecm += 12;
+				Irdeto2Decrypt(ecm, keyIV, keySeed, length);
+
+				i = (ecm[0] & 7) + 1;
+				end = length - 8 < 0 ? 0 : length - 8;
+
+				while (i < end)
+				{
+					l = ecm[i + 1] ? (ecm[i + 1] & 0x3F) + 2 : 1;
+
+					switch (ecm[i])
+					{
+						case 0x10:
+						case 0x50:
+							if (l == 0x13 && i <= length - 8 - l)
+							{
+								Irdeto2Decrypt(&ecm[i + 3], keyIV, key, 16);
+							}
+							break;
+
+						case 0x78:
+							if (l == 0x14 && i <= length - 8 - l)
+							{
+								Irdeto2Decrypt(&ecm[i + 4], keyIV, key, 16);
+							}
+							break;
+					}
+					i += l;
+				}
+
+				i = (ecm[0] & 7) + 1;
+
+				if (Irdeto2CalculateHash(keySeed, keyIV, ecm - 6, length + 6))
+				{
+					while (i < end)
+					{
+						l = ecm[i + 1] ? (ecm[i + 1] & 0x3F) + 2 : 1;
+
+						switch (ecm[i])
+						{
+							case 0x78:
+							{
+								if (l == 0x14 && i <= length - 8 - l)
+								{
+									memcpy(dw, &ecm[i + 4], 16);
+
+									for (j = 0; j < 16; j += 4) // fix dw checksum bytes
+									{
+										dw[j + 3] = (dw[j] + dw[j + 1] + dw[j + 2]) & 0xFF;
+									}
+									return 0;
+								}
+							}
+						}
+						i += l;
+					}
+				}
+			}
+
+			if (keyIVRef == 0)
+			{
+				return 2;
+			}
+		}
+
+		if (keySeedRef == 0)
+		{
+			return 2;
+		}
+	}
+
+	if (key0Ref == 0)
+	{
+		return 2;
+	}
+
+	return 1;
+}
+
+// Irdeto2 EMM EMU
+static int8_t Irdeto2DoEMMTypeOP(uint32_t ident, uint8_t *emm, uint8_t *keySeed, uint8_t *keyIV,
+									uint8_t *keyPMK, uint16_t emmLen, uint8_t startOffset,
+									uint8_t length, uint32_t *keysAdded)
+{
+	uint8_t tmp[16];
+	uint32_t end, i, l;
+	char keyName[EMU_MAX_CHAR_KEYNAME], keyValue[36];
+
+	memset(tmp, 0, 16);
+	Irdeto2Encrypt(keySeed, tmp, keyPMK, 16);
+	Irdeto2Decrypt(&emm[startOffset], keyIV, keySeed, length);
+
+	i = 16;
+	end = startOffset + (length - 8 < 0 ? 0 : length - 8);
+
+	while (i < end)
+	{
+		l = emm[i + 1] ? (emm[i + 1] & 0x3F) + 2 : 1;
+
+		switch (emm[i])
+		{
+			case 0x10:
+			case 0x50:
+				if (l == 0x13 && i <= startOffset + length - 8 - l)
+				{
+					Irdeto2Decrypt(&emm[i + 3], keyIV, keyPMK, 16);
+				}
+				break;
+
+			case 0x78:
+				if (l == 0x14 && i <= startOffset + length - 8 - l)
+				{
+					Irdeto2Decrypt(&emm[i + 4], keyIV, keyPMK, 16);
+				}
+				break;
+		}
+		i += l;
+	}
+
+	memmove(emm + 6, emm + 7, emmLen - 7);
+
+	i = 15;
+	end = startOffset + (length - 9 < 0 ? 0 : length - 9);
+
+	if (Irdeto2CalculateHash(keySeed, keyIV, emm + 3, emmLen - 4))
+	{
+		while (i < end)
+		{
+			l = emm[i + 1] ? (emm[i + 1] & 0x3F) + 2 : 1;
+
+			switch (emm[i])
+			{
+				case 0x10:
+				case 0x50:
+				{
+					if (l == 0x13 && i <= startOffset + length - 9 - l)
+					{
+						snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%02X", emm[i + 2] >> 2);
+						SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+						SetKey('I', ident, keyName, &emm[i + 3], 16, 1, NULL, NULL);
+						SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+
+						(*keysAdded)++;
+						cs_hexdump(0, &emm[i + 3], 16, keyValue, sizeof(keyValue));
+						cs_log("Key found in EMM: I %06X %s %s", ident, keyName, keyValue);
+					}
+				}
+			}
+			i += l;
+		}
+
+		if (*keysAdded > 0)
+		{
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static int8_t Irdeto2DoEMMTypePMK(uint32_t ident, uint8_t *emm, uint8_t *keySeed, uint8_t *keyIV,
+									uint8_t *keyPMK, uint16_t emmLen, uint8_t startOffset,
+									uint8_t length, uint32_t *keysAdded)
+{
+	uint32_t end, i, j, l;
+	char keyName[EMU_MAX_CHAR_KEYNAME], keyValue[36];
+
+	Irdeto2Decrypt(&emm[startOffset], keyIV, keySeed, length);
+
+	i = 13;
+	end = startOffset + (length - 8 < 0 ? 0 : length - 8);
+
+	while (i < end)
+	{
+		l = emm[i + 1] ? (emm[i + 1] & 0x3F) + 2 : 1;
+
+		switch (emm[i])
+		{
+			case 0x10:
+			case 0x50:
+				if (l == 0x13 && i <= startOffset + length - 8 - l)
+				{
+					Irdeto2Decrypt(&emm[i + 3], keyIV, keyPMK, 16);
+				}
+				break;
+
+			case 0x78:
+				if (l == 0x14 && i <= startOffset + length - 8 - l)
+				{
+					Irdeto2Decrypt(&emm[i + 4], keyIV, keyPMK, 16);
+				}
+				break;
+
+			case 0x68:
+				if (l == 0x26 && i <= startOffset + length - 8 - l)
+				{
+					Irdeto2Decrypt(&emm[i + 3], keyIV, keyPMK, 16 * 2);
+				}
+				break;
+		}
+		i += l;
+	}
+
+	memmove(emm + 7, emm + 9, emmLen - 9);
+
+	i = 11;
+	end = startOffset + (length - 10 < 0 ? 0 : length - 10);
+
+	if (Irdeto2CalculateHash(keySeed, keyIV, emm + 3, emmLen - 5))
+	{
+		while (i < end)
+		{
+			l = emm[i + 1] ? (emm[i + 1] & 0x3F) + 2 : 1;
+
+			switch (emm[i])
+			{
+				case 0x68:
+				{
+					if (l == 0x26 && i <= startOffset + length - 10 - l)
+					{
+						for (j = 0; j < 2; j++)
+						{
+							snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "M%01X", 3 + j);
+							SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+							SetKey('I', ident, keyName, &emm[i + 3 + j * 16], 16, 1, NULL, NULL);
+							SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+
+							(*keysAdded)++;
+							cs_hexdump(0, &emm[i + 3 + j * 16], 16, keyValue, sizeof(keyValue));
+							cs_log("Key found in EMM: I %06X %s %s", ident, keyName, keyValue);
+						}
+					}
+				}
+			}
+			i += l;
+		}
+
+		if (*keysAdded > 0)
+		{
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static const uint8_t fausto_xor[16] = { 0x22, 0x58, 0xBD, 0x85, 0x2E, 0x8E, 0x52, 0x80,
+										0xA3, 0x79, 0x98, 0x69, 0x68, 0xE2, 0xD8, 0x4D };
+
+int8_t Irdeto2EMM(uint16_t caid, uint8_t *oemm, uint32_t *keysAdded)
+{
+	uint8_t length, okeySeed[16], keySeed[16], keyIV[16], keyPMK[16], startOffset, emmType;
+	uint8_t emmCopy[EMU_MAX_EMM_LEN], *emm = oemm;
+	uint16_t emmLen = GetEcmLen(emm);
+	uint32_t ident, keySeedRef, keyIVRef, keyPMK0Ref, keyPMK1Ref, keyPMK0ERef, keyPMK1ERef;
+
+	if (emmLen < 11)
+	{
+		return 1;
+	}
+
+	if (emm[3] == 0xC3 || emm[3] == 0xCB)
+	{
+		emmType = 2;
+		startOffset = 11;
+	}
+	else
+	{
+		emmType = 1;
+		startOffset = 10;
+	}
+
+	ident = emm[startOffset - 2] | caid << 8;
+	length = emm[startOffset - 1];
+
+	if (emmLen < length + startOffset)
+	{
+		return 1;
+	}
+
+	keySeedRef = 0;
+
+	while (IrdetoGetKey(okeySeed, ident, 'M', emmType == 1 ? 0 : 0xA, 1, &keySeedRef))
+	{
+		keyIVRef = 0;
+
+		while (IrdetoGetKey(keyIV, ident, 'M', 2, 1, &keyIVRef))
+		{
+			keyPMK0Ref = 0;
+			keyPMK1Ref = 0;
+			keyPMK0ERef = 0;
+			keyPMK1ERef = 0;
+
+			while (IrdetoGetKey(keyPMK, ident, 'M', emmType == 1 ? 3 : 0xB, 1, &keyPMK0Ref))
+			{
+				memcpy(keySeed, okeySeed, 16);
+				memcpy(emmCopy, oemm, emmLen);
+				emm = emmCopy;
+
+				if (emmType == 1)
+				{
+					if (Irdeto2DoEMMTypeOP(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0)
+					{
+						return 0;
+					}
+				}
+				else
+				{
+					if (Irdeto2DoEMMTypePMK(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0)
+					{
+						return 0;
+					}
+				}
+			}
+
+			if (emmType == 1)
+			{
+				while (IrdetoGetKey(keyPMK, ident, 'M', 4, 1, &keyPMK1Ref))
+				{
+					memcpy(keySeed, okeySeed, 16);
+					memcpy(emmCopy, oemm, emmLen);
+					emm = emmCopy;
+
+					if (Irdeto2DoEMMTypeOP(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0)
+					{
+						return 0;
+					}
+				}
+
+				while (IrdetoGetKey(keyPMK, ident, 'M', 5, 1, &keyPMK0ERef))
+				{
+					xxor(keyPMK, 16, keyPMK, fausto_xor);
+					memcpy(keySeed, okeySeed, 16);
+					memcpy(emmCopy, oemm, emmLen);
+					emm = emmCopy;
+
+					if (Irdeto2DoEMMTypeOP(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0)
+					{
+						return 0;
+					}
+				}
+
+				while (IrdetoGetKey(keyPMK, ident, 'M', 6, 1, &keyPMK1ERef))
+				{
+					xxor(keyPMK, 16, keyPMK, fausto_xor);
+					memcpy(keySeed, okeySeed, 16);
+					memcpy(emmCopy, oemm, emmLen);
+					emm = emmCopy;
+
+					if (Irdeto2DoEMMTypeOP(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0)
+					{
+						return 0;
+					}
+				}
+			}
+
+			if (keyPMK0Ref == 0 && keyPMK1Ref == 0 && keyPMK0ERef == 0 && keyPMK1ERef == 0)
+			{
+				return 2;
+			}
+		}
+
+		if (keyIVRef == 0)
+		{
+			return 2;
+		}
+	}
+
+	if (keySeedRef == 0)
+	{
+		return 2;
+	}
+
+	return 1;
+}
+
+int8_t GetIrdeto2Hexserial(uint16_t caid, uint8_t *hexserial)
+{
+	uint32_t i, len;
+	KeyDataContainer *KeyDB;
+	KeyData *tmpKeyData;
+
+	KeyDB = GetKeyContainer('I');
+
+	if (KeyDB == NULL)
+	{
+		return 0;
+	}
+
+	for (i = 0; i < KeyDB->keyCount; i++)
+	{
+		if (KeyDB->EmuKeys[i].provider >> 8 != caid)
+		{
+			continue;
+		}
+
+		if (strcmp(KeyDB->EmuKeys[i].keyName, "MC"))
+		{
+			continue;
+		}
+
+		tmpKeyData = &KeyDB->EmuKeys[i];
+		len = tmpKeyData->keyLength;
+
+		if (len > 3)
+			{ len = 3; }
+
+		memcpy(hexserial + (3 - len), tmpKeyData->key, len);
+		return 1;
+	}
+
+	return 0;
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-irdeto.h b/module-emulator-irdeto.h
new file mode 100644
index 0000000..2c97458
--- /dev/null
+++ b/module-emulator-irdeto.h
@@ -0,0 +1,15 @@
+#ifndef MODULE_EMULATOR_IRDETO_H
+#define MODULE_EMULATOR_IRDETO_H
+
+#ifdef WITH_EMU
+
+int8_t Irdeto2ECM(uint16_t caid, uint8_t *oecm, uint8_t *dw);
+int8_t Irdeto2EMM(uint16_t caid, uint8_t *oemm, uint32_t *keysAdded);
+
+// hexserial must be of type "uint8_t hexserial[3]"
+// returns 0 on error, 1 on success
+int8_t GetIrdeto2Hexserial(uint16_t caid, uint8_t* hexserial);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_IRDETO_H
diff --git a/module-emulator-nagravision.c b/module-emulator-nagravision.c
new file mode 100644
index 0000000..a80a544
--- /dev/null
+++ b/module-emulator-nagravision.c
@@ -0,0 +1,294 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "cscrypt/bn.h"
+#include "cscrypt/des.h"
+#include "cscrypt/idea.h"
+#include "module-emulator-osemu.h"
+
+static void ReverseMem(uint8_t *in, int32_t len)
+{
+	uint8_t temp;
+	int32_t i;
+	for(i = 0; i < (len / 2); i++) {
+		temp = in[i];
+		in[i] = in[len - i - 1];
+		in[len - i - 1] = temp;
+	}
+}
+
+static void ReverseMemInOut(uint8_t *out, const uint8_t *in, int32_t n)
+{
+	if(n>0) {
+		out+=n;
+		do {
+			*(--out)=*(in++);
+		}
+		while(--n);
+	}
+}
+
+static int8_t EmuRSAInput(BIGNUM *d, const uint8_t *in, int32_t n, int8_t le)
+{
+	int8_t result = 0;
+
+	if(le) {
+		uint8_t *tmp = (uint8_t *)malloc(sizeof(uint8_t)*n);
+		if(tmp == NULL) {
+			return 0;
+		}
+		ReverseMemInOut(tmp,in,n);
+		result = BN_bin2bn(tmp,n,d)!=0;
+		free(tmp);
+	}
+	else {
+		result = BN_bin2bn(in,n,d)!=0;
+	}
+	return result;
+}
+
+static int32_t EmuRSAOutput(uint8_t *out, int32_t n, BIGNUM *r, int8_t le)
+{
+	int32_t s = BN_num_bytes(r);
+	if(s>n) {
+		uint8_t *buff = (uint8_t *)malloc(sizeof(uint8_t)*s);
+		if(buff == NULL) {
+			return 0;
+		}
+		BN_bn2bin(r,buff);
+		memcpy(out,buff+s-n,n);
+		free(buff);
+	}
+	else if(s<n) {
+		int32_t l=n-s;
+		memset(out,0,l);
+		BN_bn2bin(r,out+l);
+	}
+	else {
+		BN_bn2bin(r,out);
+	}
+	if(le) {
+		ReverseMem(out,n);
+	}
+	return s;
+}
+
+static int32_t EmuRSA(uint8_t *out, const uint8_t *in, int32_t n, BIGNUM *exp, BIGNUM *mod, int8_t le)
+{
+	BN_CTX *ctx;
+	BIGNUM *r, *d;
+	int32_t result = 0;
+
+	ctx = BN_CTX_new();
+	r = BN_new();
+	d = BN_new();
+
+	if(EmuRSAInput(d,in,n,le) && BN_mod_exp(r,d,exp,mod,ctx)) {
+		result = EmuRSAOutput(out,n,r,le);
+	}
+
+	BN_free(d);
+	BN_free(r);
+	BN_CTX_free(ctx);
+	return result;
+}
+
+
+// Nagra EMU
+static int8_t GetNagraKey(uint8_t *buf, uint32_t ident, char keyName, uint32_t keyIndex, uint8_t isCriticalKey)
+{
+	char keyStr[EMU_MAX_CHAR_KEYNAME];
+	snprintf(keyStr, EMU_MAX_CHAR_KEYNAME, "%c%X", keyName, keyIndex);
+	if(FindKey('N', ident, 0, keyStr, buf, keyName == 'M' ? 64 : 16, isCriticalKey, 0, 0, NULL)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static int8_t Nagra2Signature(const uint8_t *vkey, const uint8_t *sig, const uint8_t *msg, int32_t len)
+{
+	uint8_t buff[16];
+	uint8_t iv[8];
+	int32_t i,j;
+
+	memcpy(buff,vkey,sizeof(buff));
+	for(i=0; i+7<len; i+=8) {
+		IDEA_KEY_SCHEDULE ek;
+		idea_set_encrypt_key(buff, &ek);
+		memcpy(buff,buff+8,8);
+		memset(iv,0,sizeof(iv));
+		idea_cbc_encrypt(msg+i,buff+8,8,&ek,iv,IDEA_ENCRYPT);
+		for(j=7; j>=0; j--) {
+			buff[j+8]^=msg[i+j];
+		}
+	}
+	buff[8]&=0x7F;
+	return (memcmp(sig, buff+8, 8) == 0);
+}
+
+static int8_t DecryptNagra2ECM(uint8_t *in, uint8_t *out, const uint8_t *key, int32_t len, const uint8_t *vkey, uint8_t *keyM)
+{
+	BIGNUM *exp, *mod;
+	uint8_t iv[8];
+	int32_t i = 0, sign = in[0] & 0x80;
+	uint8_t binExp = 3;
+	int8_t result = 1;
+
+	exp = BN_new();
+	mod = BN_new();
+	BN_bin2bn(&binExp, 1, exp);
+	BN_bin2bn(keyM, 64, mod);
+
+	if(EmuRSA(out,in+1,64,exp,mod,1)<=0) {
+		BN_free(exp);
+		BN_free(mod);
+		return 0;
+	}
+	out[63]|=sign;
+	if(len>64) {
+		memcpy(out+64,in+65,len-64);
+	}
+
+	memset(iv,0,sizeof(iv));
+	if(in[0]&0x04) {
+		uint8_t key1[8], key2[8];
+		ReverseMemInOut(key1,&key[0],8);
+		ReverseMemInOut(key2,&key[8],8);
+
+		for(i=7; i>=0; i--) {
+			ReverseMem(out+8*i,8);
+		}
+		des_ede2_cbc_decrypt(out, iv, key1, key2, len);
+		for(i=7; i>=0; i--) {
+			ReverseMem(out+8*i,8);
+		}
+	}
+	else {
+		IDEA_KEY_SCHEDULE ek;
+		idea_set_encrypt_key(key, &ek);
+		idea_cbc_encrypt(out, out, len&~7, &ek, iv, IDEA_DECRYPT);
+	}
+
+	ReverseMem(out,64);
+	if(result && EmuRSA(out,out,64,exp,mod,0)<=0) {
+		result = 0;
+	}
+	if(result && vkey && !Nagra2Signature(vkey,out,out+8,len-8)) {
+		result = 0;
+	}
+
+	BN_free(exp);
+	BN_free(mod);
+	return result;
+}
+
+int8_t Nagra2ECM(uint8_t *ecm, uint8_t *dw)
+{
+	uint32_t ident, identMask, tmp1, tmp2, tmp3;
+	uint8_t cmdLen, ideaKeyNr, *dec, ideaKey[16], vKey[16], m1Key[64], mecmAlgo = 0;
+	int8_t useVerifyKey = 0;
+	int32_t l=0, s;
+	uint16_t i = 0, ecmLen = GetEcmLen(ecm);
+
+	if(ecmLen < 8) {
+		return 1;
+	}
+	cmdLen = ecm[4] - 5;
+	ident = (ecm[5] << 8) + ecm[6];
+	ideaKeyNr = (ecm[7]&0x10)>>4;
+	if(ideaKeyNr) {
+		ideaKeyNr = 1;
+	}
+	if(ident == 1283 || ident == 1285 || ident == 1297) {
+		ident = 1281;
+	}
+	if(cmdLen <= 63 || ecmLen < cmdLen + 10) {
+		return 1;
+	}
+
+	if(!GetNagraKey(ideaKey, ident, '0', ideaKeyNr, 1)) {
+		return 2;
+	}
+	if(GetNagraKey(vKey, ident, 'V', 0, 0)) {
+		useVerifyKey = 1;
+	}
+	if(!GetNagraKey(m1Key, ident, 'M', 1, 1)) {
+		return 2;
+	}
+	ReverseMem(m1Key, 64);
+
+	dec = (uint8_t*)malloc(sizeof(uint8_t)*cmdLen);
+	if(dec == NULL) {
+		return 7;
+	}
+	if(!DecryptNagra2ECM(ecm+9, dec, ideaKey, cmdLen, useVerifyKey?vKey:0, m1Key)) {
+		free(dec);
+		return 1;
+	}
+
+	for(i=(dec[14]&0x10)?16:20; i<cmdLen && l!=3; ) {
+		switch(dec[i]) {
+		case 0x10:
+		case 0x11:
+			if(i+10 < cmdLen && dec[i+1] == 0x09) {
+				s = (~dec[i])&1;
+				mecmAlgo = dec[i+2]&0x60;
+				memcpy(dw+(s<<3), &dec[i+3], 8);
+				i+=11;
+				l|=(s+1);
+			}
+			else {
+				i++;
+			}
+			break;
+		case 0x00:
+			i+=2;
+			break;
+		case 0x30:
+		case 0x31:
+		case 0x32:
+		case 0x33:
+		case 0x34:
+		case 0x35:
+		case 0x36:
+		case 0xB0:
+			if(i+1 < cmdLen) {
+				i+=dec[i+1]+2;
+			}
+			else {
+				i++;
+			}
+			break;
+		default:
+			i++;
+			continue;
+		}
+	}
+
+	free(dec);
+
+	if(l!=3) {
+		return 1;
+	}
+	if(mecmAlgo>0) {
+		return 1;
+	}
+
+	identMask = ident & 0xFF00;
+	if (identMask == 0x1100 || identMask == 0x500 || identMask == 0x3100) {
+		memcpy(&tmp1, dw, 4);
+		memcpy(&tmp2, dw + 4, 4);
+		memcpy(&tmp3, dw + 12, 4);
+		memcpy(dw, dw + 8, 4);
+		memcpy(dw + 4, &tmp3, 4);
+		memcpy(dw + 8, &tmp1, 4);
+		memcpy(dw + 12, &tmp2, 4);
+	}
+	return 0;
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-nagravision.h b/module-emulator-nagravision.h
new file mode 100644
index 0000000..244aa54
--- /dev/null
+++ b/module-emulator-nagravision.h
@@ -0,0 +1,10 @@
+#ifndef MODULE_EMULATOR_NAGRAVISION_H
+#define MODULE_EMULATOR_NAGRAVISION_H
+
+#ifdef WITH_EMU
+
+int8_t Nagra2ECM(uint8_t *ecm, uint8_t *dw);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_NAGRAVISION_H
diff --git a/module-emulator-osemu.c b/module-emulator-osemu.c
new file mode 100644
index 0000000..ab1d3c7
--- /dev/null
+++ b/module-emulator-osemu.c
@@ -0,0 +1,1095 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "oscam-string.h"
+#include "cscrypt/bn.h"
+#include "module-emulator-osemu.h"
+#include "module-emulator-streamserver.h"
+#include "module-emulator-biss.h"
+#include "module-emulator-cryptoworks.h"
+#include "module-emulator-director.h"
+#include "module-emulator-drecrypt.h"
+#include "module-emulator-irdeto.h"
+#include "module-emulator-nagravision.h"
+#include "module-emulator-powervu.h"
+#include "module-emulator-viaccess.h"
+#include "module-emulator-videoguard.h"
+
+// Shared functions
+
+inline uint16_t GetEcmLen(const uint8_t *ecm)
+{
+	return (((ecm[1] & 0x0F) << 8) | ecm[2]) + 3;
+}
+
+int8_t isValidDCW(uint8_t *dw)
+{
+	uint8_t i;
+
+	for (i = 0; i < 8; i+= 4)
+	{
+		if (((dw[i] + dw[i + 1] + dw[i + 2]) & 0xFF) != dw[i + 3])
+		{
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+void Date2Str(char *dateStr, uint8_t len, int8_t offset, uint8_t format)
+{
+	// Creates a formatted date string for use in various functions.
+	// A positive or negative time offset (in hours) can be set as well
+	// as the format of the output string.
+
+	time_t rawtime;
+	struct tm timeinfo;
+
+	time(&rawtime);
+	rawtime += (time_t) offset * 60 * 60; // Add a positive or negative offset
+	localtime_r(&rawtime, &timeinfo);
+
+	switch (format)
+	{
+		case 1: // Used in WriteKeyToFile()
+			strftime(dateStr, len, "%c", &timeinfo);
+			break;
+
+		case 2: // Used in BissAnnotate()
+			strftime(dateStr, len, "%F @ %R", &timeinfo);
+			break;
+
+		case 3: // Used in SetKey(), BissAnnotate(), BissGetKey()
+			strftime(dateStr, len, "%y%m%d%H", &timeinfo);
+			break;
+	}
+}
+
+/*
+ * Key DB
+ *
+ * The Emu reader gets keys from the OSCcam-Emu binary and the "SoftCam.Key" file.
+ *
+ * The keys are stored in structures of type "KeyDataContainer", one per CAS. Each
+ * container points to a dynamically allocated array of type "KeyData", which holds
+ * the actual keys. The array initially holds up to 64 keys (64 * KeyData), and it
+ * is expanded by 16 every time it's filled with keys. The "KeyDataContainer" also
+ * includes info about the number of keys it contains ("KeyCount") and the maximum
+ * number of keys it can store ("KeyMax").
+ *
+ * The "KeyData" structure, on the other hand, stores the actual key information,
+ * including the "identifier", "provider", "keyName", "key" and "keyLength". There
+ * is also a "nextKey" pointer to a similar "KeyData" structure which is only used
+ * for Irdeto multiple keys, in a linked list style structure. For all other CAS,
+ * the "nextKey" is a "NULL" pointer.
+ *
+ * For storing keys, the "SetKey" function is used. Duplicate keys are not allowed.
+ * When storing a key that is already present in the database, its "key" value is
+ * updated with the new one. For reading keys from the database, the "FindKey"
+ * function is used. To delete all keys in a container, the "DeleteKeysInContainer"
+ * function can be called.
+*/
+
+char *emu_keyfile_path = NULL;
+
+void set_emu_keyfile_path(const char *path)
+{
+	if (emu_keyfile_path != NULL)
+	{
+		free(emu_keyfile_path);
+	}
+
+	emu_keyfile_path = (char *)malloc(strlen(path) + 1);
+	if (emu_keyfile_path == NULL)
+	{
+		return;
+	}
+	memcpy(emu_keyfile_path, path, strlen(path));
+	emu_keyfile_path[strlen(path)] = 0;
+}
+
+int8_t CharToBin(uint8_t *out, const char *in, uint32_t inLen)
+{
+	uint32_t i, tmp;
+
+	for (i = 0; i < inLen / 2; i++)
+	{
+		if (sscanf(in + i * 2, "%02X", &tmp) != 1)
+		{
+			return 0;
+		}
+		out[i] = (uint8_t)tmp;
+	}
+	return 1;
+}
+
+KeyDataContainer CwKeys = { NULL, 0, 0 };
+KeyDataContainer ViKeys = { NULL, 0, 0 };
+KeyDataContainer NagraKeys = { NULL, 0, 0 };
+KeyDataContainer IrdetoKeys = { NULL, 0, 0 };
+KeyDataContainer NDSKeys = { NULL, 0, 0 };
+KeyDataContainer BissKeys = { NULL, 0, 0 };
+KeyDataContainer PowervuKeys = { NULL, 0, 0 };
+KeyDataContainer DreKeys = { NULL, 0, 0 };
+KeyDataContainer TandbergKeys = { NULL, 0, 0 };
+
+KeyDataContainer *GetKeyContainer(char identifier)
+{
+	switch (identifier)
+	{
+		case 'W':
+			return &CwKeys;
+		case 'V':
+			return &ViKeys;
+		case 'N':
+			return &NagraKeys;
+		case 'I':
+			return &IrdetoKeys;
+		case 'S':
+			return &NDSKeys;
+		case 'F':
+			return &BissKeys;
+		case 'P':
+			return &PowervuKeys;
+		case 'D':
+			return &DreKeys;
+		case 'T':
+			return &TandbergKeys;
+		default:
+			return NULL;
+	}
+}
+
+static void WriteKeyToFile(char identifier, uint32_t provider, const char *keyName, uint8_t *key,
+							uint32_t keyLength, char *comment)
+{
+	char line[1200], dateText[100], filename[EMU_KEY_FILENAME_MAX_LEN + 1];
+	char *path, *filepath, *keyValue;
+	uint32_t pathLength;
+	uint8_t fileNameLen = strlen(EMU_KEY_FILENAME);
+	struct dirent *pDirent;
+	DIR *pDir;
+	FILE *file = NULL;
+
+	pathLength = strlen(emu_keyfile_path);
+	path = (char *)malloc(pathLength + 1);
+	if (path == NULL)
+	{
+		return;
+	}
+	strncpy(path, emu_keyfile_path, pathLength + 1);
+
+	pathLength = strlen(path);
+	if (pathLength >= fileNameLen && strcasecmp(path + pathLength - fileNameLen, EMU_KEY_FILENAME) == 0)
+	{
+		// cut file name
+		path[pathLength-fileNameLen] = '\0';
+	}
+
+	pathLength = strlen(path);
+	if (path[pathLength - 1] == '/' || path[pathLength - 1] == '\\')
+	{
+		// cut trailing /
+		path[pathLength - 1] = '\0';
+	}
+
+	pDir = opendir(path);
+	if (pDir == NULL)
+	{
+		cs_log("Cannot open key file path: %s", path);
+		free(path);
+		return;
+	}
+
+	while ((pDirent = readdir(pDir)) != NULL)
+	{
+		if (strcasecmp(pDirent->d_name, EMU_KEY_FILENAME) == 0)
+		{
+			strncpy(filename, pDirent->d_name, sizeof(filename));
+			break;
+		}
+	}
+	closedir(pDir);
+
+	if (pDirent == NULL)
+	{
+		strncpy(filename, EMU_KEY_FILENAME, sizeof(filename));
+	}
+
+	pathLength = strlen(path) + 1 + strlen(filename) + 1;
+	filepath = (char *)malloc(pathLength);
+	if (filepath == NULL)
+	{
+		free(path);
+		return;
+	}
+	snprintf(filepath, pathLength, "%s/%s", path, filename);
+	free(path);
+
+	cs_log("Writing key file: %s", filepath);
+
+	file = fopen(filepath, "a");
+	free(filepath);
+	if (file == NULL)
+	{
+		return;
+	}
+
+	Date2Str(dateText, sizeof(dateText), 0, 1);
+
+	keyValue = (char *)malloc((keyLength * 2) + 1);
+	if (keyValue == NULL)
+	{
+		fclose(file);
+		return;
+	}
+	cs_hexdump(0, key, keyLength, keyValue, (keyLength * 2) + 1);
+
+	if (comment)
+	{
+		snprintf(line, sizeof(line), "\n%c %.4X %s %s ; added by Emu %s %s",
+					identifier, provider, keyName, keyValue, dateText, comment);
+	}
+	else
+	{
+		snprintf(line, sizeof(line), "\n%c %.4X %s %s ; added by Emu %s",
+					identifier, provider, keyName, keyValue, dateText);
+	}
+
+	cs_log("Key written: %c %.4X %s %s", identifier, provider, keyName, keyValue);
+
+	free(keyValue);
+
+	fwrite(line, strlen(line), 1, file);
+	fclose(file);
+}
+
+int8_t SetKey(char identifier, uint32_t provider, char *keyName, uint8_t *orgKey, uint32_t keyLength,
+				uint8_t writeKey, char *comment, struct s_reader *rdr)
+{
+	uint32_t i, j;
+	uint8_t *tmpKey = NULL;
+	KeyDataContainer *KeyDB;
+	KeyData *tmpKeyData, *newKeyData;
+
+	identifier = (char)toupper((int)identifier);
+
+	KeyDB = GetKeyContainer(identifier);
+	if (KeyDB == NULL)
+	{
+		return 0;
+	}
+
+	keyName = strtoupper(keyName);
+
+	if (identifier == 'F') // Prepare BISS keys before saving to the db
+	{
+		// Convert legacy BISS "00" & "01" keynames
+		if (0 == strcmp(keyName, "00") || 0 == strcmp(keyName, "01"))
+		{
+			keyName = "00000000";
+		}
+
+		// All keyNames should have a length of 8 after converting
+		if (strlen(keyName) != 8)
+		{
+			cs_log("WARNING: Wrong key format in %s: F %08X %s", EMU_KEY_FILENAME, provider, keyName);
+			return 0;
+		}
+
+		// Verify date-coded keyName (if enabled), ignoring old (expired) keys
+		if (rdr->emu_datecodedenabled)
+		{
+			char timeStr[9];
+			Date2Str(timeStr, sizeof(timeStr), 0, 3);
+
+			// Reject old date-coded keys, but allow our "00000000" evergreen label
+			if (strcmp("00000000", keyName) != 0 && strcmp(timeStr, keyName) >= 0)
+			{
+				return 0;
+			}
+		}
+	}
+
+	// fix checksum for BISS keys with a length of 6
+	if (identifier == 'F' && keyLength == 6)
+	{
+		tmpKey = (uint8_t *)malloc(8 * sizeof(uint8_t));
+		if(tmpKey == NULL)
+		{
+			return 0;
+		}
+
+		tmpKey[0] = orgKey[0];
+		tmpKey[1] = orgKey[1];
+		tmpKey[2] = orgKey[2];
+		tmpKey[3] = ((orgKey[0] + orgKey[1] + orgKey[2]) & 0xff);
+		tmpKey[4] = orgKey[3];
+		tmpKey[5] = orgKey[4];
+		tmpKey[6] = orgKey[5];
+		tmpKey[7] = ((orgKey[3] + orgKey[4] + orgKey[5]) & 0xff);
+
+		keyLength = 8;
+	}
+	else // All keys with a length of 8, including BISS
+	{
+		tmpKey = (uint8_t *)malloc(keyLength * sizeof(uint8_t));
+		if (tmpKey == NULL)
+		{
+			return 0;
+		}
+
+		memcpy(tmpKey, orgKey, keyLength);
+	}
+
+	// fix patched mgcamd format for Irdeto
+	if (identifier == 'I' && provider < 0xFFFF)
+	{
+		provider = provider << 8;
+	}
+
+	// key already exists on db, update its value
+	for (i = 0; i < KeyDB->keyCount; i++)
+	{
+		if (KeyDB->EmuKeys[i].provider != provider)
+		{
+			continue;
+		}
+
+		// Don't match keyName (i.e. expiration date) for BISS
+		if (identifier != 'F' && strcmp(KeyDB->EmuKeys[i].keyName, keyName))
+		{
+			continue;
+		}
+
+		// allow multiple keys for Irdeto
+		if (identifier == 'I')
+		{
+			// reject duplicates
+			tmpKeyData = &KeyDB->EmuKeys[i];
+			do
+			{
+				if (memcmp(tmpKeyData->key, tmpKey, tmpKeyData->keyLength < keyLength ? tmpKeyData->keyLength : keyLength) == 0)
+				{
+					free(tmpKey);
+					return 0;
+				}
+				tmpKeyData = tmpKeyData->nextKey;
+			}
+			while(tmpKeyData != NULL);
+
+			// add new key
+			newKeyData = (KeyData *)malloc(sizeof(KeyData));
+			if (newKeyData == NULL)
+			{
+				free(tmpKey);
+				return 0;
+			}
+			newKeyData->identifier = identifier;
+			newKeyData->provider = provider;
+			if (strlen(keyName) < EMU_MAX_CHAR_KEYNAME)
+			{
+				strncpy(newKeyData->keyName, keyName, EMU_MAX_CHAR_KEYNAME);
+			}
+			else
+			{
+				memcpy(newKeyData->keyName, keyName, EMU_MAX_CHAR_KEYNAME);
+			}
+			newKeyData->keyName[EMU_MAX_CHAR_KEYNAME - 1] = 0;
+			newKeyData->key = tmpKey;
+			newKeyData->keyLength = keyLength;
+			newKeyData->nextKey = NULL;
+
+			tmpKeyData = &KeyDB->EmuKeys[i];
+			j = 0;
+			while (tmpKeyData->nextKey != NULL)
+			{
+				if (j == 0xFE)
+				{
+					break;
+				}
+				tmpKeyData = tmpKeyData->nextKey;
+				j++;
+			}
+			if (tmpKeyData->nextKey)
+			{
+				NULLFREE(tmpKeyData->nextKey->key);
+				NULLFREE(tmpKeyData->nextKey);
+			}
+			tmpKeyData->nextKey = newKeyData;
+
+			if (writeKey)
+			{
+				WriteKeyToFile(identifier, provider, keyName, tmpKey, keyLength, comment);
+			}
+		}
+		else // identifier != 'I'
+		{
+			free(KeyDB->EmuKeys[i].key);
+			KeyDB->EmuKeys[i].key = tmpKey;
+			KeyDB->EmuKeys[i].keyLength = keyLength;
+
+			if (identifier == 'F') // Update keyName (i.e. expiration date) for BISS
+			{
+				strncpy(KeyDB->EmuKeys[i].keyName, keyName, EMU_MAX_CHAR_KEYNAME);
+			}
+
+			if (writeKey)
+			{
+				WriteKeyToFile(identifier, provider, keyName, tmpKey, keyLength, comment);
+			}
+		}
+		return 1;
+	}
+
+	// key does not exist on db
+	if (KeyDB->keyCount + 1 > KeyDB->keyMax)
+	{
+		if (KeyDB->EmuKeys == NULL) // db is empty
+		{
+			KeyDB->EmuKeys = (KeyData *)malloc(sizeof(KeyData) * (KeyDB->keyMax + 64));
+			if (KeyDB->EmuKeys == NULL)
+			{
+				free(tmpKey);
+				return 0;
+			}
+			KeyDB->keyMax += 64;
+		}
+		else // db is full, expand it
+		{
+			tmpKeyData = (KeyData *)realloc(KeyDB->EmuKeys, sizeof(KeyData) * (KeyDB->keyMax + 16));
+			if (tmpKeyData == NULL)
+			{
+				free(tmpKey);
+				return 0;
+			}
+			KeyDB->EmuKeys = tmpKeyData;
+			KeyDB->keyMax += 16;
+		}
+	}
+
+	KeyDB->EmuKeys[KeyDB->keyCount].identifier = identifier;
+	KeyDB->EmuKeys[KeyDB->keyCount].provider = provider;
+	if (strlen(keyName) < EMU_MAX_CHAR_KEYNAME)
+	{
+		strncpy(KeyDB->EmuKeys[KeyDB->keyCount].keyName, keyName, EMU_MAX_CHAR_KEYNAME);
+	}
+	else
+	{
+		memcpy(KeyDB->EmuKeys[KeyDB->keyCount].keyName, keyName, EMU_MAX_CHAR_KEYNAME);
+	}
+	KeyDB->EmuKeys[KeyDB->keyCount].keyName[EMU_MAX_CHAR_KEYNAME - 1] = 0;
+	KeyDB->EmuKeys[KeyDB->keyCount].key = tmpKey;
+	KeyDB->EmuKeys[KeyDB->keyCount].keyLength = keyLength;
+	KeyDB->EmuKeys[KeyDB->keyCount].nextKey = NULL;
+	KeyDB->keyCount++;
+
+	if (writeKey)
+	{
+		WriteKeyToFile(identifier, provider, keyName, tmpKey, keyLength, comment);
+	}
+	return 1;
+}
+
+int8_t FindKey(char identifier, uint32_t provider, uint32_t providerIgnoreMask, char *keyName,
+				uint8_t *key, uint32_t maxKeyLength, uint8_t isCriticalKey, uint32_t keyRef,
+				uint8_t matchLength, uint32_t *getProvider)
+{
+	uint32_t i;
+	uint16_t j;
+	uint8_t provider_matching_key_count = 0;
+	KeyDataContainer *KeyDB;
+	KeyData *tmpKeyData;
+
+	KeyDB = GetKeyContainer(identifier);
+	if (KeyDB == NULL)
+	{
+		return 0;
+	}
+
+	for (i = 0; i < KeyDB->keyCount; i++)
+	{
+
+		if ((KeyDB->EmuKeys[i].provider & ~providerIgnoreMask) != provider)
+		{
+			continue;
+		}
+
+		// Don't match keyName (i.e. expiration date) for BISS
+		if (identifier != 'F' && strcmp(KeyDB->EmuKeys[i].keyName, keyName))
+		{
+			continue;
+		}
+
+		//matchLength cannot be used when multiple keys are allowed
+		//for a single provider/keyName combination.
+		//Currently this is only the case for Irdeto keys.
+		if (matchLength && KeyDB->EmuKeys[i].keyLength != maxKeyLength)
+		{
+			continue;
+		}
+
+		if (providerIgnoreMask)
+		{
+			if (provider_matching_key_count < keyRef)
+			{
+				provider_matching_key_count++;
+				continue;
+			}
+			else
+			{
+				keyRef = 0;
+			}
+		}
+
+		tmpKeyData = &KeyDB->EmuKeys[i];
+
+		j = 0;
+		while (j < keyRef && tmpKeyData->nextKey != NULL)
+		{
+			j++;
+			tmpKeyData = tmpKeyData->nextKey;
+		}
+
+		if (j == keyRef)
+		{
+			memcpy(key, tmpKeyData->key, tmpKeyData->keyLength > maxKeyLength ? maxKeyLength : tmpKeyData->keyLength);
+			if (tmpKeyData->keyLength < maxKeyLength)
+			{
+				memset(key+tmpKeyData->keyLength, 0, maxKeyLength - tmpKeyData->keyLength);
+			}
+
+			if (identifier == 'F') // Report the keyName of found key back to BissGetKey()
+			{
+				strncpy(keyName, tmpKeyData->keyName, EMU_MAX_CHAR_KEYNAME);
+			}
+
+			if (getProvider != NULL)
+			{
+				(*getProvider) = tmpKeyData->provider;
+			}
+			return 1;
+		}
+		else
+		{
+			break;
+		}
+	}
+
+	if (isCriticalKey)
+	{
+		cs_log("Key not found: %c %X %s", identifier, provider, keyName);
+	}
+
+	return 0;
+}
+
+int8_t UpdateKey(char identifier, uint32_t provider, char *keyName, uint8_t *key, uint32_t keyLength,
+					uint8_t writeKey, char *comment)
+{
+	uint32_t keyRef = 0;
+	uint8_t *tmpKey = (uint8_t *)malloc(sizeof(uint8_t) * keyLength);
+
+	if (tmpKey == NULL)
+	{
+		return 0;
+	}
+
+	while (FindKey(identifier, provider, 0, keyName, tmpKey, keyLength, 0, keyRef, 0, NULL))
+	{
+		if (memcmp(tmpKey, key, keyLength) == 0)
+		{
+			free(tmpKey);
+			return 0;
+		}
+
+		keyRef++;
+	}
+
+	free(tmpKey);
+	return SetKey(identifier, provider, keyName, key, keyLength, writeKey, comment, NULL);
+}
+
+int32_t DeleteKeysInContainer(char identifier)
+{
+	// Deletes all keys stored in memory for the specified identifier,
+	// but keeps the container itself, re-initialized at { NULL, 0, 0 }.
+	// Returns the count of deleted keys.
+
+	uint32_t oldKeyCount, i;
+	KeyData *tmpKeyData;
+	KeyDataContainer *KeyDB = GetKeyContainer(identifier);
+
+	if (KeyDB == NULL || KeyDB->EmuKeys == NULL || KeyDB->keyCount == 0)
+	{
+		return 0;
+	}
+
+	for (i = 0; i < KeyDB->keyCount; i++)
+	{
+		// For Irdeto multiple keys only (linked list structure)
+		while (KeyDB->EmuKeys[i].nextKey != NULL)
+		{
+			tmpKeyData = KeyDB->EmuKeys[i].nextKey;
+			KeyDB->EmuKeys[i].nextKey = KeyDB->EmuKeys[i].nextKey->nextKey;
+			free(tmpKeyData->key); // Free key
+			free(tmpKeyData); // Free KeyData
+		}
+
+		// For single keys (all identifiers, including Irdeto)
+		free(KeyDB->EmuKeys[i].key); // Free key
+	}
+
+	// Free the KeyData array
+	NULLFREE(KeyDB->EmuKeys);
+	oldKeyCount = KeyDB->keyCount;
+	KeyDB->keyCount = 0;
+	KeyDB->keyMax = 0;
+
+	return oldKeyCount;
+}
+
+void clear_emu_keydata(void)
+{
+	uint32_t total = 0;
+
+	total  = CwKeys.keyCount;
+	total += ViKeys.keyCount;
+	total += NagraKeys.keyCount;
+	total += IrdetoKeys.keyCount;
+	total += NDSKeys.keyCount;
+	total += BissKeys.keyCount;
+	total += PowervuKeys.keyCount;
+	total += DreKeys.keyCount;
+	total += TandbergKeys.keyCount;
+
+	if (total != 0)
+	{
+		cs_log("Freeing keys in memory: W:%d V:%d N:%d I:%d S:%d F:%d P:%d D:%d T:%d", \
+						CwKeys.keyCount, ViKeys.keyCount, NagraKeys.keyCount, \
+						IrdetoKeys.keyCount, NDSKeys.keyCount, BissKeys.keyCount, \
+						PowervuKeys.keyCount, DreKeys.keyCount, TandbergKeys.keyCount);
+
+		DeleteKeysInContainer('W');
+		DeleteKeysInContainer('V');
+		DeleteKeysInContainer('N');
+		DeleteKeysInContainer('I');
+		DeleteKeysInContainer('S');
+		DeleteKeysInContainer('F');
+		DeleteKeysInContainer('P');
+		DeleteKeysInContainer('D');
+		DeleteKeysInContainer('T');
+	}
+}
+
+uint8_t read_emu_keyfile(struct s_reader *rdr, const char *opath)
+{
+	char line[1200], keyName[EMU_MAX_CHAR_KEYNAME], keyString[1026], identifier;
+	char *path, *filepath, filename[EMU_KEY_FILENAME_MAX_LEN + 1];
+	uint32_t pathLength, provider, keyLength;
+	uint8_t fileNameLen = strlen(EMU_KEY_FILENAME);
+	uint8_t *key;
+	struct dirent *pDirent;
+	DIR *pDir;
+	FILE *file = NULL;
+
+	pathLength = strlen(opath);
+	path = (char *)malloc(pathLength + 1);
+	if (path == NULL)
+	{
+		return 0;
+	}
+	strncpy(path, opath, pathLength + 1);
+
+	pathLength = strlen(path);
+	if (pathLength >= fileNameLen && strcasecmp(path + pathLength - fileNameLen, EMU_KEY_FILENAME) == 0)
+	{
+		// cut file name
+		path[pathLength-fileNameLen] = '\0';
+	}
+
+	pathLength = strlen(path);
+	if (path[pathLength - 1] == '/' || path[pathLength - 1] == '\\')
+	{
+		// cut trailing /
+		path[pathLength - 1] = '\0';
+	}
+
+	pDir = opendir(path);
+	if (pDir == NULL)
+	{
+		cs_log("Cannot open key file path: %s", path);
+		free(path);
+		return 0;
+	}
+
+	while ((pDirent = readdir(pDir)) != NULL)
+	{
+		if (strcasecmp(pDirent->d_name, EMU_KEY_FILENAME) == 0)
+		{
+			strncpy(filename, pDirent->d_name, sizeof(filename));
+			break;
+		}
+	}
+	closedir(pDir);
+
+	if (pDirent == NULL)
+	{
+		cs_log("Key file not found in: %s", path);
+		free(path);
+		return 0;
+	}
+
+	pathLength = strlen(path) + 1 + strlen(filename) + 1;
+	filepath = (char *)malloc(pathLength);
+	if (filepath == NULL)
+	{
+		free(path);
+		return 0;
+	}
+	snprintf(filepath, pathLength, "%s/%s", path, filename);
+	free(path);
+
+	cs_log("Reading key file: %s", filepath);
+
+	file = fopen(filepath, "r");
+	free(filepath);
+	if (file == NULL)
+	{
+		return 0;
+	}
+
+	set_emu_keyfile_path(opath);
+
+	while (fgets(line, 1200, file))
+	{
+		if (sscanf(line, "%c %8x %11s %1024s", &identifier, &provider, keyName, keyString) != 4)
+		{
+			continue;
+		}
+
+		keyLength = strlen(keyString) / 2;
+		key = (uint8_t *)malloc(keyLength);
+		if (key == NULL)
+		{
+			fclose(file);
+			return 0;
+		}
+
+		if (CharToBin(key, keyString, strlen(keyString))) // Conversion OK
+		{
+			SetKey(identifier, provider, keyName, key, keyLength, 0, NULL, rdr);
+		}
+		else // Non-hex characters in keyString
+		{
+			if ((identifier != ';' && identifier != '#' && // Skip warning for comments, etc.
+				 identifier != '=' && identifier != '-' &&
+				 identifier != ' ') &&
+				!(identifier == 'F' && 0 == strncmp(keyString, "XXXXXXXXXXXX", 12))) // Skip warning for BISS 'Example key' lines
+			{
+				// Alert user regarding faulty line
+				cs_log("WARNING: non-hex value in %s at %c %04X %s %s",
+						EMU_KEY_FILENAME, identifier, provider, keyName, keyString);
+			}
+		}
+		free(key);
+	}
+	fclose(file);
+
+	return 1;
+}
+
+#if !defined(__APPLE__) && !defined(__ANDROID__)
+extern uint8_t SoftCamKey_Data[]    __asm__("_binary_SoftCam_Key_start");
+extern uint8_t SoftCamKey_DataEnd[] __asm__("_binary_SoftCam_Key_end");
+
+void read_emu_keymemory(struct s_reader *rdr)
+{
+	char *keyData, *line, *saveptr, keyName[EMU_MAX_CHAR_KEYNAME], keyString[1026], identifier;
+	uint32_t provider, keyLength;
+	uint8_t *key;
+
+	keyData = (char *)malloc(SoftCamKey_DataEnd - SoftCamKey_Data + 1);
+	if (keyData == NULL)
+	{
+		return;
+	}
+	memcpy(keyData, SoftCamKey_Data, SoftCamKey_DataEnd - SoftCamKey_Data);
+	keyData[SoftCamKey_DataEnd-SoftCamKey_Data] = 0x00;
+
+	line = strtok_r(keyData, "\n", &saveptr);
+	while (line != NULL)
+	{
+		if (sscanf(line, "%c %8x %11s %1024s", &identifier, &provider, keyName, keyString) != 4)
+		{
+			line = strtok_r(NULL, "\n", &saveptr);
+			continue;
+		}
+		keyLength = strlen(keyString) / 2;
+		key = (uint8_t *)malloc(keyLength);
+		if (key == NULL)
+		{
+			free(keyData);
+			return;
+		}
+
+		if (CharToBin(key, keyString, strlen(keyString))) // Conversion OK
+		{
+			SetKey(identifier, provider, keyName, key, keyLength, 0, NULL, rdr);
+		}
+		else // Non-hex characters in keyString
+		{
+			if ((identifier != ';' && identifier != '#' && // Skip warning for comments, etc.
+				 identifier != '=' && identifier != '-' &&
+				 identifier != ' ') &&
+				!(identifier == 'F' && 0 == strncmp(keyString, "XXXXXXXXXXXX", 12))) // Skip warning for BISS 'Example key' lines
+			{
+				// Alert user regarding faulty line
+				cs_log("WARNING: non-hex value in internal keyfile at %c %04X %s %s",
+						identifier, provider, keyName, keyString);
+			}
+		}
+		free(key);
+		line = strtok_r(NULL, "\n", &saveptr);
+	}
+	free(keyData);
+}
+#endif
+
+void read_emu_eebin(const char *path, const char *name)
+{
+	char tmp[256];
+	FILE *file = NULL;
+	uint8_t i, buffer[64][32], dummy[2][32];
+	uint32_t prvid;
+
+	// Set path
+	if (path != NULL)
+	{
+		snprintf(tmp, 256, "%s%s", path, name);
+	}
+	else // No path set, use SoftCam.Keys's path
+	{
+		snprintf(tmp, 256, "%s%s", emu_keyfile_path, name);
+	}
+
+	// Read file to buffer
+	if ((file = fopen(tmp, "rb")) != NULL)
+	{
+		cs_log("Reading key file: %s", tmp);
+
+		if (fread(buffer, 1, sizeof(buffer), file) != sizeof(buffer))
+		{
+			cs_log("Corrupt key file: %s", tmp);
+			fclose(file);
+			return;
+		}
+
+		fclose(file);
+	}
+	else
+	{
+		if (path != NULL)
+		{
+			cs_log("Cannot open key file: %s", tmp);
+		}
+
+		return;
+	}
+
+	// Save keys to db
+	memset(dummy[0], 0x00, 32);
+	memset(dummy[1], 0xFF, 32);
+	prvid = (strncmp(name, "ee36.bin", 9) == 0) ? 0x4AE111 : 0x4AE114;
+
+	for (i = 0; i < 32; i++) // Set "3B" type keys
+	{
+		// Write keys if they have "real" values
+		if ((memcmp(buffer[i], dummy[0], 32) !=0) && (memcmp(buffer[i], dummy[1], 32) != 0))
+		{
+			snprintf(tmp, 5, "3B%02X", i);
+			SetKey('D', prvid, tmp, buffer[i], 32, 0, NULL, NULL);
+		}
+	}
+
+	for (i = 0; i < 32; i++) // Set "56" type keys
+	{
+		// Write keys if they have "real" values
+		if ((memcmp(buffer[32 + i], dummy[0], 32) !=0) && (memcmp(buffer[32 + i], dummy[1], 32) != 0))
+		{
+			snprintf(tmp, 5, "56%02X", i);
+			SetKey('D', prvid, tmp, buffer[32 + i], 32, 0, NULL, NULL);
+		}
+	}
+}
+
+void read_emu_deskey(uint8_t *dreOverKey, uint8_t len)
+{
+	uint8_t i;
+
+	if (len == 128)
+	{
+		cs_log("Reading DreCrypt overcrypt (ADEC) key");
+
+		for (i = 0; i < 16; i++)
+		{
+			SetKey('D', i, "OVER", dreOverKey + (i * 8), 8, 0, NULL, NULL);
+		}
+	}
+	else if ((len != 0 && len < 128) || len > 128)
+	{
+		cs_log("DreCrypt overcrypt (ADEC) key has wrong length");
+	}
+}
+
+static const char *GetProcessECMErrorReason(int8_t result)
+{
+	switch (result)
+	{
+		case 0:
+			return "No error";
+		case 1:
+			return "ECM not supported";
+		case 2:
+			return "Key not found";
+		case 3:
+			return "Nano80 problem";
+		case 4:
+			return "Corrupt data";
+		case 5:
+			return "CW not found";
+		case 6:
+			return "CW checksum error";
+		case 7:
+			return "Out of memory";
+		case 8:
+			return "ECM checksum error";
+		case 9:
+			return "ICG error";
+		default:
+			return "Unknown";
+	}
+}
+
+/* Error codes
+0  OK
+1  ECM not supported
+2  Key not found
+3  Nano80 problem
+4  Corrupt data
+5  CW not found
+6  CW checksum error
+7  Out of memory
+8  ECM checksum error
+9  ICG error
+*/
+
+int8_t ProcessECM(struct s_reader *rdr, int16_t ecmDataLen, uint16_t caid, uint32_t provider,
+				const uint8_t *ecm, uint8_t *dw, uint16_t srvid, uint16_t ecmpid, EXTENDED_CW* cw_ex)
+{
+	if (ecmDataLen < 3)
+	{
+		cs_log_dbg(D_TRACE, "Received ecm data of zero length!");
+		return 4;
+	}
+
+	uint16_t ecmLen = GetEcmLen(ecm);
+	uint8_t ecmCopy[ecmLen];
+	int8_t result = 1;
+
+	if (ecmLen != ecmDataLen)
+	{
+		cs_log_dbg(D_TRACE, "Actual ecm data length 0x%03X but ecm section length is 0x%03X",
+							ecmDataLen, ecmLen);
+		return 4;
+	}
+
+	if (ecmLen > EMU_MAX_ECM_LEN)
+	{
+		cs_log_dbg(D_TRACE, "Actual ecm data length 0x%03X but maximum supported ecm length is 0x%03X",
+							ecmDataLen, EMU_MAX_ECM_LEN);
+		return 1;
+	}
+
+	memcpy(ecmCopy, ecm, ecmLen);
+
+	     if (caid_is_viaccess(caid))    result = ViaccessECM(ecmCopy, dw);
+	else if (caid_is_irdeto(caid))      result = Irdeto2ECM(caid, ecmCopy, dw);
+	else if (caid_is_videoguard(caid))  result = SoftNDSECM(caid, ecmCopy, dw);
+	else if (caid_is_cryptoworks(caid)) result = CryptoworksECM(caid, ecmCopy, dw);
+	else if (caid_is_powervu(caid))     result = PowervuECM(ecmCopy, dw, srvid, NULL, cw_ex);
+	else if (caid_is_director(caid))    result = DirectorEcm(ecmCopy, dw);
+	else if (caid_is_nagra(caid))       result = Nagra2ECM(ecmCopy, dw);
+	else if (caid_is_biss(caid))        result = BissEcm(rdr, caid, ecm, dw, srvid, ecmpid);
+	else if (caid_is_dre(caid))         result = Drecrypt2ECM(provider, ecmCopy, dw);
+	else if (caid == 0xA101)            result = 0; // RossCrypt1 does not send ECM's
+
+	if (result != 0)
+	{
+		cs_log("ECM failed: %s", GetProcessECMErrorReason(result));
+	}
+
+	return result;
+}
+
+static const char *GetProcessEMMErrorReason(int8_t result)
+{
+	switch (result)
+	{
+		case 0:
+			return "No error";
+		case 1:
+			return "EMM not supported";
+		case 2:
+			return "Key not found";
+		case 3:
+			return "Nano80 problem";
+		case 4:
+			return "Corrupt data";
+		case 5:
+			return "Unknown";
+		case 6:
+			return "Checksum error";
+		case 7:
+			return "Out of memory";
+		case 8:
+			return "EMM checksum error";
+		case 9:
+			return "Wrong provider";
+		default:
+			return "Unknown";
+	}
+}
+
+int8_t ProcessEMM(struct s_reader *rdr, uint16_t caid, uint32_t provider, const uint8_t *emm, uint32_t *keysAdded)
+{
+	uint16_t emmLen = GetEcmLen(emm);
+	uint8_t emmCopy[emmLen];
+	int8_t result = 1;
+
+	if (emmLen > EMU_MAX_EMM_LEN)
+	{
+		return 1;
+	}
+	memcpy(emmCopy, emm, emmLen);
+	*keysAdded = 0;
+
+	     if (caid_is_viaccess(caid)) result = ViaccessEMM(emmCopy, keysAdded);
+	else if (caid_is_irdeto(caid))   result = Irdeto2EMM(caid, emmCopy, keysAdded);
+	else if (caid_is_powervu(caid))  result = PowervuEMM(emmCopy, keysAdded);
+	else if (caid_is_director(caid)) result = DirectorEmm(emmCopy, keysAdded);
+	else if (caid_is_dre(caid))      result = Drecrypt2EMM(rdr, provider, emmCopy, keysAdded);
+
+	if (result != 0)
+	{
+		cs_log_dbg(D_EMM,"EMM failed: %s", GetProcessEMMErrorReason(result));
+	}
+
+	return result;
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-osemu.h b/module-emulator-osemu.h
new file mode 100644
index 0000000..812c146
--- /dev/null
+++ b/module-emulator-osemu.h
@@ -0,0 +1,106 @@
+#ifndef MODULE_EMULATOR_H_
+#define MODULE_EMULATOR_H_
+
+#ifdef WITH_EMU
+
+#define EMU_MAX_CHAR_KEYNAME 12
+#define EMU_KEY_FILENAME "SoftCam.Key"
+#define EMU_KEY_FILENAME_MAX_LEN 31
+#define EMU_MAX_ECM_LEN MAX_ECM_SIZE
+#define EMU_MAX_EMM_LEN MAX_EMM_SIZE
+
+/*
+ * Error codes for ProccessECM and ProccessEMM functions
+ *  0 - OK
+ *  1 - ECM / EMM not supported
+ *  2 - ECM / EMM key not found
+ *  3 - Nano80 error
+ *  4 - Corrupt data
+ *  5 - CW not found
+ *  6 - CW / ECM / EMM checksum error
+ *  7 - Out of memory
+ *  8 - ICG error
+ *  9 - Wrong provider
+ * 10 - ECM key rejected
+*/
+
+#define EMU_OK             0
+#define EMU_NOT_SUPPORTED  1
+#define EMU_KEY_NOT_FOUND  2
+#define EMU_NANO_80_ERROR  3
+#define EMU_CORRUPT_DATA   4
+#define EMU_CW_NOT_FOUND   5
+#define EMU_CHECKSUM_ERROR 6
+#define EMU_OUT_OF_MEMORY  7
+#define EMU_ICG_ERROR      8
+#define EMU_WRONG_PROVID   9
+#define EMU_KEY_REJECTED  10
+
+typedef struct KeyData KeyData;
+
+struct KeyData
+{
+	char identifier;
+	uint32_t provider;
+	char keyName[EMU_MAX_CHAR_KEYNAME];
+	uint8_t *key;
+	uint32_t keyLength;
+	KeyData *nextKey;
+};
+
+typedef struct
+{
+	KeyData *EmuKeys;
+	uint32_t keyCount;
+	uint32_t keyMax;
+} KeyDataContainer;
+
+extern KeyDataContainer CwKeys;
+extern KeyDataContainer ViKeys;
+extern KeyDataContainer NagraKeys;
+extern KeyDataContainer IrdetoKeys;
+extern KeyDataContainer NDSKeys;
+extern KeyDataContainer BissKeys;
+extern KeyDataContainer PowervuKeys;
+extern KeyDataContainer DreKeys;
+extern KeyDataContainer TandbergKeys;
+extern uint8_t viasat_const[];
+extern char *emu_keyfile_path;
+extern pthread_mutex_t emu_key_data_mutex;
+
+void set_emu_keyfile_path(const char *path);
+void clear_emu_keydata(void);
+uint8_t read_emu_keyfile(struct s_reader *rdr, const char *path);
+
+#if !defined(__APPLE__) && !defined(__ANDROID__)
+void read_emu_keymemory(struct s_reader *rdr);
+#endif
+
+void read_emu_eebin(const char *path, const char *name);
+void read_emu_deskey(uint8_t *dreOverKey, uint8_t len);
+
+extern uint16_t GetEcmLen(const uint8_t *ecm);
+int8_t isValidDCW(uint8_t *dw);
+int8_t CharToBin(uint8_t *out, const char *in, uint32_t inLen);
+void Date2Str(char *dateStr, uint8_t len, int8_t offset, uint8_t format);
+KeyDataContainer *GetKeyContainer(char identifier);
+
+int8_t ProcessECM(struct s_reader *rdr, int16_t ecmDataLen, uint16_t caid, uint32_t provider,
+				const uint8_t *ecm, uint8_t *dw, uint16_t srvid, uint16_t ecmpid, EXTENDED_CW* cw_ex);
+
+int8_t ProcessEMM(struct s_reader *rdr, uint16_t caid, uint32_t provider, const uint8_t *emm,
+				uint32_t *keysAdded);
+
+int8_t FindKey(char identifier, uint32_t provider, uint32_t providerIgnoreMask, char *keyName,
+				uint8_t *key, uint32_t maxKeyLength, uint8_t isCriticalKey, uint32_t keyRef,
+				uint8_t matchLength, uint32_t *getProvider);
+
+int8_t SetKey(char identifier, uint32_t provider, char *keyName, uint8_t *orgKey, uint32_t keyLength,
+				uint8_t writeKey, char *comment, struct s_reader *rdr);
+
+int8_t UpdateKey(char identifier, uint32_t provider, char *keyName, uint8_t *key, uint32_t keyLength,
+				uint8_t writeKey, char *comment);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_H_
diff --git a/module-emulator-powervu.c b/module-emulator-powervu.c
new file mode 100644
index 0000000..2784c8f
--- /dev/null
+++ b/module-emulator-powervu.c
@@ -0,0 +1,2063 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "cscrypt/des.h"
+#include "ffdecsa/ffdecsa.h"
+#include "module-emulator-osemu.h"
+#include "module-emulator-streamserver.h"
+#include "module-emulator-powervu.h"
+#include "oscam-string.h"
+#include "oscam-time.h"
+
+static inline uint8_t GetBit(uint8_t byte, uint8_t bitnb)
+{
+	return ((byte & (1 << bitnb)) ? 1 : 0);
+}
+
+static inline uint8_t SetBit(uint8_t val, uint8_t bitnb, uint8_t biton)
+{
+	return (biton ? (val | (1 << bitnb)) : (val & ~(1 << bitnb)));
+}
+
+static uint8_t PowervuCrc8Calc(uint8_t *data, int len)
+{
+	int i;
+	uint8_t crc = 0;
+	uint8_t crcTable[256] = { 0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15,
+							  0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
+							  0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65,
+							  0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
+							  0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5,
+							  0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
+							  0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85,
+							  0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
+							  0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2,
+							  0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
+							  0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2,
+							  0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
+							  0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32,
+							  0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
+							  0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42,
+							  0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
+							  0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C,
+							  0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
+							  0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC,
+							  0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
+							  0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C,
+							  0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
+							  0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C,
+							  0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
+							  0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B,
+							  0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
+							  0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B,
+							  0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
+							  0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB,
+							  0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
+							  0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB,
+							  0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3 };
+
+	for(i = 0; i < len; i++)
+	{
+		crc = crcTable[data[i] ^ crc];
+	}
+
+	return crc;
+}
+
+static void PowervuPadData(uint8_t *data, int len, uint8_t *dataPadded)
+{
+	int i;
+	uint8_t pad[] = { 0x01, 0x02, 0x22, 0x04, 0x20, 0x2A, 0x1F, 0x03,
+					  0x04, 0x06, 0x02, 0x0C, 0x2B, 0x2B, 0x01, 0x7B };
+
+	for(i = 0; i < len; i++)
+	{
+		dataPadded[i] = data[i];
+	}
+
+	dataPadded[len] = 0x01;
+
+	for(i = len + 1; i < 0x2F; i++)
+	{
+		dataPadded[i] = 0x00;
+	}
+
+	dataPadded[0x2F] = len;
+
+	for(i = 0; i < 0x10; i++)
+	{
+		dataPadded[0x30 + i] = pad[i];
+	}
+}
+
+static void PowervuHashMode01CustomMD5(uint8_t *data, uint8_t *hash)
+{
+	int i, j, s;
+	uint32_t a, b, c, d, f = 0, g;
+
+	uint32_t T[] = { 0x783E16F6, 0xC267AC13, 0xA2B17F12, 0x6B8A31A4,
+					 0xF910654D, 0xB702DBCB, 0x266CEF60, 0x5145E47C,
+					 0xB92E00D6, 0xE80A4A64, 0x8A07FA77, 0xBA7D89A9,
+					 0xEBED8022, 0x653AAF2B, 0xF118B03B, 0x6CC16544,
+					 0x96EB6583, 0xF4E27E35, 0x1ABB119E, 0x068D3EF2,
+					 0xDAEAA8A5, 0x3C312A3D, 0x59538388, 0xA100772F,
+					 0xAB0165CE, 0x979959E7, 0x5DD8F53D, 0x189662BA,
+					 0xFD021A9C, 0x6BC2D338, 0x1EFF667E, 0x40C66888,
+					 0x6E9F07FF, 0x0CEF442F, 0x82D20190, 0x4E8CAEAC,
+					 0x0F7CB305, 0x2E73FBE7, 0x1CE884A2, 0x7A60BD52,
+					 0xC348B30D, 0x081CE3AA, 0xA12220E7, 0x38C7EC79,
+					 0xCBD8DD3A, 0x62B4FBA5, 0xAD2A63DB, 0xE4D0852E,
+					 0x53DE980F, 0x9C8DDA59, 0xA6B4CEDE, 0xB48A7692,
+					 0x0E2C46A4, 0xEB9367CB, 0x165D72EE, 0x75532B45,
+					 0xB9CA8E97, 0x08C8837B, 0x966F917B, 0x527515B4,
+					 0xF27A5E5D, 0xB71E6267, 0x7603D7E6, 0x9837DD69 }; // CUSTOM T
+
+	uint8_t r[] = { 0x06, 0x0A, 0x0F, 0x15, 0x05, 0x09, 0x0E, 0x14,
+					0x04, 0x0B, 0x10, 0x17, 0x07, 0x0C, 0x11, 0x16 }; // STANDARD REORDERED
+
+	uint8_t tIdxInit[] = {0, 1, 5, 0}; // STANDARD
+	uint8_t tIdxIncr[] = {1, 5, 3, 7}; // STANDARD
+
+	uint32_t h[] = { 0xEAD81D2E, 0xCE4DC6E9, 0xF9B5C301, 0x10325476 }; // CUSTOM h0, h1, h2, STANDARD h3
+	uint32_t dataLongs[16];
+
+	for (i = 0; i < 16; i++)
+	{
+		dataLongs[i] = (data[4 * i + 0] << 0) + (data[4 * i + 1] << 8) + (data[4 * i + 2] << 16) + (data[4 * i + 3] << 24);
+	}
+
+	a = h[0];
+	b = h[1];
+	c = h[2];
+	d = h[3];
+
+	for (i = 0; i < 4; i++)
+	{
+		g = tIdxInit[i];
+
+		for (j = 0; j < 16; j++)
+		{
+			if (i == 0)
+			{
+				f = (b & c) | (~b & d);
+			}
+			else if (i == 1)
+			{
+				f = (b & d) | (~d & c);
+			}
+			else if (i == 2)
+			{
+				f = (b ^ c ^ d);
+			}
+			else if (i == 3)
+			{
+				f = (~d | b) ^ c;
+			}
+
+			f = dataLongs[g] + a + T[16 * i + j] + f;
+
+			s = r[4 * i + (j & 3)];
+			f = (f << s) | (f >> (32 - s));
+
+			a = d;
+			d = c;
+			c = b;
+			b += f;
+
+			g = (g + tIdxIncr[i]) & 0xF;
+		}
+	}
+
+	h[0] += a;
+	h[1] += b;
+	h[2] += c;
+	h[3] += d;
+
+	for (i = 0; i < 4; i++)
+	{
+		hash[4 * i + 0] = h[i] >> 0;
+		hash[4 * i + 1] = h[i] >> 8;
+		hash[4 * i + 2] = h[i] >> 16;
+		hash[4 * i + 3] = h[i] >> 24;
+	}
+}
+
+static void PowervuHashMode02(uint8_t *data, uint8_t *hash)
+{
+	int i;
+	uint32_t a, b, c, d, e, f = 0, tmp;
+	uint32_t h[] = { 0x81887F3A, 0x36CCA480, 0x99056FB1, 0x79705BAE };
+	uint32_t dataLongs[80];
+
+	for (i = 0; i < 16; i++)
+	{
+		dataLongs[i] = (data[4 * i + 0] << 24) + (data[4 * i + 1] << 16) + (data[4 * i + 2] << 8) + (data[4 * i + 3] << 0);
+	}
+
+	for (i = 0; i < 64; i++)
+	{
+		dataLongs[16 + i] = dataLongs[16 + i - 2];
+		dataLongs[16 + i] ^= dataLongs[16 + i - 7];
+		dataLongs[16 + i] ^= dataLongs[16 + i - 13];
+		dataLongs[16 + i] ^= dataLongs[16 + i - 16];
+	}
+
+	a = dataLongs[0];
+	b = dataLongs[1];
+	c = dataLongs[2];
+	d = dataLongs[3];
+	e = dataLongs[4];
+
+	for (i = 0; i < 80; i++)
+	{
+		if (i < 0x15) f = (b & c) | (~b & d);
+		else if (i < 0x28) f = (b ^ c ^ d);
+		else if (i < 0x3D) f = (b & c) | (c & d) | (b & d);
+		else if (i < 0x50) f = (b ^ c ^ d);
+
+		tmp = a;
+		a = e + f + (a << 5) + (a >> 27) + h[i / 0x14] + dataLongs[i];
+		e = d;
+		d = c;
+		c = (b << 30) + (b >> 2);
+		b = tmp;
+	}
+
+	dataLongs[0] += a;
+	dataLongs[1] += b;
+	dataLongs[2] += c;
+	dataLongs[3] += d;
+
+	for (i = 0; i < 4; i++)
+	{
+		hash[4 * i + 0] = dataLongs[i] >> 24;
+		hash[4 * i + 1] = dataLongs[i] >> 16;
+		hash[4 * i + 2] = dataLongs[i] >> 8;
+		hash[4 * i + 3] = dataLongs[i] >> 0;
+	}
+}
+
+static void PowervuHashMode03(uint8_t *data, uint8_t *hash)
+{
+	int i, j, k, s, s2, tmp;
+	uint32_t a, b, c, d, f = 0, g;
+	uint32_t a2, b2, c2, d2, f2 = 0, g2;
+
+	uint32_t T[] = { 0xC88F3F2E, 0x967506BA, 0xDA877A7B, 0x0DECCDFE };
+	uint32_t T2[] = { 0x01F42668, 0x39C7CDA5, 0xD490E2FE, 0x9965235D };
+
+	uint8_t r[] = { 0x0B, 0x0E, 0x0F, 0x0C, 0x05, 0x08, 0x07, 0x09,
+					0x0B, 0x0D, 0x0E, 0x0F, 0x06, 0x07, 0x09, 0x08,
+					0x07, 0x06, 0x08, 0x0D, 0x0B, 0x09, 0x07, 0x0F,
+					0x07, 0x0C, 0x0F, 0x09, 0x0B, 0x07, 0x0D, 0x0C };
+
+	uint8_t tIdxIncr[] = { 0x07, 0x04, 0x0D, 0x01, 0x0A, 0x06, 0x0F, 0x03,
+						   0x0C, 0x00, 0x09, 0x05, 0x02, 0x0E, 0x0B, 0x08,
+						   0x05, 0x0D, 0x02, 0x00, 0x04, 0x09, 0x03, 0x08,
+						   0x01, 0x0A, 0x07, 0x0B, 0x06, 0x0F, 0x0C, 0x0E };
+
+	uint32_t h[] = { 0xC8616857, 0x9D3F5B8E, 0x4D7B8F76, 0x97BC8D80 };
+
+	uint32_t dataLongs[80];
+	uint32_t result[4];
+
+	for (i = 0; i < 16; i++)
+	{
+		dataLongs[i] = (data[4 * i + 0] << 24) + (data[4 * i + 1] << 16) + (data[4 * i + 2] << 8) + (data[4 * i + 3] << 0);
+	}
+
+	a = h[0];
+	b = h[1];
+	c = h[2];
+	d = h[3];
+
+	a2 = h[3];
+	b2 = h[2];
+	c2 = h[1];
+	d2 = h[0];
+
+	for (i = 0; i < 4; i++)
+	{
+		for (j = 0; j < 16; j++)
+		{
+			tmp = j;
+
+			for (k = 0; k < i; k++)
+			{
+				tmp = tIdxIncr[tmp];
+			}
+
+			g = 0x0F - tmp;
+			g2 = tmp;
+
+			if (i == 0) f = (b & d) | (~d & c);
+			else if (i == 1) f = (~c | b) ^ d;
+			else if (i == 2) f = (~b & d) | (b & c);
+			else if (i == 3) f = (b ^ c ^ d);
+
+			if (i == 0) f2 = (b2 ^ c2 ^ d2);
+			else if (i == 1) f2 = (~b2 & d2) | (b2 & c2);
+			else if (i == 2) f2 = (~c2 | b2) ^ d2;
+			else if (i == 3) f2 = (b2 & d2) | (~d2 & c2);
+
+			f = dataLongs[g] + a + T[i] + f;
+			s = r[0x0F + (((i & 1) ^ 1) << 4) - j];
+			f = (f << s) | (f >> (32 - s));
+
+			f2 = dataLongs[g2] + a2 + T2[i] + f2;
+			s2 = r[((i & 1) << 4) + j];
+			f2 = (f2 << s2) | (f2 >> (32 - s2));
+
+			a = d;
+			d = (c << 10) | (c >> 22);
+			c = b;
+			b = f;
+
+			a2 = d2;
+			d2 = (c2 << 10) | (c2 >> 22);
+			c2 = b2;
+			b2 = f2;
+		}
+	}
+
+	result[0] = h[3] + b + a2;
+	result[1] = h[2] + c + b2;
+	result[2] = h[1] + d + c2;
+	result[3] = h[0] + a + d2;
+
+	for (i = 0; i < 4; i++)
+	{
+		hash[4 * i + 0] = result[i] >> 0;
+		hash[4 * i + 1] = result[i] >> 8;
+		hash[4 * i + 2] = result[i] >> 16;
+		hash[4 * i + 3] = result[i] >> 24;
+	}
+}
+
+static const uint8_t table04[] = { 0x02, 0x03, 0x07, 0x0B, 0x0D, 0x08, 0x00, 0x01,
+								   0x2B, 0x2D, 0x28, 0x20, 0x21, 0x0A, 0x0C, 0x0E,
+								   0x22, 0x36, 0x23, 0x27, 0x29, 0x24, 0x25, 0x26,
+								   0x2A, 0x3C, 0x3E, 0x3F, 0x0F, 0x2C, 0x2E, 0x2F,
+								   0x12, 0x13, 0x17, 0x1B, 0x1C, 0x18, 0x10, 0x11,
+								   0x19, 0x14, 0x15, 0x16, 0x1A, 0x09, 0x04, 0x05,
+								   0x32, 0x33, 0x37, 0x3B, 0x06, 0x1C, 0x1E, 0x1F,
+								   0x3D, 0x38, 0x30, 0x31, 0x39, 0x34, 0x35, 0x3A };
+
+static const uint8_t table05[] = { 0x08, 0x09, 0x0A, 0x03, 0x04, 0x3F, 0x27, 0x28,
+								   0x29, 0x2A, 0x05, 0x0B, 0x1B, 0x1C, 0x1C, 0x1E,
+								   0x20, 0x0C, 0x0D, 0x22, 0x23, 0x24, 0x00, 0x01,
+								   0x02, 0x06, 0x07, 0x25, 0x26, 0x0E, 0x0F, 0x21,
+								   0x10, 0x11, 0x12, 0x2E, 0x2F, 0x13, 0x14, 0x15,
+								   0x2B, 0x2C, 0x2D, 0x16, 0x17, 0x18, 0x19, 0x1A,
+								   0x30, 0x31, 0x37, 0x3B, 0x3C, 0x3D, 0x3E, 0x1F,
+								   0x38, 0x39, 0x32, 0x33, 0x34, 0x35, 0x36, 0x3A };
+
+static const uint8_t table06[] = { 0x00, 0x01, 0x02, 0x06, 0x07, 0x08, 0x03, 0x2A,
+								   0x2B, 0x2C, 0x2E, 0x2F, 0x04, 0x05, 0x09, 0x0D,
+								   0x20, 0x21, 0x22, 0x26, 0x27, 0x3A, 0x3B, 0x3C,
+								   0x3E, 0x3F, 0x10, 0x11, 0x12, 0x16, 0x17, 0x28,
+								   0x18, 0x13, 0x14, 0x15, 0x19, 0x1C, 0x1A, 0x1B,
+								   0x1C, 0x1E, 0x1F, 0x23, 0x24, 0x25, 0x29, 0x2D,
+								   0x30, 0x31, 0x32, 0x36, 0x37, 0x38, 0x33, 0x34,
+								   0x0A, 0x0B, 0x0C, 0x0E, 0x0F, 0x35, 0x39, 0x3D };
+
+static const uint8_t table07[] = { 0x10, 0x11, 0x12, 0x17, 0x1C, 0x1E, 0x0E, 0x38,
+								   0x39, 0x3A, 0x13, 0x14, 0x29, 0x2A, 0x16, 0x1F,
+								   0x00, 0x01, 0x02, 0x3C, 0x3D, 0x3E, 0x3F, 0x07,
+								   0x08, 0x09, 0x03, 0x04, 0x05, 0x06, 0x3B, 0x0A,
+								   0x20, 0x21, 0x22, 0x19, 0x1A, 0x1B, 0x1C, 0x0B,
+								   0x0C, 0x15, 0x23, 0x24, 0x25, 0x26, 0x18, 0x0F,
+								   0x30, 0x31, 0x2B, 0x33, 0x34, 0x35, 0x36, 0x37,
+								   0x27, 0x28, 0x2C, 0x2D, 0x2E, 0x2F, 0x32, 0x0D };
+
+static const uint8_t table08[] = { 0x10, 0x11, 0x1E, 0x17, 0x18, 0x19, 0x12, 0x13,
+								   0x14, 0x1C, 0x1C, 0x15, 0x0D, 0x05, 0x06, 0x0A,
+								   0x00, 0x01, 0x0E, 0x07, 0x08, 0x09, 0x02, 0x2D,
+								   0x25, 0x26, 0x2A, 0x2B, 0x2F, 0x03, 0x04, 0x0C,
+								   0x20, 0x21, 0x2E, 0x27, 0x28, 0x29, 0x30, 0x31,
+								   0x3E, 0x37, 0x38, 0x39, 0x22, 0x23, 0x24, 0x2C,
+								   0x32, 0x33, 0x34, 0x3C, 0x3D, 0x35, 0x36, 0x3A,
+								   0x3B, 0x0B, 0x0F, 0x16, 0x1A, 0x1B, 0x1F, 0x3F };
+
+static const uint8_t table09[] = { 0x20, 0x21, 0x24, 0x22, 0x23, 0x2A, 0x2B, 0x33,
+								   0x35, 0x38, 0x39, 0x36, 0x2D, 0x2C, 0x2E, 0x2F,
+								   0x00, 0x01, 0x04, 0x02, 0x25, 0x28, 0x08, 0x09,
+								   0x06, 0x07, 0x0A, 0x0B, 0x0D, 0x0C, 0x0E, 0x0F,
+								   0x10, 0x11, 0x14, 0x12, 0x13, 0x15, 0x19, 0x16,
+								   0x29, 0x26, 0x03, 0x17, 0x1A, 0x1C, 0x1C, 0x1E,
+								   0x30, 0x31, 0x34, 0x32, 0x37, 0x3A, 0x3B, 0x3D,
+								   0x3C, 0x3E, 0x3F, 0x1B, 0x05, 0x18, 0x27, 0x1F };
+
+static const uint8_t table0A[] = { 0x00, 0x04, 0x05, 0x0B, 0x0C, 0x06, 0x09, 0x0A,
+								   0x0E, 0x0D, 0x0F, 0x25, 0x15, 0x1B, 0x1C, 0x16,
+								   0x10, 0x11, 0x01, 0x02, 0x03, 0x07, 0x08, 0x12,
+								   0x13, 0x17, 0x18, 0x14, 0x23, 0x27, 0x28, 0x24,
+								   0x30, 0x31, 0x32, 0x33, 0x37, 0x38, 0x34, 0x35,
+								   0x3B, 0x3C, 0x20, 0x21, 0x22, 0x2B, 0x2C, 0x26,
+								   0x36, 0x39, 0x3A, 0x3E, 0x3D, 0x19, 0x1A, 0x1E,
+								   0x1C, 0x1F, 0x3F, 0x29, 0x2A, 0x2E, 0x2D, 0x2F };
+
+static void PowervuHashModes04to0ATables(uint8_t *data, uint8_t *hash, const uint8_t *table)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+	{
+		hash[i] = table[i];
+		hash[i] ^= data[table[i]];
+		hash[i] ^= table[16 + i];
+		hash[i] ^= data[table[16 + i]];
+		hash[i] ^= table[32 + i];
+		hash[i] ^= data[table[32 + i]];
+		hash[i] ^= table[48 + i];
+		hash[i] ^= data[table[48 + i]];
+	}
+}
+
+static const uint8_t table0F[] = { 0xC7, 0x45, 0x15, 0x71, 0x61, 0x07, 0x05, 0x47 };
+static const uint8_t table10[] = { 0x0F, 0x47, 0x2B, 0x6C, 0xAD, 0x0F, 0xB3, 0xEA };
+static const uint8_t table11[] = { 0xB1, 0x46, 0xD1, 0x66, 0x5D, 0x28, 0x59, 0xD2 };
+static const uint8_t table12[] = { 0x0B, 0x4B, 0xD7, 0x68, 0x5F, 0xAD, 0x4B, 0xBB };
+static const uint8_t table13[] = { 0x4F, 0x4E, 0xE1, 0x6A, 0x21, 0xD3, 0xF7, 0xA6 };
+static const uint8_t table14[] = { 0xDD, 0x39, 0xB9, 0x65, 0x03, 0x91, 0xF1, 0xAC };
+static const uint8_t table15[] = { 0x3F, 0x50, 0xB5, 0x6F, 0x37, 0xC9, 0x13, 0x5D };
+static const uint8_t table16[] = { 0xF9, 0x5C, 0xFD, 0x72, 0x19, 0x42, 0x23, 0x6B };
+static const uint8_t table17[] = { 0xDF, 0x60, 0x93, 0x64, 0x33, 0x16, 0xB3, 0x8A };
+static const uint8_t table18[] = { 0x09, 0x64, 0x5F, 0x6B, 0xFB, 0x21, 0x19, 0xE4 };
+
+static void PowervuHashModes0Fto18Tables(uint8_t *data, uint8_t *hash, const uint8_t *table)
+{
+	int i;
+	uint32_t t[4], tmp;
+
+	memset(hash, 0x00, 16);
+
+	t[0] = (table[1] << 8) + table[0];
+	t[1] = (table[3] << 8) + table[2];
+	t[2] = (table[5] << 8) + table[4];
+	t[3] = (table[7] << 8) + table[6];
+
+	for (i = 0; i < 60; i += 4)
+	{
+		t[0] = ((t[0] & 0xFFFF) * t[2]) + (t[0] >> 16);
+		t[1] = ((t[1] & 0xFFFF) * t[3]) + (t[1] >> 16);
+		tmp = t[0] + t[1];
+
+		hash[(i + 0) & 0x0F] = hash[(i + 0) & 0x0F] ^ data[i + 0] ^ (tmp >> 24);
+		hash[(i + 1) & 0x0F] = hash[(i + 1) & 0x0F] ^ data[i + 1] ^ (tmp >> 16);
+		hash[(i + 2) & 0x0F] = hash[(i + 2) & 0x0F] ^ data[i + 2] ^ (tmp >> 8);
+		hash[(i + 3) & 0x0F] = hash[(i + 3) & 0x0F] ^ data[i + 3] ^ (tmp >> 0);
+	}
+}
+
+static const uint8_t table19[] = { 0x02, 0x03, 0x05, 0x10 };
+static const uint8_t table1A[] = { 0x01, 0x05, 0x08, 0x10 };
+static const uint8_t table1B[] = { 0x03, 0x07, 0x08, 0x10 };
+
+static void PowervuHashModes19to27Tables3(uint8_t *data, uint8_t *hash, const uint8_t *table)
+{
+	int i;
+	uint8_t val, it[4];
+	uint16_t seed = 0xFFFF, tmp;
+
+	memset(hash, 0x00, 16);
+
+	for (i = 0; i < 4; i++)
+	{
+		it[i] = 0x10 - table[i];
+	}
+
+	for (i = 0; i < 16; i++)
+	{
+		val = ((seed >> it[0]) ^ (seed >> it[1]) ^ (seed >> it[2]) ^ (seed >> it[3])) & 0x01;
+
+		if (val == 0x00)
+		{
+			seed = seed >> 1;
+		}
+		else
+		{
+			seed = (seed >> 1) | 0x8000;
+		}
+		tmp = seed + (data[i] << 8) + data[i + 32];
+
+		val = ((seed >> it[0]) ^ (seed >> it[1]) ^ (seed >> it[2]) ^ (seed >> it[3])) & 0x01;
+
+		if (val == 0x00)
+		{
+			seed = seed >> 1;
+		}
+		else
+		{
+			seed = (seed >> 1) | 0x8000;
+		}
+		tmp = tmp + seed + (data[i + 16] << 8) + data[i + 48];
+
+		hash[i & 0x0F] ^= tmp >> 8;
+		hash[(i + 1) & 0x0F] ^= tmp;
+	}
+}
+
+static void PowervuCreateHash(uint8_t *data, int len, uint8_t *hash, int mode)
+{
+	uint8_t dataPadded[64];
+
+	PowervuPadData(data, len, dataPadded);
+
+	switch (mode)
+	{
+		case 1:
+			PowervuHashMode01CustomMD5(dataPadded, hash);
+			break;
+
+		case 2:
+			PowervuHashMode02(dataPadded, hash);
+			break;
+
+		case 3:
+			PowervuHashMode03(dataPadded, hash);
+			break;
+
+		case 4:
+			PowervuHashModes04to0ATables(dataPadded, hash, table04);
+			break;
+
+		case 5:
+			PowervuHashModes04to0ATables(dataPadded, hash, table05);
+			break;
+
+		case 6:
+			PowervuHashModes04to0ATables(dataPadded, hash, table06);
+			break;
+
+		case 7:
+			PowervuHashModes04to0ATables(dataPadded, hash, table07);
+			break;
+
+		case 8:
+			PowervuHashModes04to0ATables(dataPadded, hash, table08);
+			break;
+
+		case 9:
+			PowervuHashModes04to0ATables(dataPadded, hash, table09);
+			break;
+
+		case 10:
+			PowervuHashModes04to0ATables(dataPadded, hash, table0A);
+			break;
+
+		case 15:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table0F);
+			break;
+
+		case 16:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table10);
+			break;
+
+		case 17:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table11);
+			break;
+
+		case 18:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table12);
+			break;
+
+		case 19:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table13);
+			break;
+
+		case 20:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table14);
+			break;
+
+		case 21:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table15);
+			break;
+
+		case 22:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table16);
+			break;
+
+		case 23:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table17);
+			break;
+
+		case 24:
+			PowervuHashModes0Fto18Tables(dataPadded, hash, table18);
+			break;
+
+		case 25:
+			PowervuHashModes19to27Tables3(dataPadded, hash, table19);
+			break;
+
+		case 26:
+			PowervuHashModes19to27Tables3(dataPadded, hash, table1A);
+			break;
+
+		case 27:
+			PowervuHashModes19to27Tables3(dataPadded, hash, table1B);
+			break;
+
+		default:
+			cs_log("A new hash mode [%d] is in use.", mode);
+			break;
+	}
+}
+
+void PowervuCreateHashMode03(uint8_t *data, uint8_t *hash)
+{
+	int i, j, c;
+	uint8_t buffer0[16], buffer1[8], buffer2[8], tmpBuff1[4], tmpBuff2[4];
+
+	uint8_t table[] = { 0x68, 0xCE, 0xE7, 0x71, 0xCC, 0x3A, 0x0B, 0x6E,
+						0x2A, 0x43, 0x17, 0x07, 0x5A, 0xD9, 0x14, 0x5B,
+						0xB0, 0x8E, 0xA8, 0x7F, 0xD8, 0xA2, 0xCF, 0x73,
+						0xC2, 0xB9, 0x5D, 0x46, 0xDD, 0x2C, 0xE2, 0x2D,
+						0xFD, 0x50, 0xE9, 0x7C, 0x28, 0x72, 0x9B, 0xAA,
+						0xEC, 0x24, 0x74, 0xAB, 0x00, 0x1C, 0x8B, 0x65,
+						0x38, 0x13, 0x22, 0x82, 0xAC, 0x9A, 0x4D, 0x2B,
+						0xEA, 0x04, 0x31, 0x84, 0x32, 0x3D, 0x36, 0x53,
+						0x5F, 0x42, 0x96, 0xDE, 0x47, 0x08, 0x51, 0x4B,
+						0x3E, 0xD1, 0x1E, 0x12, 0xD2, 0x1F, 0x7D, 0x26,
+						0xCD, 0x57, 0x8C, 0xB6, 0xD3, 0xF8, 0x11, 0xAD,
+						0x6A, 0x88, 0x95, 0x21, 0xE8, 0xBF, 0x6B, 0x27,
+						0xBE, 0xA3, 0x33, 0xB8, 0x9E, 0xB3, 0x6C, 0xC3,
+						0x06, 0xC7, 0x6F, 0x99, 0x97, 0xDA, 0x09, 0xAF,
+						0xAE, 0xCB, 0x79, 0x37, 0x55, 0x85, 0x8D, 0x2F,
+						0x8A, 0x70, 0xA1, 0x7A, 0x66, 0x29, 0x67, 0x0F,
+						0xEB, 0x9C, 0xC8, 0xC4, 0xD6, 0x4C, 0xDF, 0x1A,
+						0xC0, 0x01, 0x64, 0xBC, 0x4E, 0xE1, 0x54, 0xD7,
+						0x4F, 0xB7, 0x5E, 0xCA, 0xF0, 0x91, 0xE4, 0x59,
+						0x4A, 0xC6, 0x83, 0x8F, 0xBD, 0x61, 0xFF, 0x56,
+						0x92, 0xF1, 0x5C, 0x77, 0xC9, 0x20, 0xF4, 0xE5,
+						0x10, 0x69, 0x03, 0x1D, 0xD5, 0x45, 0xF6, 0x0E,
+						0xEF, 0xA0, 0xE3, 0x58, 0xFC, 0xED, 0x80, 0x16,
+						0xEE, 0xFA, 0x02, 0xF5, 0xB4, 0x0A, 0xE0, 0x0C,
+						0xF7, 0xF9, 0xBA, 0x7E, 0x18, 0x78, 0x19, 0xB5,
+						0x0D, 0x44, 0x34, 0xD4, 0xDC, 0x30, 0x6D, 0x3B,
+						0x63, 0x41, 0x48, 0x40, 0xA7, 0xA5, 0xC5, 0x98,
+						0x76, 0x3F, 0xC1, 0x25, 0x93, 0x49, 0xD0, 0x62,
+						0x2E, 0x75, 0xDB, 0x94, 0xF3, 0x52, 0x05, 0x81,
+						0xFB, 0xBB, 0xA6, 0x89, 0x39, 0xA4, 0xF2, 0xA9,
+						0xFE, 0x60, 0x3C, 0x15, 0xB1, 0x35, 0x86, 0x9D,
+						0x9F, 0x90, 0x1B, 0xE6, 0x7B, 0x23, 0x87, 0xB2 };
+
+	for (i = 0; i < 4; i++)
+	{
+		buffer0[0 + i] = data[12 + i];
+		buffer0[4 + i] = data[8 + i];
+		buffer0[8 + i] = data[4 + i];
+		buffer0[12 + i] = data[0 + i];
+	}
+
+	for (c = 0; c < 12; c++)
+	{
+		for (i = 0; i < 4; i++)
+		{
+			buffer1[0 + i] = buffer0[8 + i] ^ buffer0[12 + i];
+			buffer1[4 + i] = buffer0[0 + i] ^ buffer0[4 + i];
+		}
+
+		for (i = 0; i < 8; i++)
+		{
+			buffer1[i] = table[buffer1[i] ^ data[16 + 16 * (c % 3) + i]];
+		}
+
+		for (j = 0; j < 8; j++)
+		{
+			buffer2[j] = 0;
+			for (i = 0; i < 8; i++)
+			{
+				buffer2[j] ^= buffer1[i] * (j * i + 1);
+			}
+		}
+
+		for (i = 0; i < 8; i++)
+		{
+			buffer2[i] = table[buffer2[i] ^ data[24 + 16 * (c % 3) + i]] ^ data[16 + 16 * (c % 3) + i];
+		}
+
+		for (i = 0; i < 4; i++)
+		{
+			buffer0[12 + i] ^= buffer2[0 + i];
+			buffer0[8 + i] ^= buffer2[0 + i];
+			buffer0[4 + i] ^= buffer2[4 + i];
+			buffer0[0 + i] ^= buffer2[4 + i];
+		}
+
+		tmpBuff1[0] = buffer0[14];
+		tmpBuff1[1] = buffer0[15];
+		tmpBuff1[2] = buffer0[12] ^ buffer0[14];
+		tmpBuff1[3] = buffer0[13] ^ buffer0[15];
+
+		tmpBuff2[0] = buffer0[6];
+		tmpBuff2[1] = buffer0[7];
+		tmpBuff2[2] = buffer0[4] ^ buffer0[6];
+		tmpBuff2[3] = buffer0[5] ^ buffer0[7];
+
+		for (i = 0; i < 4; i++)
+		{
+			buffer0[12 + i] = tmpBuff1[i];
+			buffer0[4 + i] = tmpBuff2[i];
+		}
+	}
+
+	for (i = 0; i < 4; i++)
+	{
+		hash[0 + i] = buffer0[12 + i] ^ data[0 + i];
+		hash[4 + i] = buffer0[8 + i] ^ data[4 + i];
+		hash[8 + i] = buffer0[4 + i] ^ data[8 + i];
+		hash[12 + i] = buffer0[0 + i] ^ data[12 + i];
+	}
+}
+
+void PowervuCreateDataCwMode03(uint8_t *seed, int lenSeed, uint8_t *basecw, uint8_t val,
+								uint8_t *ecmBody, uint8_t *data)
+{
+	uint8_t padding[] = { 0x4A, 0x56, 0x7F, 0x16, 0xFC, 0x1F, 0x5B, 0x95,
+						  0x19, 0xEF, 0x75, 0x14, 0x0E, 0x9E, 0x17, 0x3C,
+						  0xF5, 0xB7, 0xA0, 0x93, 0xA3, 0x0F, 0xFA, 0x38,
+						  0x7A, 0x34, 0x6C, 0xDC, 0xFB, 0xB0, 0x24, 0x42,
+						  0x74, 0x72, 0x1C, 0xDC, 0x1E, 0xA1, 0x6D, 0xAB,
+						  0xC8, 0x44, 0x53, 0xEF, 0x56, 0x00, 0xE9, 0x97,
+						  0x48, 0x77, 0xF8, 0x00, 0x8E, 0x0B, 0x78, 0xA2 };
+
+	memcpy(data + 8, padding, 56);
+
+	data[0] = ecmBody[0x0F];
+	data[1] = ecmBody[0x09];
+	data[2] = ecmBody[0x10];
+	data[3] = ecmBody[0x11];
+	data[4] = ecmBody[0x05];
+	data[5] = ecmBody[0x07];
+	data[6] = ecmBody[0x08];
+	data[7] = ecmBody[0x0A];
+
+	int idxData = 8, idxSeed = 0, idxBase = 0;
+	while (idxBase < 7)
+	{
+		if ((idxBase == 0) || (idxBase == 2) || (idxBase == 5)) data[idxData++] = val;
+		if (idxSeed < lenSeed) data[idxData++] = seed[idxSeed++];
+		data[idxData++] = basecw[idxBase++];
+	}
+}
+
+void PowervuCreateDataUnmaskMode03(uint8_t *ecmBody, uint8_t *data)
+{
+	uint8_t padding[] = { 0xB1, 0x7C, 0xD2, 0xA7, 0x5E, 0x45, 0x6C, 0x36,
+						  0xF0, 0xB6, 0x81, 0xF3, 0x25, 0x06, 0x65, 0x06,
+						  0x6B, 0xBF, 0x4C, 0xE7, 0xED, 0x6E, 0x85, 0x00,
+						  0xCC, 0xF2, 0x61, 0x48, 0x62, 0x24, 0x0E, 0x3C,
+						  0x05, 0x89, 0xA5, 0x39, 0x5A, 0x4E, 0x9B, 0xC8,
+						  0x14, 0x78, 0xEA, 0xB6, 0xFB, 0xF8, 0x10, 0xE6,
+						  0x61, 0xF5, 0x3A, 0xBC, 0x5B, 0x79, 0x09, 0x97 };
+
+	memcpy(data + 8, padding, 56);
+
+	data[0] = ecmBody[0x17];
+	data[1] = ecmBody[0x26];
+	data[2] = ecmBody[0x19];
+	data[3] = ecmBody[0x21];
+	data[4] = ecmBody[0x26];
+	data[5] = ecmBody[0x31];
+	data[6] = ecmBody[0x21];
+	data[7] = ecmBody[0x27];
+}
+
+uint8_t PowervuGetModeCW(uint8_t *extraData)
+{
+	uint64_t data = ((uint32_t)extraData[0] << 24) + (extraData[1] << 16) + (extraData[2] << 8) + extraData[3];
+	uint64_t t1 = (data * 0x76E9DEA7) >> 50;
+	uint64_t t2 = (t1 * 0x51EB851F) >> 36;
+	uint64_t t3 = t2 * 0x32;
+	uint8_t r = t1 - t3;
+	return r;
+}
+
+uint8_t PowervuGetModeUnmask(uint8_t *extraData)
+{
+	uint64_t data = ((uint32_t)extraData[0] << 24) + (extraData[1] << 16) + (extraData[2] << 8) + extraData[3];
+	uint64_t t1 = (data * 0xB9CD6BE5) >> 45;
+	uint64_t t2 = (t1 * 0x51EB851F) >> 36;
+	uint64_t t3 = t2 * 0x32;
+	uint8_t r = t1 - t3;
+	return r;
+}
+
+static void PowervuCreateDataEcmEmm(uint8_t *emmEcm, uint8_t *pos, int lenHeader, int len, uint8_t *data)
+{
+	int i;
+
+	for (i = 0; i < len; i++)
+	{
+		data[i] = emmEcm[lenHeader + pos[i]];
+	}
+}
+
+static uint8_t PowervuCreateDataCw(uint8_t *seed, uint8_t lenSeed, uint8_t *baseCw, uint8_t val,
+									uint8_t *seedEcmCw, uint8_t *data)
+{
+	int i;
+
+	for (i = 0; i < lenSeed; i++)
+	{
+		data[i] = seed[i];
+	}
+
+	for (i = 0; i < 7; i++)
+	{
+		data[lenSeed + i] = baseCw[i];
+	}
+
+	data[lenSeed + 7] = val;
+
+	for (i = 0; i < 16; i++)
+	{
+		data[lenSeed + 7 + 1 + i] = seedEcmCw[i];
+	}
+
+	return lenSeed + 7 + 1 + 0x10;
+}
+
+static uint8_t PowervuUnmaskEcm(uint8_t *ecm, uint8_t *seedEcmCw, uint8_t *modeCW)
+{
+	int i, l;
+	uint8_t data[64], mask[16];
+	uint8_t hashModeEcm, hashModeCw, modeUnmask = 0;
+	uint32_t crc;
+
+	uint8_t sourcePos[] = { 0x04, 0x05, 0x06, 0x07, 0x0A, 0x0B, 0x0C, 0x0D,
+							0x0E, 0x0F, 0x10, 0x17, 0x1C, 0x1D, 0x1F, 0x23,
+							0x24, 0x25, 0x26, 0x27, 0x29, 0x2C, 0x2D, 0x2E };
+
+	uint8_t destPos[] = { 0x08, 0x09, 0x11, 0x18, 0x19, 0x1A, 0x1B, 0x1E,
+						  0x20, 0x21, 0x22, 0x28, 0x2A, 0x2B, 0x2F, 0x30 };
+
+	uint8_t seedCwPos[] = {0x07, 0x0A, 0x04, 0x0D, 0x05, 0x0E, 0x06, 0x0B, 0x10, 0x0C, 0x0F};
+
+	// Create seed for CW decryption
+	memset(seedEcmCw, 0, 16);
+
+	int extraBytesLen = ecm[9];
+	int startOffset = extraBytesLen + 10;
+
+	for (i = 0; i < 11; i++)
+	{
+		seedEcmCw[i] = ecm[startOffset + seedCwPos[i]];
+	}
+
+	*modeCW = 0;
+	if (extraBytesLen > 0)
+	{
+		*modeCW = PowervuGetModeCW(ecm + 10);
+	}
+
+	// Read hash mode CW
+	hashModeCw = ecm[28 + extraBytesLen] ^ PowervuCrc8Calc(seedEcmCw, 16);
+
+	// Create mask for ECM decryption
+	PowervuCreateDataEcmEmm(ecm, sourcePos, startOffset, 24, data);
+
+	hashModeEcm = ecm[8] ^ PowervuCrc8Calc(data, 24);
+
+	if (extraBytesLen > 0)
+	{
+		modeUnmask = PowervuGetModeUnmask(ecm + 10);
+	}
+
+	if (modeUnmask == 0x03)
+	{
+		ecm[startOffset + 0x21] -= ecm[startOffset + 0x07];
+		ecm[startOffset + 0x26] -= ecm[startOffset + 0x05];
+		ecm[startOffset + 0x26] -= ecm[startOffset + 0x08];
+		ecm[startOffset + 0x19] -= ecm[startOffset + 0x06];
+		ecm[startOffset + 0x31] -= ecm[startOffset + 0x09];
+		ecm[startOffset + 0x27] -= ecm[startOffset + 0x0C];
+		ecm[startOffset + 0x21] -= ecm[startOffset + 0x0B];
+		ecm[startOffset + 0x17] -= ecm[startOffset + 0x04];
+
+		PowervuCreateDataUnmaskMode03(ecm + startOffset, data);
+		PowervuCreateHashMode03(data, mask);
+
+		// Unmask body
+		ecm[startOffset + 0x06] ^= mask[0x02];
+		ecm[startOffset + 0x0B] ^= mask[0x06];
+		ecm[startOffset + 0x0C] ^= mask[0x07];
+		ecm[startOffset + 0x0D] ^= mask[0x08];
+		ecm[startOffset + 0x0E] ^= mask[0x09];
+		ecm[startOffset + 0x0F] ^= mask[0x0A];
+		ecm[startOffset + 0x11] ^= mask[0x0B];
+		ecm[startOffset + 0x18] ^= mask[0x0C];
+		ecm[startOffset + 0x2D] ^= mask[0x0A];
+		ecm[startOffset + 0x07] ^= mask[0x03];
+		ecm[startOffset + 0x1B] ^= mask[0x0D];
+		ecm[startOffset + 0x30] ^= mask[0x0C];
+		ecm[startOffset + 0x1C] ^= mask[0x0E];
+		ecm[startOffset + 0x1E] ^= mask[0x00];
+		ecm[startOffset + 0x04] ^= mask[0x00];
+		ecm[startOffset + 0x05] ^= mask[0x01];
+		ecm[startOffset + 0x1F] ^= mask[0x01];
+		ecm[startOffset + 0x2C] ^= mask[0x09];
+		ecm[startOffset + 0x20] ^= mask[0x02];
+		ecm[startOffset + 0x1D] ^= mask[0x0F];
+		ecm[startOffset + 0x23] ^= mask[0x04];
+		ecm[startOffset + 0x09] ^= mask[0x05];
+		ecm[startOffset + 0x22] ^= mask[0x03];
+		ecm[startOffset + 0x24] ^= mask[0x05];
+		ecm[startOffset + 0x08] ^= mask[0x04];
+		ecm[startOffset + 0x28] ^= mask[0x06];
+		ecm[startOffset + 0x29] ^= mask[0x07];
+		ecm[startOffset + 0x2A] ^= mask[0x08];
+		ecm[startOffset + 0x2E] ^= mask[0x0B];
+
+		for (i = 0; i < ecm[9]; i++)
+		{
+			ecm[10 + i] = 0x00;
+		}
+	}
+	else if (modeUnmask == 0x04)
+	{
+		// Do nothing
+	}
+	else
+	{
+		PowervuCreateHash(data, 24, mask, hashModeEcm);
+		// Unmask body
+		for (i = 0; i < 16; i++)
+		{
+			ecm[startOffset + destPos[i]] ^= mask[i & 0x0F];
+		}
+	}
+
+	// Fix header
+	ecm[3] &= 0x0F;
+	ecm[3] |= 0x30;
+	ecm[8]  = 0x00;
+	ecm[28 + extraBytesLen] = 0x00;
+
+	// Fix CRC (optional)
+	l = (((ecm[1] << 8) + ecm[2]) & 0xFFF) + 3 - 4;
+
+	crc = fletcher_crc32(ecm, l);
+
+	ecm[l + 0] = crc >> 24;
+	ecm[l + 1] = crc >> 16;
+	ecm[l + 2] = crc >> 8;
+	ecm[l + 3] = crc >> 0;
+
+	for (i = 0; i < 11; i++)
+	{
+		seedEcmCw[i] = ecm[startOffset + seedCwPos[i]];
+	}
+
+	return hashModeCw;
+}
+
+static void PowervuCreateCw(uint8_t *seed, uint8_t lenSeed, uint8_t *baseCw, uint8_t val, uint8_t *seedEcmCw,
+							uint8_t *cw, int modeDesCsa, int hashMode, int modeCW, uint8_t* ecmBody)
+{
+	uint8_t data[64], hash[16], lenData;
+	int i;
+
+	uint8_t tableFixParity[] = { 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x07, 0x07,
+								 0x08, 0x08, 0x0B, 0x0B, 0x0D, 0x0D, 0x0E, 0x0E,
+								 0x10, 0x10, 0x13, 0x13, 0x15, 0x15, 0x16, 0x16,
+								 0x19, 0x19, 0x1A, 0x1A, 0x1C, 0x1C, 0x1F, 0x1F,
+								 0x20, 0x20, 0x23, 0x23, 0x25, 0x25, 0x26, 0x26,
+								 0x29, 0x29, 0x2A, 0x2A, 0x2C, 0x2C, 0x2F, 0x2F,
+								 0x31, 0x31, 0x32, 0x32, 0x34, 0x34, 0x37, 0x37,
+								 0x38, 0x38, 0x3B, 0x3B, 0x3D, 0x3D, 0x3E, 0x3E,
+								 0x40, 0x40, 0x43, 0x43, 0x45, 0x45, 0x46, 0x46,
+								 0x49, 0x49, 0x4A, 0x4A, 0x4C, 0x4C, 0x4F, 0x4F,
+								 0x51, 0x51, 0x52, 0x52, 0x54, 0x54, 0x57, 0x57,
+								 0x58, 0x58, 0x5B, 0x5B, 0x5D, 0x5D, 0x5E, 0x5E,
+								 0x61, 0x61, 0x62, 0x62, 0x64, 0x64, 0x67, 0x67,
+								 0x68, 0x68, 0x6B, 0x6B, 0x6D, 0x6D, 0x6E, 0x6E,
+								 0x70, 0x70, 0x73, 0x73, 0x75, 0x75, 0x76, 0x76,
+								 0x79, 0x79, 0x7A, 0x7A, 0x7C, 0x7C, 0x7F, 0x7F,
+								 0x80, 0x80, 0x83, 0x83, 0x85, 0x85, 0x86, 0x86,
+								 0x89, 0x89, 0x8A, 0x8A, 0x8C, 0x8C, 0x8F, 0x8F,
+								 0x91, 0x91, 0x92, 0x92, 0x94, 0x94, 0x97, 0x97,
+								 0x98, 0x98, 0x9B, 0x9B, 0x9D, 0x9D, 0x9E, 0x9E,
+								 0xA1, 0xA1, 0xA2, 0xA2, 0xA4, 0xA4, 0xA7, 0xA7,
+								 0xA8, 0xA8, 0xAB, 0xAB, 0xAD, 0xAD, 0xAE, 0xAE,
+								 0xB0, 0xB0, 0xB3, 0xB3, 0xB5, 0xB5, 0xB6, 0xB6,
+								 0xB9, 0xB9, 0xBA, 0xBA, 0xBC, 0xBC, 0xBF, 0xBF,
+								 0xC1, 0xC1, 0xC2, 0xC2, 0xC4, 0xC4, 0xC7, 0xC7,
+								 0xC8, 0xC8, 0xCB, 0xCB, 0xCD, 0xCD, 0xCE, 0xCE,
+								 0xD0, 0xD0, 0xD3, 0xD3, 0xD5, 0xD5, 0xD6, 0xD6,
+								 0xD9, 0xD9, 0xDA, 0xDA, 0xDC, 0xDC, 0xDF, 0xDF,
+								 0xE0, 0xE0, 0xE3, 0xE3, 0xE5, 0xE5, 0xE6, 0xE6,
+								 0xE9, 0xE9, 0xEA, 0xEA, 0xEC, 0xEC, 0xEF, 0xEF,
+								 0xF1, 0xF1, 0xF2, 0xF2, 0xF4, 0xF4, 0xF7, 0xF7,
+								 0xF8, 0xF8, 0xFB, 0xFB, 0xFD, 0xFD, 0xFE, 0xFE };
+
+	if (modeCW == 0x03)
+	{
+		PowervuCreateDataCwMode03(seed, lenSeed, baseCw, val, ecmBody, data);
+		PowervuCreateHashMode03(data, hash);
+
+		cw[0] = hash[0x09];
+		cw[1] = hash[0x01];
+		cw[2] = hash[0x0F];
+		cw[3] = hash[0x0E];
+		cw[4] = hash[0x04];
+		cw[5] = hash[0x02];
+		cw[6] = hash[0x05];
+		cw[7] = hash[0x0D];
+	}
+	else if (modeCW == 0x04)
+	{
+		// Do nothing
+	}
+	else
+	{
+		lenData = PowervuCreateDataCw(seed, lenSeed, baseCw, val, seedEcmCw, data);
+		PowervuCreateHash(data, lenData, hash, hashMode);
+
+		for (i = 0; i < 8; i++)
+		{
+			cw[i] = hash[i];
+		}
+	}
+
+	if (modeDesCsa == 0) // DES - Fix Parity Bits
+	{
+		for (i = 0; i < 8; i++)
+		{
+			cw[i] = tableFixParity[cw[i]];
+		}
+	}
+	else if (modeDesCsa == 1) // CSA - Fix Checksums
+	{
+		cw[3] = cw[0] + cw[1] + cw[2];
+		cw[7] = cw[4] + cw[5] + cw[6];
+	}
+}
+
+static inline int8_t PowervuGetEcmKey(uint8_t *key, uint16_t srvid, uint8_t keyIndex, uint32_t keyRef)
+{
+	return FindKey('P', srvid, 0xFFFF0000, keyIndex == 1 ? "01" : "00", key, 7, 0, keyRef, 0, NULL);
+}
+
+static inline int8_t PowervuGetEmmKey(uint8_t *key, char *uniqueAddress, uint32_t keyRef, uint32_t *groupId)
+{
+	return FindKey('P', 0, 0xFFFFFFFF, uniqueAddress, key, 7, 0, keyRef, 0, groupId);
+}
+
+static const uint8_t PowerVu_A0_S_1[16] = { 0x33, 0xA4, 0x44, 0x3C, 0xCA, 0x2E, 0x75, 0x7B,
+											0xBC, 0xE6, 0xE5, 0x35, 0xA0, 0x55, 0xC9, 0xA2 };
+
+static const uint8_t PowerVu_A0_S_2[16] = { 0x5A, 0xB0, 0x2C, 0xBC, 0xDA, 0x32, 0xE6, 0x92,
+											0x40, 0x53, 0x6E, 0xF9, 0x69, 0x11, 0x1E, 0xFB };
+
+static const uint8_t PowerVu_A0_S_3[16] = { 0x4E, 0x18, 0x9B, 0x19, 0x79, 0xFB, 0x01, 0xFA,
+											0xE3, 0xE1, 0x28, 0x3D, 0x32, 0xE4, 0x92, 0xEA };
+
+static const uint8_t PowerVu_A0_S_4[16] = { 0x05, 0x6F, 0x37, 0x66, 0x35, 0xE1, 0x58, 0xD0,
+											0xB4, 0x6A, 0x97, 0xAE, 0xD8, 0x91, 0x27, 0x56 };
+
+static const uint8_t PowerVu_A0_S_5[16] = { 0x7B, 0x26, 0xAD, 0x34, 0x3D, 0x77, 0x39, 0x51,
+											0xE0, 0xE0, 0x48, 0x8C, 0x39, 0xF5, 0xE8, 0x47 };
+
+static const uint8_t PowerVu_A0_S_6[16] = { 0x74, 0xFA, 0x4D, 0x79, 0x42, 0x39, 0xD1, 0xA4,
+											0x99, 0xA3, 0x97, 0x07, 0xDF, 0x14, 0x3A, 0xC4 };
+
+static const uint8_t PowerVu_A0_S_7[16] = { 0xC6, 0x1E, 0x3C, 0x24, 0x11, 0x08, 0x5D, 0x6A,
+											0xEB, 0x97, 0xB9, 0x25, 0xA7, 0xFA, 0xE9, 0x1A };
+
+static const uint8_t PowerVu_A0_S_8[16] = { 0x9A, 0xAD, 0x72, 0xD7, 0x7C, 0x68, 0x3B, 0x55,
+											0x1D, 0x4A, 0xA2, 0xB0, 0x38, 0xB9, 0x56, 0xD0 };
+
+static const uint8_t PowerVu_A0_S_9[32] = { 0x61, 0xDA, 0x5F, 0xB7, 0xEB, 0xC6, 0x3F, 0x6C,
+											0x09, 0xF3, 0x64, 0x38, 0x33, 0x08, 0xAA, 0x15,
+											0xCC, 0xEF, 0x22, 0x64, 0x01, 0x2C, 0x12, 0xDE,
+											0xF4, 0x6E, 0x3C, 0xCD, 0x1A, 0x64, 0x63, 0x7C };
+
+static const uint8_t PowerVu_00_S_1[16] = { 0x97, 0x13, 0xEB, 0x6B, 0x04, 0x5E, 0x60, 0x3A,
+											0xD9, 0xCC, 0x91, 0xC2, 0x5A, 0xFD, 0xBA, 0x0C };
+
+static const uint8_t PowerVu_00_S_2[16] = { 0x61, 0x3C, 0x03, 0xB0, 0xB5, 0x6F, 0xF8, 0x01,
+											0xED, 0xE0, 0xE5, 0xF3, 0x78, 0x0F, 0x0A, 0x73 };
+
+static const uint8_t PowerVu_00_S_3[16] = { 0xFD, 0xDF, 0xD2, 0x97, 0x06, 0x14, 0x91, 0xB5,
+											0x36, 0xAD, 0xBC, 0xE1, 0xB3, 0x00, 0x66, 0x41 };
+
+static const uint8_t PowerVu_00_S_4[16] = { 0x8B, 0xD9, 0x18, 0x0A, 0xED, 0xEE, 0x61, 0x34,
+											0x1A, 0x79, 0x80, 0x8C, 0x1E, 0x7F, 0xC5, 0x9F };
+
+static const uint8_t PowerVu_00_S_5[16] = { 0xB0, 0xA1, 0xF2, 0xB8, 0xEA, 0x72, 0xDD, 0xD3,
+											0x30, 0x65, 0x2B, 0x1E, 0xE9, 0xE1, 0x45, 0x29 };
+
+static const uint8_t PowerVu_00_S_6[16] = { 0x5D, 0xCA, 0x53, 0x75, 0xB2, 0x24, 0xCE, 0xAF,
+											0x21, 0x54, 0x9E, 0xBE, 0x02, 0xA9, 0x4C, 0x5D };
+
+static const uint8_t PowerVu_00_S_7[16] = { 0x42, 0x66, 0x72, 0x83, 0x1B, 0x2D, 0x22, 0xC9,
+											0xF8, 0x4D, 0xBA, 0xCD, 0xBB, 0x20, 0xBD, 0x6B };
+
+static const uint8_t PowerVu_00_S_8[16] = { 0xC4, 0x0C, 0x6B, 0xD3, 0x6D, 0x94, 0x7E, 0x53,
+											0xCE, 0x96, 0xAC, 0x40, 0x2C, 0x7A, 0xD3, 0xA9 };
+
+static const uint8_t PowerVu_00_S_9[32] = { 0x31, 0x82, 0x4F, 0x9B, 0xCB, 0x6F, 0x9D, 0xB7,
+											0xAE, 0x68, 0x0B, 0xA0, 0x93, 0x15, 0x32, 0xE2,
+											0xED, 0xE9, 0x47, 0x29, 0xC2, 0xA8, 0x92, 0xEF,
+											0xBA, 0x27, 0x22, 0x57, 0x76, 0x54, 0xC0, 0x59 };
+
+static uint8_t PowervuSbox(uint8_t *input, uint8_t mode)
+{
+	uint8_t s_index, bit, last_index, last_bit;
+	uint8_t const *Sbox1, *Sbox2, *Sbox3, *Sbox4, *Sbox5, *Sbox6, *Sbox7, *Sbox8, *Sbox9;
+
+	if (mode)
+	{
+		Sbox1 = PowerVu_A0_S_1;
+		Sbox2 = PowerVu_A0_S_2;
+		Sbox3 = PowerVu_A0_S_3;
+		Sbox4 = PowerVu_A0_S_4;
+		Sbox5 = PowerVu_A0_S_5;
+		Sbox6 = PowerVu_A0_S_6;
+		Sbox7 = PowerVu_A0_S_7;
+		Sbox8 = PowerVu_A0_S_8;
+		Sbox9 = PowerVu_A0_S_9;
+	}
+	else
+	{
+		Sbox1 = PowerVu_00_S_1;
+		Sbox2 = PowerVu_00_S_2;
+		Sbox3 = PowerVu_00_S_3;
+		Sbox4 = PowerVu_00_S_4;
+		Sbox5 = PowerVu_00_S_5;
+		Sbox6 = PowerVu_00_S_6;
+		Sbox7 = PowerVu_00_S_7;
+		Sbox8 = PowerVu_00_S_8;
+		Sbox9 = PowerVu_00_S_9;
+	}
+
+	bit = (GetBit(input[2], 0) << 2) | (GetBit(input[3], 4) << 1) | (GetBit(input[5], 3));
+	s_index = (GetBit(input[0], 0) << 3) | (GetBit(input[2], 6) << 2) | (GetBit(input[2], 4) << 1) | (GetBit(input[5], 7));
+	last_bit = GetBit(Sbox1[s_index], 7 - bit);
+
+	bit = (GetBit(input[5], 0) << 2) | (GetBit(input[4], 0) << 1) | (GetBit(input[6], 2));
+	s_index = (GetBit(input[2], 1) << 3) | (GetBit(input[2], 2) << 2) | (GetBit(input[5], 5) << 1) | (GetBit(input[5], 1));
+	last_bit = last_bit | (GetBit(Sbox2[s_index], 7 - bit) << 1);
+
+	bit = (GetBit(input[6], 0) << 2) | (GetBit(input[1], 7) << 1) | (GetBit(input[6], 7));
+	s_index = (GetBit(input[1], 3) << 3) | (GetBit(input[3], 7) << 2) | (GetBit(input[1], 5) << 1) | (GetBit(input[5], 2));
+	last_bit = last_bit | (GetBit(Sbox3[s_index], 7 - bit) << 2);
+
+	bit = (GetBit(input[1], 0) << 2) | (GetBit(input[2], 7) << 1) | (GetBit(input[2], 5));
+	s_index = (GetBit(input[6], 3) << 3) | (GetBit(input[6], 4) << 2) | (GetBit(input[6], 6) << 1) | (GetBit(input[3], 5));
+	last_index = GetBit(Sbox4[s_index], 7 - bit);
+
+	bit = (GetBit(input[3], 3) << 2) | (GetBit(input[4], 6) << 1) | (GetBit(input[3], 2));
+	s_index = (GetBit(input[3], 1) << 3) | (GetBit(input[4], 5) << 2) | (GetBit(input[3], 0) << 1) | (GetBit(input[4], 7));
+	last_index = last_index | (GetBit(Sbox5[s_index], 7 - bit) << 1);
+
+	bit = (GetBit(input[5], 4) << 2) | (GetBit(input[4], 4) << 1) | (GetBit(input[1], 2));
+	s_index = (GetBit(input[2], 3) << 3) | (GetBit(input[6], 5) << 2) | (GetBit(input[1], 4) << 1) | (GetBit(input[4], 1));
+	last_index = last_index | (GetBit(Sbox6[s_index], 7 - bit) << 2);
+
+	bit = (GetBit(input[0], 6) << 2) | (GetBit(input[0], 7) << 1) | (GetBit(input[0], 4));
+	s_index = (GetBit(input[0], 5) << 3) | (GetBit(input[0], 3) << 2) | (GetBit(input[0], 1) << 1) | (GetBit(input[0], 2));
+	last_index = last_index | (GetBit(Sbox7[s_index], 7 - bit) << 3);
+
+	bit = (GetBit(input[4], 2) << 2) | (GetBit(input[4], 3) << 1) | (GetBit(input[1], 1));
+	s_index = (GetBit(input[1], 6) << 3) | (GetBit(input[6], 1) << 2) | (GetBit(input[5], 6) << 1) | (GetBit(input[3], 6));
+	last_index = last_index | (GetBit(Sbox8[s_index], 7 - bit) << 4);
+
+	return (GetBit(Sbox9[last_index & 0x1F], 7 - last_bit) & 1) ? 1 : 0;
+}
+
+static void PowervuDecrypt(uint8_t *data, uint32_t length, uint8_t *key, uint8_t sbox)
+{
+	uint32_t i;
+	int32_t j, k;
+	uint8_t curByte, tmpBit;
+
+	for (i = 0; i < length; i++)
+	{
+		curByte = data[i];
+
+		for (j = 7; j >= 0; j--)
+		{
+			data[i] = SetBit(data[i], j, (GetBit(curByte, j) ^ PowervuSbox(key, sbox)) ^ GetBit(key[0], 7));
+			tmpBit = GetBit(data[i], j) ^ (GetBit(key[6], 0));
+
+			if (tmpBit)
+			{
+				key[3] ^= 0x10;
+			}
+
+			for (k = 6; k > 0; k--)
+			{
+				key[k] = (key[k] >> 1) | (key[k - 1] << 7);
+			}
+
+			key[0] = (key[0] >> 1);
+			key[0] = SetBit(key[0], 7, tmpBit);
+		}
+	}
+}
+
+static void ExpandDesKey(unsigned char *key)
+{
+	uint8_t i, j, parity;
+	uint8_t tmpKey[7];
+
+	memcpy(tmpKey, key, 7);
+
+	key[0] = (tmpKey[0] & 0xFE);
+	key[1] = ((tmpKey[0] << 7) | ((tmpKey[1] >> 1) & 0xFE));
+	key[2] = ((tmpKey[1] << 6) | ((tmpKey[2] >> 2) & 0xFE));
+	key[3] = ((tmpKey[2] << 5) | ((tmpKey[3] >> 3) & 0xFE));
+	key[4] = ((tmpKey[3] << 4) | ((tmpKey[4] >> 4) & 0xFE));
+	key[5] = ((tmpKey[4] << 3) | ((tmpKey[5] >> 5) & 0xFE));
+	key[6] = ((tmpKey[5] << 2) | ((tmpKey[6] >> 6) & 0xFE));
+	key[7] = (tmpKey[6] << 1);
+
+	for (i = 0; i < 8; i++)
+	{
+		parity = 1;
+		for (j = 1; j < 8; j++)
+		{
+			if ((key[i] >> j) & 0x1)
+			{
+				parity = ~parity & 0x01;
+			}
+		}
+		key[i] |= parity;
+	}
+}
+
+static uint8_t PowervuGetConvcwIndex(uint8_t ecmTag)
+{
+	switch (ecmTag)
+	{
+		case PVU_CONVCW_VID_ECM:
+			return PVU_CW_VID;
+
+		case PVU_CONVCW_HSD_ECM:
+			return PVU_CW_HSD;
+
+		case PVU_CONVCW_A1_ECM:
+			return PVU_CW_A1;
+
+		case PVU_CONVCW_A2_ECM:
+			return PVU_CW_A2;
+
+		case PVU_CONVCW_A3_ECM:
+			return PVU_CW_A3;
+
+		case PVU_CONVCW_A4_ECM:
+			return PVU_CW_A4;
+
+		case PVU_CONVCW_UTL_ECM:
+			return PVU_CW_UTL;
+
+		case PVU_CONVCW_VBI_ECM:
+			return PVU_CW_VBI;
+
+		default:
+			return PVU_CW_VBI;
+	}
+}
+
+static uint16_t PowervuGetSeedIV(uint8_t seedType, uint8_t *ecm)
+{
+	switch (seedType)
+	{
+		case PVU_CW_VID:
+			return ((ecm[0x10] & 0x1F) << 3) | 0;
+		case PVU_CW_HSD:
+			return ((ecm[0x12] & 0x1F) << 3) | 2;
+		case PVU_CW_A1:
+			return ((ecm[0x11] & 0x3F) << 3) | 1;
+		case PVU_CW_A2:
+			return ((ecm[0x13] & 0x3F) << 3) | 1;
+		case PVU_CW_A3:
+			return ((ecm[0x19] & 0x3F) << 3) | 1;
+		case PVU_CW_A4:
+			return ((ecm[0x1A] & 0x3F) << 3) | 1;;
+		case PVU_CW_UTL:
+			return ((ecm[0x14] & 0x0F) << 3) | 4;
+		case PVU_CW_VBI:
+			return (((ecm[0x15] & 0xF8) >> 3) << 3) | 5;
+		default:
+			return 0;
+	}
+}
+
+static uint8_t PowervuExpandSeed(uint8_t seedType, uint8_t *seed)
+{
+	uint8_t seedLength = 0, i;
+
+	switch (seedType)
+	{
+		case PVU_CW_VID:
+		case PVU_CW_HSD:
+			seedLength = 4;
+			break;
+		case PVU_CW_A1:
+		case PVU_CW_A2:
+		case PVU_CW_A3:
+		case PVU_CW_A4:
+			seedLength = 3;
+			break;
+		case PVU_CW_UTL:
+		case PVU_CW_VBI:
+			seedLength = 2;
+			break;
+		default:
+			return seedLength;
+	}
+
+	for (i = seedLength; i < 7; i++)
+	{
+		seed[i] = seed[i % seedLength];
+	}
+
+	return seedLength;
+}
+
+static void PowervuCalculateSeed(uint8_t seedType, uint8_t *ecm, uint8_t *seedBase, uint8_t *key,
+									uint8_t *seed, uint8_t sbox)
+{
+	uint16_t tmpSeed;
+
+	tmpSeed = PowervuGetSeedIV(seedType, ecm + 23);
+
+	seed[0] = (tmpSeed >> 2) & 0xFF;
+	seed[1] = ((tmpSeed & 0x3) << 6) | (seedBase[0] >> 2);
+	seed[2] = (    seedBase[0] << 6) | (seedBase[1] >> 2);
+	seed[3] = (    seedBase[1] << 6) | (seedBase[2] >> 2);
+	seed[4] = (    seedBase[2] << 6) | (seedBase[3] >> 2);
+	seed[5] = (    seedBase[3] << 6);
+
+	PowervuDecrypt(seed, 6, key, sbox);
+
+	seed[0] = (seed[1] << 2) | (seed[2] >> 6);
+	seed[1] = (seed[2] << 2) | (seed[3] >> 6);
+	seed[2] = (seed[3] << 2) | (seed[4] >> 6);
+	seed[3] = (seed[4] << 2) | (seed[5] >> 6);
+}
+
+static void PowervuCalculateCw(uint8_t seedType, uint8_t *seed, uint8_t csaUsed, uint8_t *convolvedCw,
+								uint8_t *cw, uint8_t *baseCw, uint8_t *seedEcmCw, uint8_t hashModeCw,
+								uint8_t needsUnmasking, uint8_t xorMode, int modeCW, uint8_t* ecmBody)
+{
+	int32_t k;
+	uint8_t seedLength, val = 0;
+
+	seedLength = PowervuExpandSeed(seedType, seed);
+
+	if (needsUnmasking && (((modeCW >= 0x00) && (hashModeCw > 0) && (hashModeCw <= 0x27) &&
+		(hashModeCw != 0x0B) && (hashModeCw != 0x0C) && (hashModeCw != 0x0D) && (hashModeCw != 0x0E)) ||
+		(modeCW == 0x03) || (modeCW == 0x04)))
+	{
+		switch (seedType)
+		{
+			case PVU_CW_VID:
+				val = 0;
+				break;
+
+			case PVU_CW_A1:
+			case PVU_CW_A2:
+			case PVU_CW_A3:
+			case PVU_CW_A4:
+				val = 1;
+				break;
+
+			case PVU_CW_HSD:
+				val = 2;
+				break;
+
+			case PVU_CW_UTL:
+				val = 4;
+				break;
+
+			case PVU_CW_VBI:
+				val = 5;
+				break;
+		}
+
+		PowervuCreateCw(seed, seedLength, baseCw, val, seedEcmCw, cw, csaUsed, hashModeCw, modeCW, ecmBody);
+
+		if (csaUsed)
+		{
+			cw[0] = cw[0] ^ convolvedCw[0];
+			cw[1] = cw[1] ^ convolvedCw[1];
+			cw[2] = cw[2] ^ convolvedCw[2];
+			cw[3] = cw[3] ^ convolvedCw[3];
+			cw[4] = cw[4] ^ convolvedCw[4];
+			cw[5] = cw[5] ^ convolvedCw[5];
+			cw[6] = cw[6] ^ convolvedCw[6];
+			cw[7] = cw[7] ^ convolvedCw[7];
+
+			cw[3] = cw[0] + cw[1] + cw[2];
+			cw[7] = cw[4] + cw[5] + cw[6];
+		}
+	}
+	else
+	{
+		if (csaUsed)
+		{
+			for (k = 0; k < 7; k++)
+			{
+				seed[k] ^= baseCw[k];
+			}
+
+			cw[0] = seed[0] ^ convolvedCw[0];
+			cw[1] = seed[1] ^ convolvedCw[1];
+			cw[2] = seed[2] ^ convolvedCw[2];
+			cw[3] = seed[3] ^ convolvedCw[3];
+			cw[4] = seed[3] ^ convolvedCw[4];
+			cw[5] = seed[4] ^ convolvedCw[5];
+			cw[6] = seed[5] ^ convolvedCw[6];
+			cw[7] = seed[6] ^ convolvedCw[7];
+		}
+		else
+		{
+			if (xorMode == 0)
+			{
+				for (k = 0; k < 7; k++)
+				{
+					cw[k] = seed[k] ^ baseCw[k];
+				}
+			}
+
+			if (xorMode == 1)
+			{
+				for (k = 0; k < 3; k++)
+				{
+					cw[k] = seed[k] ^ baseCw[k];
+				}
+
+				for (k = 3; k < 7; k++)
+				{
+					cw[k] = baseCw[k];
+				}
+			}
+
+			ExpandDesKey(cw);
+		}
+	}
+}
+
+int8_t PowervuECM(uint8_t *ecm, uint8_t *dw, uint16_t srvid, emu_stream_client_key_data *cdata, EXTENDED_CW *cw_ex)
+{
+	uint32_t i, j, k;
+	uint32_t ecmCrc32, keyRef1, keyRef2;
+
+	uint16_t ecmLen = GetEcmLen(ecm);
+	uint16_t nanoLen, channelId, ecmSrvid;
+
+	uint8_t keyIndex, sbox, decrypt_ok, calculateAll, hashModeCw = 0, needsUnmasking, xorMode;
+	uint8_t nanoCmd, nanoChecksum, keyType, fixedKey, oddKey, bid, csaUsed, modeCW = 0, offsetBody;
+
+	uint8_t ecmKey[7], tmpEcmKey[7], seedBase[4], baseCw[7], seed[8][8], cw[8][8], convolvedCw[8][8];
+	uint8_t ecmPart1[14], ecmPart2[27], unmaskedEcm[ecmLen], seedEcmCw[16];
+
+	//char tmpBuffer1[512];
+	char tmpBuffer2[17];
+
+	emu_stream_cw_item *cw_item;
+	int8_t update_global_key = 0, ret = 1;
+	int8_t update_global_keys[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+
+	memset(update_global_keys, 0, sizeof(update_global_keys));
+
+	if (ecmLen < 7)
+	{
+		return EMU_NOT_SUPPORTED;
+	}
+
+	needsUnmasking = (ecm[3] & 0xF0) == 0x50;
+
+	//cs_log_dbg(D_ATR, "ecm1: %s", cs_hexdump(0, ecm, ecmLen, tmpBuffer1, sizeof(tmpBuffer1)));
+
+	if (needsUnmasking)
+	{
+		hashModeCw = PowervuUnmaskEcm(ecm, seedEcmCw, &modeCW);
+	}
+
+	//cs_log_dbg(D_ATR, "needsUnmasking=%d", needsUnmasking);
+	//cs_log_dbg(D_ATR, "ecm2: %s", cs_hexdump(0, ecm, ecmLen, tmpBuffer1, sizeof(tmpBuffer1)));
+
+	memcpy(unmaskedEcm, ecm, ecmLen);
+
+	ecmCrc32 = b2i(4, ecm + ecmLen - 4);
+
+	if (fletcher_crc32(ecm, ecmLen - 4) != ecmCrc32)
+	{
+		return EMU_CHECKSUM_ERROR;
+	}
+	ecmLen -= 4;
+
+	for (i = 0; i < 8; i++)
+	{
+		memset(convolvedCw[i], 0, 8);
+	}
+
+	for (i = 3; i + 3 < ecmLen; )
+	{
+		nanoLen = (((ecm[i] & 0x0F) << 8) | ecm[i + 1]);
+		i += 2;
+
+		if (nanoLen > 0)
+		{
+			nanoLen--;
+		}
+		nanoCmd = ecm[i++];
+
+		if (i + nanoLen > ecmLen)
+		{
+			return EMU_NOT_SUPPORTED;
+		}
+
+		switch (nanoCmd)
+		{
+			case 0x27:
+				if (nanoLen < 15)
+				{
+					break;
+				}
+
+				nanoChecksum = 0;
+				for (j = 4; j < 15; j++)
+				{
+					nanoChecksum += ecm[i + j];
+				}
+
+				if (nanoChecksum != 0)
+				{
+					break;
+				}
+
+				keyType = PowervuGetConvcwIndex(ecm[i + 4]);
+				memcpy(convolvedCw[keyType], &ecm[i + 6], 8);
+				break;
+
+			default:
+				break;
+		}
+
+		i += nanoLen;
+	}
+
+	for (i = 3; i + 3 < ecmLen; )
+	{
+		nanoLen = (((ecm[i] & 0x0F) << 8) | ecm[i + 1]);
+		i += 2;
+
+		if (nanoLen > 0)
+		{
+			nanoLen--;
+		}
+		nanoCmd = ecm[i++];
+
+		if (i + nanoLen > ecmLen)
+		{
+			return EMU_NOT_SUPPORTED;
+		}
+
+		switch (nanoCmd)
+		{
+			case 0x20:
+			{
+				if (nanoLen < 54)
+				{
+					break;
+				}
+
+				offsetBody = i + 4 + ecm[i + 3];
+				i += ecm[i + 3]; // Extra Data Length
+
+				csaUsed = GetBit(ecm[i + 7], 7);
+				fixedKey = !GetBit(ecm[i + 6], 5);
+				oddKey = GetBit(ecm[i + 6], 4);
+				xorMode = GetBit(ecm[i + 6], 0);
+				bid = (GetBit(ecm[i + 7], 1) << 1) | GetBit(ecm[i + 7], 0);
+				sbox = GetBit(ecm[i + 6], 3);
+
+				keyIndex = (fixedKey << 3) | (bid << 2) | oddKey;
+				channelId = b2i(2, ecm + i + 23);
+				ecmSrvid = (channelId >> 4) | ((channelId & 0xF) << 12);
+
+				decrypt_ok = 0;
+
+				memcpy(ecmPart1, ecm + i + 8, 14);
+				memcpy(ecmPart2, ecm + i + 27, 27);
+
+				keyRef1 = 0;
+				keyRef2 = 0;
+
+				cs_log_dbg(D_ATR, "csaUsed=%d, xorMode=%d, ecmSrvid=%04X, hashModeCw=%d, modeCW=%d",
+							csaUsed, xorMode, ecmSrvid, hashModeCw, modeCW);
+
+				do
+				{
+					if (!PowervuGetEcmKey(ecmKey, ecmSrvid, keyIndex, keyRef1++))
+					{
+						if (!PowervuGetEcmKey(ecmKey, channelId, keyIndex, keyRef2++))
+						{
+							cs_log("Key not found: P %04X %02X", ecmSrvid, keyIndex);
+							return EMU_KEY_NOT_FOUND;
+						}
+					}
+
+					PowervuDecrypt(ecm + i + 8, 14, ecmKey, sbox);
+
+					if ((ecm[i + 6] != ecm[i + 6 + 7]) || (ecm[i + 6 + 8] != ecm[i + 6 + 15]))
+					{
+						memcpy(ecm + i + 8, ecmPart1, 14);
+						continue;
+					}
+
+					memcpy(tmpEcmKey, ecmKey, 7);
+
+					PowervuDecrypt(ecm + i + 27, 27, ecmKey, sbox);
+
+					if ((ecm[i + 23] != ecm[i + 23 + 29]) || (ecm[i + 23 + 1] != ecm[i + 23 + 30]))
+					{
+						memcpy(ecm + i + 8, ecmPart1, 14);
+						memcpy(ecm + i + 27, ecmPart2, 27);
+						continue;
+					}
+
+					decrypt_ok = 1;
+				}
+				while (!decrypt_ok);
+
+				memcpy(seedBase, ecm + i + 6 + 2, 4);
+
+				if (cdata == NULL)
+				{
+					SAFE_MUTEX_LOCK(&emu_fixed_key_srvid_mutex);
+					for (j = 0; j < EMU_STREAM_SERVER_MAX_CONNECTIONS; j++)
+					{
+						if (!stream_server_has_ecm[j] && emu_stream_cur_srvid[j] == srvid)
+						{
+							update_global_key = 1;
+							update_global_keys[j] = 1;
+						}
+					}
+					SAFE_MUTEX_UNLOCK(&emu_fixed_key_srvid_mutex);
+				}
+
+				calculateAll = cdata != NULL || update_global_key || cw_ex != NULL;
+
+				if (calculateAll) // Calculate all seeds
+				{
+					for (j = 0; j < 8; j++)
+					{
+						memcpy(ecmKey, tmpEcmKey, 7);
+						PowervuCalculateSeed(j, ecm + i, seedBase, ecmKey, seed[j], sbox);
+					}
+				}
+				else // Calculate only video seed
+				{
+					memcpy(ecmKey, tmpEcmKey, 7);
+					PowervuCalculateSeed(PVU_CW_VID, ecm + i, seedBase, ecmKey, seed[PVU_CW_VID], sbox);
+				}
+
+				memcpy(baseCw, ecm + i + 6 + 8, 7);
+
+				if (calculateAll) // Calculate all CWs
+				{
+					for (j = 0; j < 8; j++)
+					{
+						PowervuCalculateCw(j, seed[j], csaUsed, convolvedCw[j], cw[j], baseCw, seedEcmCw,
+											hashModeCw, needsUnmasking, xorMode, modeCW, unmaskedEcm + offsetBody);
+
+						if (csaUsed)
+						{
+							for (k = 0; k < 8; k += 4)
+							{
+								cw[j][k + 3] = ((cw[j][k] + cw[j][k + 1] + cw[j][k + 2]) & 0xFF);
+							}
+						}
+
+						cs_log_dbg(D_ATR, "calculated cw %d: %s", j,
+										cs_hexdump(0, cw[j], 8, tmpBuffer2, sizeof(tmpBuffer2)));
+					}
+
+					//cs_log_dbg(D_ATR, "csaUsed=%d, cw: %s cdata=%x, cw_ex=%x",
+					//			csaUsed, cs_hexdump(3, cw[0], 8, tmpBuffer1, sizeof(tmpBuffer1)),
+					//			(unsigned int)cdata, (unsigned int)cw_ex);
+
+					if (update_global_key)
+					{
+						for (j = 0; j < EMU_STREAM_SERVER_MAX_CONNECTIONS; j++)
+						{
+							if (update_global_keys[j])
+							{
+								cw_item = (emu_stream_cw_item *)malloc(sizeof(emu_stream_cw_item));
+								if (cw_item != NULL)
+								{
+									cw_item->csa_used = csaUsed;
+									cw_item->is_even = ecm[0] == 0x80 ? 1 : 0;
+									cs_ftime(&cw_item->write_time);
+									add_ms_to_timeb(&cw_item->write_time, cfg.emu_stream_ecm_delay);
+									memcpy(cw_item->cw, cw, sizeof(cw));
+									ll_append(ll_emu_stream_delayed_keys[j], cw_item);
+								}
+							}
+						}
+					}
+
+					if (cdata != NULL)
+					{
+						for (j = 0; j < 8; j++)
+						{
+							if (csaUsed)
+							{
+								if (cdata->pvu_csa_ks[j] == NULL)
+								{
+									cdata->pvu_csa_ks[j] = get_key_struct();
+								}
+
+								if (ecm[0] == 0x80)
+								{
+									set_even_control_word(cdata->pvu_csa_ks[j], cw[j]);
+								}
+								else
+								{
+									set_odd_control_word(cdata->pvu_csa_ks[j], cw[j]);
+								}
+
+								cdata->pvu_csa_used = 1;
+							}
+							else
+							{
+								if (ecm[0] == 0x80)
+								{
+									des_set_key(cw[j], cdata->pvu_des_ks[j][0]);
+								}
+								else
+								{
+									des_set_key(cw[j], cdata->pvu_des_ks[j][1]);
+								}
+
+								cdata->pvu_csa_used = 0;
+							}
+						}
+					}
+
+					if (cw_ex != NULL)
+					{
+						cw_ex->mode = CW_MODE_MULTIPLE_CW;
+
+						if (csaUsed)
+						{
+							cw_ex->algo = CW_ALGO_CSA;
+							cw_ex->algo_mode = CW_ALGO_MODE_ECB;
+						}
+						else
+						{
+							cw_ex->algo = CW_ALGO_DES;
+							cw_ex->algo_mode = CW_ALGO_MODE_ECB;
+						}
+
+						for (j = 0; j < 4; j++)
+						{
+							memset(cw_ex->audio[j], 0, 16);
+
+							if (ecm[0] == 0x80)
+							{
+								memcpy(cw_ex->audio[j], cw[PVU_CW_A1 + j], 8);
+							}
+							else
+							{
+								memcpy(&cw_ex->audio[j][8], cw[PVU_CW_A1 + j], 8);
+							}
+						}
+
+						memset(cw_ex->data, 0, 16);
+
+						if (ecm[0] == 0x80)
+						{
+							memcpy(cw_ex->data, cw[PVU_CW_HSD], 8);
+						}
+						else
+						{
+							memcpy(&cw_ex->data[8], cw[PVU_CW_HSD], 8);
+						}
+					}
+				}
+				else // Calculate only video CW
+				{
+					PowervuCalculateCw(PVU_CW_VID, seed[PVU_CW_VID], csaUsed, convolvedCw[PVU_CW_VID],
+										cw[PVU_CW_VID], baseCw, seedEcmCw, hashModeCw, needsUnmasking,
+										xorMode, modeCW, unmaskedEcm + offsetBody);
+
+					if (csaUsed)
+					{
+						for (k = 0; k < 8; k += 4)
+						{
+							cw[PVU_CW_VID][k + 3] = ((cw[PVU_CW_VID][k] + cw[PVU_CW_VID][k + 1] + cw[PVU_CW_VID][k + 2]) & 0xFF);
+						}
+					}
+
+					cs_log_dbg(D_ATR, "calculated video only cw: %s",
+									cs_hexdump(0, cw[PVU_CW_VID], 8, tmpBuffer2, sizeof(tmpBuffer2)));
+				}
+
+				memset(dw, 0, 16);
+
+				if (ecm[0] == 0x80)
+				{
+					memcpy(dw, cw[PVU_CW_VID], 8);
+				}
+				else
+				{
+					memcpy(&dw[8], cw[PVU_CW_VID], 8);
+				}
+
+				return EMU_OK;
+			}
+
+			default:
+				break;
+		}
+
+		i += nanoLen;
+	}
+
+	return ret;
+}
+
+// PowerVu EMM EMU
+static void PowervuUnmaskEmm(uint8_t *emm)
+{
+	uint8_t hashModeEmm, data[30], mask[16];
+	uint32_t crc, i, l;
+
+	uint8_t sourcePos[] = { 0x03, 0x0C, 0x0D, 0x11, 0x15, 0x18, 0x1D, 0x1F, 0x25, 0x2A,
+							0x32, 0x35, 0x3A, 0x3B, 0x3E, 0x42, 0x47, 0x48, 0x53, 0x58,
+							0x5C, 0x61, 0x66, 0x69, 0x71, 0x72, 0x78, 0x7B, 0x81, 0x84 };
+
+	uint8_t destPos[] = { 0x02, 0x08, 0x0B, 0x0E, 0x13, 0x16, 0x1E, 0x23, 0x28, 0x2B,
+						  0x2F, 0x33, 0x38, 0x3C, 0x40, 0x44, 0x4A, 0x4D, 0x54, 0x57,
+						  0x5A, 0x63, 0x68, 0x6A, 0x70, 0x75, 0x76, 0x7D, 0x82, 0x85 };
+
+	// Create Mask for ECM decryption
+	PowervuCreateDataEcmEmm(emm, sourcePos, 19, 30, data);
+
+	hashModeEmm = emm[8] ^ PowervuCrc8Calc(data, 30);
+
+	PowervuCreateHash(data, 30, mask, hashModeEmm);
+
+	// Fix Header
+	emm[3] &= 0x0F;
+	emm[3] |= 0x10;
+	emm[8]  = 0x00;
+
+	// Unmask Body
+	for (i = 0; i < 30; i++)
+	{
+		emm[19 + destPos[i]] ^= mask[i & 0x0F];
+	}
+
+	// Fix CRC (optional)
+	l = (((emm[1] << 8) + emm[2]) & 0xFFF) + 3 - 4;
+	crc = fletcher_crc32(emm, l);
+
+	emm[l + 0] = crc >> 24;
+	emm[l + 1] = crc >> 16;
+	emm[l + 2] = crc >> 8;
+	emm[l + 3] = crc >> 0;
+}
+
+static int8_t PowervuUpdateEcmKeysByGroup(uint32_t groupId, uint8_t keyIndex, uint8_t *Key, uint32_t uniqueAddress)
+{
+	int8_t ret = 0;
+	uint8_t oldKey[7];
+	uint32_t foundProvider = 0, keyRef = 0;
+	char indexStr[3], uaInfo[13];
+
+	snprintf(indexStr, 3, "%02X", keyIndex);
+	snprintf(uaInfo, 13, "UA: %08X", uniqueAddress);
+
+	SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+	while (FindKey('P', groupId << 16 & 0xFFFF0000, 0x0000FFFF, indexStr, oldKey, 7, 0, keyRef, 0, &foundProvider))
+	{
+		keyRef++;
+
+		if (memcmp(oldKey, Key, 7) == 0) // New ECM key already in the db
+		{
+			continue;
+		}
+
+		if (SetKey('P', foundProvider, indexStr, Key, 7, 1, uaInfo, NULL))
+		{
+			ret = 1;
+		}
+	}
+	SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+
+	return ret;
+}
+
+int8_t PowervuEMM(uint8_t *emm, uint32_t *keysAdded)
+{
+	uint8_t emmInfo, emmType, decryptOk = 0;
+	uint8_t emmKey[7], tmpEmmKey[7], tmp[26];
+	uint16_t emmLen = GetEcmLen(emm);
+	uint32_t i, uniqueAddress, groupId, keyRef = 0;
+	//uint32_t emmCrc32;
+	char keyName[EMU_MAX_CHAR_KEYNAME], keyValue[16];
+
+	if (emmLen < 50)
+	{
+		return EMU_NOT_SUPPORTED;
+	}
+
+	// Check if unmasking is needed
+	if ((emm[3] & 0xF0) == 0x50)
+	{
+		PowervuUnmaskEmm(emm);
+	}
+
+	// looks like checksum does not work for all EMMs
+	//emmCrc32 = b2i(4, emm+emmLen-4);
+	//
+	//if(fletcher_crc32(emm, emmLen-4) != emmCrc32)
+	//{
+	//	return EMU_CHECKSUM_ERROR;
+	//}
+	emmLen -= 4;
+
+	uniqueAddress = b2i(4, emm+12);
+	snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%.8X", uniqueAddress);
+
+	do
+	{
+		if (!PowervuGetEmmKey(emmKey, keyName, keyRef++, &groupId))
+		{
+			cs_log_dbg(D_TRACE, "EMM key for UA %s is missing", keyName);
+			return EMU_KEY_NOT_FOUND;
+		}
+
+		for (i = 19; i + 27 <= emmLen; i += 27)
+		{
+			emmInfo = emm[i];
+
+			if (!GetBit(emmInfo, 7))
+			{
+				continue;
+			}
+
+			//keyNb = emm[i] & 0x0F;
+
+			memcpy(tmp, emm + i + 1, 26);
+			memcpy(tmpEmmKey, emmKey, 7);
+			PowervuDecrypt(emm + i + 1, 26, tmpEmmKey, 0);
+
+			if ((emm[13] != emm[i + 24]) || (emm[14] != emm[i + 25]) || (emm[15] != emm[i + 26]))
+			{
+				memcpy(emm + i + 1, tmp, 26);
+				memcpy(tmpEmmKey, emmKey, 7);
+				PowervuDecrypt(emm + i + 1, 26, tmpEmmKey, 1);
+
+				if ((emm[13] != emm[i + 24]) || (emm[14] != emm[i + 25]) || (emm[15] != emm[i + 26]))
+				{
+					memcpy(emm + i + 1, tmp, 26);
+					memcpy(tmpEmmKey, emmKey, 7);
+					continue;
+				}
+			}
+
+			decryptOk = 1;
+
+			emmType = emm[i + 2] & 0x7F;
+
+			if (emmType > 1)
+			{
+				continue;
+			}
+
+			if (emm[i + 3] == 0 && emm[i + 4] == 0)
+			{
+				cs_hexdump(0, &emm[i + 3], 7, keyValue, sizeof(keyValue));
+				cs_log("Key found in EMM: P %04X**** %02X %s -> REJECTED (looks invalid) UA: %08X",
+						groupId, emmType, keyValue, uniqueAddress);
+				continue;
+			}
+
+			PowervuUpdateEcmKeysByGroup(groupId, emmType, &emm[i + 3], uniqueAddress);
+
+			(*keysAdded)++;
+			cs_hexdump(0, &emm[i + 3], 7, keyValue, sizeof(keyValue));
+			cs_log("Key found in EMM: P %04X**** %02X %s ; UA: %08X", groupId, emmType, keyValue, uniqueAddress);
+		}
+
+	} while (!decryptOk);
+
+	return EMU_OK;
+}
+
+int8_t PowervuGetHexserials(uint16_t srvid, uint8_t hexserials[][4], uint32_t maxCount, uint32_t *count)
+{
+	//srvid == 0xFFFF -> get all
+
+	int8_t alreadyAdded;
+	uint8_t tmp[4];
+	uint32_t i, j, k, groupid, length;
+	KeyDataContainer *KeyDB;
+
+	KeyDB = GetKeyContainer('P');
+	if (KeyDB == NULL)
+		{ return 0; }
+
+	(*count) = 0;
+
+	for (i = 0; i < KeyDB->keyCount && (*count) < maxCount; i++)
+	{
+		if (KeyDB->EmuKeys[i].provider <= 0x0000FFFF) // skip au keys
+			{ continue; }
+
+		if (srvid != 0xFFFF && (KeyDB->EmuKeys[i].provider & 0x0000FFFF) != srvid)
+			{ continue; }
+
+		groupid = KeyDB->EmuKeys[i].provider >> 16;
+
+		for (j = 0; j < KeyDB->keyCount && (*count) < maxCount; j++)
+		{
+			if (KeyDB->EmuKeys[j].provider != groupid) // search au key with groupip
+				{ continue; }
+
+			length = strlen(KeyDB->EmuKeys[j].keyName);
+
+			if (length < 3)
+				{ continue; }
+
+			if (length > 8)
+				{ length = 8; }
+
+			memset(tmp, 0, 4);
+			CharToBin(tmp + (4 - (length / 2)), KeyDB->EmuKeys[j].keyName, length);
+
+			for (k = 0, alreadyAdded = 0; k < *count; k++)
+			{
+				if (!memcmp(hexserials[k], tmp, 4))
+				{
+					alreadyAdded = 1;
+					break;
+				}
+			}
+
+			if (!alreadyAdded)
+			{
+				memcpy(hexserials[*count], tmp, 4);
+				(*count)++;
+			}
+		}
+	}
+
+	return 1;
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-powervu.h b/module-emulator-powervu.h
new file mode 100644
index 0000000..f41e42c
--- /dev/null
+++ b/module-emulator-powervu.h
@@ -0,0 +1,47 @@
+#ifndef MODULE_EMULATOR_POWERVU_H
+#define MODULE_EMULATOR_POWERVU_H
+
+#ifdef WITH_EMU
+
+#define PVU_CW_VID	0	// VIDeo
+#define PVU_CW_HSD	1	// High Speed Data
+#define PVU_CW_A1	2	// Audio 1
+#define PVU_CW_A2	3	// Audio 2
+#define PVU_CW_A3	4	// Audio 3
+#define PVU_CW_A4	5	// Audio 4
+#define PVU_CW_UTL	6	// UTiLity
+#define PVU_CW_VBI	7	// Vertical Blanking Interval
+
+#define PVU_CONVCW_VID_ECM	0x80	// VIDeo
+#define PVU_CONVCW_HSD_ECM	0x40	// High Speed Data
+#define PVU_CONVCW_A1_ECM	0x20	// Audio 1
+#define PVU_CONVCW_A2_ECM	0x10	// Audio 2
+#define PVU_CONVCW_A3_ECM	0x08	// Audio 3
+#define PVU_CONVCW_A4_ECM	0x04	// Audio 4
+#define PVU_CONVCW_UTL_ECM	0x02	// UTiLity
+#define PVU_CONVCW_VBI_ECM	0x01	// Vertical Blanking Interval
+
+int8_t PowervuECM(uint8_t *ecm, uint8_t *dw, uint16_t srvid, emu_stream_client_key_data *cdata, EXTENDED_CW* cw_ex);
+int8_t PowervuEMM(uint8_t *emm, uint32_t *keysAdded);
+
+/*
+ * This function searches for EMM keys and sends their Unique Address (UA) back to OSCam as
+ * EMM filter. The EMM keys are picked from all group id's that have ECM keys for the srvid
+ * specified as input. If there is a large ammount of EMM keys for a given group, only the
+ * first "maxCount" UA's are sent as EMM filters. The rest are not used at all.
+ *
+ * In the rare case where two or more EMM keys with the same UA belong to different groups,
+ * and these groups also have ECM keys for the srvid in request, there is a chance the ECM
+ * keys in the "wrong" group to be updated. This is because the EMM algorithm has no way of
+ * knowing in which group the service id belongs to. A workaround for this designing flaw
+ * is to make sure there are no EMM keys with the same UA between different groups.
+ *
+ * Hexserials must be of type "uint8_t hexserials[maxCount][4]". If srvid is equal to 0xFFFF
+ * all serials are returned (no service id filtering is done). Return value is 0 on error,
+ * 1 on success.
+*/
+int8_t PowervuGetHexserials(uint16_t srvid, uint8_t hexserials[][4], uint32_t maxCount, uint32_t *count);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_POWERVU_H
diff --git a/module-emulator-streamserver.c b/module-emulator-streamserver.c
new file mode 100644
index 0000000..b18219c
--- /dev/null
+++ b/module-emulator-streamserver.c
@@ -0,0 +1,1476 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "cscrypt/des.h"
+#include "ffdecsa/ffdecsa.h"
+#include "module-emulator-osemu.h"
+#include "module-emulator-streamserver.h"
+#include "module-emulator-powervu.h"
+#include "oscam-config.h"
+#include "oscam-net.h"
+#include "oscam-string.h"
+#include "oscam-time.h"
+#include "oscam-chk.h"
+
+extern int32_t exit_oscam;
+
+typedef struct
+{
+	int32_t connfd;
+	int32_t connid;
+} emu_stream_client_conn_data;
+
+int8_t stream_server_thread_init = 0;
+char emu_stream_source_host[256] = {"127.0.0.1"};
+int32_t emu_stream_source_port = 8001;
+char *emu_stream_source_auth = NULL;
+int32_t emu_stream_relay_port = 17999;
+int8_t emu_stream_emm_enabled = 0;
+uint32_t cluster_size = 50;
+
+static uint8_t emu_stream_server_mutex_init = 0;
+static pthread_mutex_t emu_stream_server_mutex;
+static int32_t glistenfd, gconncount = 0, gconnfd[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+
+pthread_mutex_t emu_fixed_key_srvid_mutex;
+uint16_t emu_stream_cur_srvid[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+int8_t stream_server_has_ecm[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+
+pthread_mutex_t emu_fixed_key_data_mutex[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+emu_stream_client_key_data emu_fixed_key_data[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+LLIST *ll_emu_stream_delayed_keys[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+
+static void SearchTsPackets(uint8_t *buf, uint32_t bufLength, uint16_t *packetSize, uint16_t *startOffset)
+{
+	uint32_t i;
+
+	(*packetSize) = 0;
+	(*startOffset) = 0;
+
+	for (i = 0; i < bufLength; i++)
+	{
+		if (buf[i] == 0x47)
+		{
+			// if three packets align, probably safe to assume correct size
+			if ((buf[i + 188] == 0x47) & (buf[i + 376] == 0x47))
+			{
+				(*packetSize) = 188;
+				(*startOffset) = i;
+				return;
+			}
+			else if ((buf[i + 204] == 0x47) & (buf[i + 408] == 0x47))
+			{
+				(*packetSize) = 204;
+				(*startOffset) = i;
+				return;
+			}
+			else if ((buf[i + 208] == 0x47) & (buf[i + 416] == 0x47))
+			{
+				(*packetSize) = 208;
+				(*startOffset) = i;
+				return;
+			}
+		}
+	}
+}
+
+typedef void (*ts_data_callback)(emu_stream_client_data *cdata);
+
+static void ParseTsData(uint8_t table_id, uint8_t table_mask, uint8_t min_table_length, int8_t *flag,
+						uint8_t *data, uint16_t data_length, uint16_t *data_pos, int8_t payloadStart,
+						uint8_t *buf, int32_t len, ts_data_callback func, emu_stream_client_data *cdata)
+{
+	int8_t found_start = 0;
+	int32_t free_data_length, copySize, i;
+	uint16_t section_length, offset = 0;
+
+	if (len < 1)
+		{ return; }
+
+	if (*flag == 0 && !payloadStart)
+		{ return; }
+
+	if (*flag == 0)
+	{
+		*data_pos = 0;
+		offset = 1 + buf[0];
+	}
+	else if (payloadStart)
+	{
+		offset = 1;
+	}
+
+	if (len - offset < 1)
+		{ return; }
+
+	free_data_length = data_length - *data_pos;
+	copySize = (len - offset) > free_data_length ? free_data_length : (len - offset);
+
+	memcpy(data + (*data_pos), buf + offset, copySize);
+	(*data_pos) += copySize;
+
+	found_start = 0;
+	for (i = 0; i < *data_pos; i++)
+	{
+		if ((data[i] & table_mask) == table_id)
+		{
+			if (i != 0)
+			{
+				if ((*data_pos) - i > i)
+				{
+					memmove(data, &data[i], (*data_pos) - i);
+				}
+				else
+				{
+					memcpy(data, &data[i], (*data_pos) - i);
+				}
+
+				*data_pos -= i;
+			}
+			found_start = 1;
+			break;
+		}
+	}
+
+	if (!found_start)
+	{
+		*flag = 0;
+		return;
+	}
+
+	*flag = 2;
+
+	if (*data_pos < 3)
+		{ return; }
+
+	section_length = SCT_LEN(data);
+
+	if (section_length > data_length || section_length < min_table_length)
+	{
+		*flag = 0;
+		return;
+	}
+
+	if ((*data_pos) < section_length)
+		{ return; }
+
+	func(cdata);
+
+	found_start = 0;
+	for (i = section_length; i < *data_pos; i++)
+	{
+		if ((data[i] & table_mask) == table_id)
+		{
+			if ((*data_pos) - i > i)
+			{
+				memmove(data, &data[i], (*data_pos) - i);
+			}
+			else
+			{
+				memcpy(data, &data[i], (*data_pos) - i);
+			}
+
+			*data_pos -= i;
+			found_start = 1;
+			break;
+		}
+	}
+	if (!found_start)
+		{ *data_pos = 0; }
+
+	*flag = 1;
+}
+
+static void ParsePatData(emu_stream_client_data *cdata)
+{
+	int32_t i;
+	uint8_t *data = cdata->pat_data;
+	uint16_t srvid, section_length = SCT_LEN(data);
+
+	for (i = 8; i + 7 < section_length; i += 4)
+	{
+		srvid = b2i(2, data + i);
+
+		if (srvid == 0)
+			{ continue; }
+
+		if (cdata->srvid == srvid)
+		{
+			cdata->pmt_pid = b2i(2, data + i + 2) & 0x1FFF;
+			cs_log_dbg(D_READER, "Stream %i found pmt pid: 0x%04X (%i)",
+						cdata->connid, cdata->pmt_pid, cdata->pmt_pid);
+			break;
+		}
+	}
+}
+
+static void ParsePmtData(emu_stream_client_data *cdata)
+{
+	int32_t i;
+	uint8_t *data = cdata->pmt_data;
+	uint8_t descriptor_tag = 0, descriptor_length = 0, stream_type;
+	uint16_t program_info_length = 0, es_info_length = 0, elementary_pid, caid;
+	uint16_t section_length = SCT_LEN(data);
+
+	cdata->pcr_pid = b2i(2, data + 8) & 0x1FFF;
+	if (cdata->pcr_pid != 0x1FFF)
+	{
+		cs_log_dbg(D_READER, "Stream %i found pcr pid: 0x%04X (%i)",
+					cdata->connid, cdata->pcr_pid, cdata->pcr_pid);
+	}
+
+	program_info_length = b2i(2, data + 10) & 0xFFF;
+
+	if (12 + program_info_length >= section_length)
+		{ return; }
+
+	for (i = 12; i + 1 < 12 + program_info_length; i += descriptor_length + 2)
+	{
+		descriptor_tag = data[i];
+		descriptor_length = data[i + 1];
+
+		if (descriptor_length < 1)
+			{ break; }
+
+		if (i + 1 + descriptor_length >= 12 + program_info_length)
+			{ break; }
+
+		if (descriptor_tag == 0x09 && descriptor_length >= 4)
+		{
+			caid = b2i(2, data + i + 2);
+
+			if (caid_is_powervu(caid)) // add all supported caids here
+			{
+				if (cdata->caid == NO_CAID_VALUE) { cdata->caid = caid; }
+				cdata->ecm_pid = b2i(2, data + i + 4) & 0x1FFF;
+				cs_log_dbg(D_READER, "Stream %i found ecm pid: 0x%04X (%i)",
+							cdata->connid, cdata->ecm_pid, cdata->ecm_pid);
+				break;
+			}
+		}
+	}
+
+	for (i = 12 + program_info_length; i + 4 < section_length; i += 5 + es_info_length)
+	{
+		stream_type = data[i];
+		elementary_pid = b2i(2, data + i + 1) & 0x1FFF;
+		es_info_length = b2i(2, data + i + 3) & 0xFFF;
+
+		switch (stream_type)
+		{
+			case 0x01: // MPEG-1 video
+			case 0x02: // MPEG-1 (constrained parameter), MPEG-2 video
+			case 0x10: // MPEG-4 video
+			case 0x1B: // AVC video
+			case 0x20: // MVC video
+			case 0x24: // HEVC video
+			case 0x25: // HEVC video
+			case 0x42: // Chinese video
+			case 0x80: // DigiCipher 2 video
+			case 0xD1: // Dirac video
+			case 0xEA: // VC-1 video
+			{
+				cdata->video_pid = elementary_pid;
+				cs_log_dbg(D_READER, "Stream %i found video pid: 0x%04X (%i)",
+							cdata->connid, elementary_pid, elementary_pid);
+				break;
+			}
+
+			case 0x03: // MPEG-1 part 3 audio (MP1, MP2, MP3)
+			case 0x04: // MPEG-2 part 3 audio (MP1, MP2, MP3)
+			case 0x06: // AC-3, Enhanced AC-3, AC-4, DTS, DTS-HD and DTS-UHD audio (DVB)
+			case 0x0F: // MPEG-2 part 7 audio (AAC)
+			case 0x11: // MPEG-4 part 3 audio (AAC, HE AAC and AAC v2)
+			case 0x1C: // MPEG-4 part 3 audio (DST, ALS, SLS)
+			case 0x2D: // MPEG-H part 3 3D audio (main stream)
+			case 0x2E: // MPEG-H part 3 3D audio (auxiliary stream)
+			case 0x81: // AC-3 audio (ATSC)
+			case 0x87: // Enhanced AC-3 audio (ATSC)
+			//case 0x88: // DTS-HD audio (ATSC 2.0) /* fixme: has ATSC 2.0 ever been used? */
+			//case 0x??: // AC-4 audio (ATSC 3.0) /* fixme: add the actual value when it gets published */
+			//case 0x??: // MPEG-H part 3 3D audio (ATSC 3.0) /* fixme: add the actual value when it gets published */
+			{
+				if (cdata->audio_pid_count >= EMU_STREAM_MAX_AUDIO_SUB_TRACKS)
+					{ continue; }
+
+				cdata->audio_pids[cdata->audio_pid_count] = elementary_pid;
+				cdata->audio_pid_count++;
+				cs_log_dbg(D_READER, "Stream %i found audio pid: 0x%04X (%i)",
+							cdata->connid, elementary_pid, elementary_pid);
+				break;
+			}
+		}
+	}
+}
+
+static void ParseCatData(emu_stream_client_data *cdata)
+{
+	uint8_t *data = cdata->cat_data;
+	uint32_t i;
+
+	for (i = 8; i < (b2i(2, data + 1) & 0xFFF) - 1; i += data[i + 1] + 2)
+	{
+		if (data[i] != 0x09)
+			{ continue; }
+
+		uint16_t caid = b2i(2, data + i + 2);
+
+		if (caid_is_powervu(caid)) // add all supported caids here
+		{
+			if (cdata->caid == NO_CAID_VALUE) { cdata->caid = caid; }
+			cdata->emm_pid = b2i(2, data + i + 4) & 0x1FFF;;
+			cs_log_dbg(D_READER, "Stream %i found emm pid: 0x%04X (%i)",
+						cdata->connid, cdata->emm_pid, cdata->emm_pid);
+			break;
+		}
+	}
+}
+
+static void ParseEmmData(emu_stream_client_data *cdata)
+{
+	uint32_t keysAdded = 0;
+
+	ProcessEMM(NULL, cdata->caid, 0, cdata->emm_data, &keysAdded);
+
+	if (keysAdded)
+	{
+		//refresh_entitlements(rdr);
+		cs_log("Stream %i found %i keys", cdata->connid, keysAdded);
+	}
+}
+
+static void ParseEcmData(emu_stream_client_data *cdata)
+{
+	uint8_t *data = cdata->ecm_data;
+	uint8_t dcw[16];
+	uint16_t section_length = SCT_LEN(data);
+
+	if (section_length < 11)
+		{ return; }
+
+	if (caid_is_powervu(cdata->caid))
+	{
+		if (data[11] > cdata->ecm_nb || (cdata->ecm_nb == 255 && data[11] == 0) || ((cdata->ecm_nb - data[11]) > 5))
+		{
+			cdata->ecm_nb = data[11];
+			PowervuECM(data, dcw, cdata->srvid, &cdata->key, NULL);
+		}
+	}
+	//else if () // All other caids
+	//{
+		//ProcessECM();
+	//}
+}
+
+static void ParseTsPackets(emu_stream_client_data *data, uint8_t *stream_buf, uint32_t bufLength, uint16_t packetSize)
+{
+	uint8_t payloadStart;
+	uint16_t pid, offset;
+	uint32_t i, tsHeader;
+
+	for (i = 0; i < bufLength; i += packetSize)
+	{
+		tsHeader = b2i(4, stream_buf + i);
+		pid = (tsHeader & 0x1FFF00) >> 8;
+		payloadStart = (tsHeader & 0x400000) >> 22;
+
+		if (tsHeader & 0x20)
+		{
+			offset = 4 + stream_buf[i + 4] + 1;
+		}
+		else
+		{
+			offset = 4;
+		}
+
+		if (packetSize - offset < 1)
+			{ continue; }
+
+		if (pid == 0x0000 && data->have_pat_data != 1) // Search the PAT for the PMT pid
+		{
+			ParseTsData(0x00, 0xFF, 16, &data->have_pat_data, data->pat_data, sizeof(data->pat_data),
+						&data->pat_data_pos, payloadStart, stream_buf + i + offset, packetSize - offset, ParsePatData, data);
+			continue;
+		}
+
+		if (pid == data->pmt_pid && data->have_pmt_data != 1) // Search the PMT for PCR, ECM, Video and Audio pids
+		{
+			ParseTsData(0x02, 0xFF, 21, &data->have_pmt_data, data->pmt_data, sizeof(data->pmt_data),
+						&data->pmt_data_pos, payloadStart, stream_buf + i + offset, packetSize - offset, ParsePmtData, data);
+			continue;
+		}
+
+		// We have bot PAT and PMT data - No need to search the rest of the packets
+		if (data->have_pat_data == 1 && data->have_pmt_data == 1)
+			{ break; }
+	}
+}
+
+static void DescrambleTsPacketsPowervu(emu_stream_client_data *data, uint8_t *stream_buf, uint32_t bufLength, uint16_t packetSize)
+{
+	int8_t oddKeyUsed;
+
+	uint8_t scramblingControl, payloadStart, oddeven;
+	uint8_t *pdata, *packetClusterV[256];
+	uint8_t *packetClusterA[EMU_STREAM_MAX_AUDIO_SUB_TRACKS][64]; // separate cluster arrays for video and each audio track
+	uint16_t pid, offset;
+	uint32_t i, j, k, tsHeader;
+	uint32_t scrambled_packets = 0, scrambled_packetsA[EMU_STREAM_MAX_AUDIO_SUB_TRACKS] = { 0 };
+	uint32_t *deskey;
+	uint32_t cs = 0; // video cluster start
+	uint32_t ce = 1; // video cluster end
+	uint32_t csa[EMU_STREAM_MAX_AUDIO_SUB_TRACKS] = { 0 }; // cluster index for audio tracks
+
+	void *csakeyA[EMU_STREAM_MAX_AUDIO_SUB_TRACKS] = { 0 };
+	void *csakeyV = 0;
+	emu_stream_client_key_data *keydata;
+
+	packetClusterV[0] = NULL;
+
+	for (i = 0; i < bufLength; i += packetSize)
+	{
+		tsHeader = b2i(4, stream_buf + i);
+		pid = (tsHeader & 0x1FFF00) >> 8;
+		scramblingControl = tsHeader & 0xC0;
+		payloadStart = (tsHeader & 0x400000) >> 22;
+
+		if (tsHeader & 0x20)
+		{
+			offset = 4 + stream_buf[i + 4] + 1;
+		}
+		else
+		{
+			offset = 4;
+		}
+
+		if (packetSize - offset < 1)
+			{ continue; }
+
+		if (emu_stream_emm_enabled && pid == 0x0001 && data->have_cat_data != 1) // Search the CAT for EMM pids
+		{
+			// set to null pid
+			stream_buf[i + 1] |= 0x1F;
+			stream_buf[i + 2] = 0xFF;
+
+			ParseTsData(0x01, 0xFF, 8, &data->have_cat_data, data->cat_data, sizeof(data->cat_data),
+						&data->cat_data_pos, payloadStart, stream_buf + i + offset, packetSize - offset, ParseCatData, data);
+			continue;
+		}
+
+		if (emu_stream_emm_enabled && data->emm_pid && pid == data->emm_pid) // Process the EMM data
+		{
+			// set to null pid
+			stream_buf[i + 1] |= 0x1F;
+			stream_buf[i + 2] = 0xFF;
+
+			ParseTsData(0x80, 0xF0, 3, &data->have_emm_data, data->emm_data, sizeof(data->emm_data),
+						&data->emm_data_pos, payloadStart, stream_buf + i + offset, packetSize - offset, ParseEmmData, data);
+			continue;
+		}
+
+		if (data->ecm_pid && pid == data->ecm_pid) // Process the ECM data
+		{
+			stream_server_has_ecm[data->connid] = 1;
+
+			// set to null pid
+			stream_buf[i + 1] |= 0x1F;
+			stream_buf[i + 2] = 0xFF;
+
+			ParseTsData(0x80, 0xFE, 3, &data->have_ecm_data, data->ecm_data, sizeof(data->ecm_data),
+						&data->ecm_data_pos, payloadStart, stream_buf + i + offset, packetSize - offset, ParseEcmData, data);
+			continue;
+		}
+
+		if (scramblingControl == 0)
+			{ continue; }
+
+		if (!(stream_buf[i + 3] & 0x10))
+		{
+			stream_buf[i + 3] &= 0x3F;
+			continue;
+		}
+
+		oddKeyUsed = scramblingControl == 0xC0 ? 1 : 0;
+
+		if (!stream_server_has_ecm[data->connid])
+		{
+			keydata = &emu_fixed_key_data[data->connid];
+			SAFE_MUTEX_LOCK(&emu_fixed_key_data_mutex[data->connid]);
+			data->key.pvu_csa_used = keydata->pvu_csa_used;
+		}
+		else
+		{
+			keydata = &data->key;
+		}
+
+		if (keydata->pvu_csa_used)
+		{
+			oddeven = scramblingControl; // for detecting odd/even switch
+
+			if (pid == data->video_pid) // start with video pid, since it is most dominant
+			{
+				csakeyV = keydata->pvu_csa_ks[PVU_CW_VID];
+
+				if (csakeyV != NULL)
+				{
+					cs = 0;
+					ce = 1;
+					packetClusterV[cs] = stream_buf + i; // set first cluster start
+					packetClusterV[ce] = stream_buf + i + packetSize - 1;
+					scrambled_packets = 1;
+
+					// Now iterate through the rest of the packets and create clusters for batch decryption
+					for (j = i + packetSize; j < bufLength; j += packetSize)
+					{
+						tsHeader = b2i(4, stream_buf + j);
+						pid = (tsHeader & 0x1FFF00) >> 8;
+
+						if (pid == data->video_pid)
+						{
+							if (oddeven != (tsHeader & 0xC0)) // changed key so stop adding clusters
+							{
+								break;
+							}
+
+							if (cs > ce) // First video packet for each cluster
+							{
+								packetClusterV[cs] = stream_buf + j;
+								ce = cs + 1;
+							}
+
+							scrambled_packets++;
+						}
+						else
+						{
+							if (cs < ce) // First non-video packet - need to set end of video cluster
+							{
+								packetClusterV[ce] = stream_buf + j - 1;
+								cs = ce + 1;
+							}
+
+							if ((tsHeader & 0xC0) == 0)
+							{
+								continue;
+							}
+
+							if (oddeven != (tsHeader & 0xC0)) // changed key so stop adding clusters
+							{
+								j = bufLength; // to break out of outer loop also
+								break;
+							}
+
+							// Check for audio tracks and create single packet clusters
+							for (k = 0; k < data->audio_pid_count; k++)
+							{
+								if (pid == data->audio_pids[k])
+								{
+									packetClusterA[k][csa[k]] = stream_buf + j;
+									csa[k]++;
+									packetClusterA[k][csa[k]] = stream_buf + j + packetSize - 1;
+									csa[k]++;
+									scrambled_packetsA[k]++;
+								}
+							}
+						}
+					}
+
+					if (cs > ce) // last packet was not a video packet, so set null for end of all clusters
+					{
+						packetClusterV[cs] = NULL;
+					}
+					else
+					{
+						// last packet was a video packet, so set end of cluster to end of last packet
+						if (scrambled_packets > 1)
+						{
+							packetClusterV[ce] = stream_buf + j - 1;
+						}
+
+						packetClusterV[ce + 1] = NULL; // add null to end of cluster list
+					}
+
+					while (j >= cluster_size)
+					{
+						j = decrypt_packets(csakeyV, packetClusterV);
+					}
+
+					for (k = 0; k < data->audio_pid_count; k++)
+					{
+						// if audio track has scrambled packets, set null to mark end and decrypt
+						if (scrambled_packetsA[k])
+						{
+							csakeyA[k] = keydata->pvu_csa_ks[PVU_CW_A1 + k];
+							packetClusterA[k][csa[k]] = NULL;
+							decrypt_packets(csakeyA[k], packetClusterA[k]);
+							csa[k] = 0;
+							scrambled_packetsA[k] = 0;
+						}
+					}
+				}
+			}
+			else
+			{
+				for (j = 0; j < data->audio_pid_count; j++)
+				{
+					if (pid == data->audio_pids[j])
+					{
+						csakeyA[0] = keydata->pvu_csa_ks[PVU_CW_A1 + j];
+					}
+				}
+
+				if (csakeyA[0] != NULL)
+				{
+					packetClusterA[0][0] = stream_buf + i;
+					packetClusterA[0][1] = stream_buf + i + packetSize - 1;
+					packetClusterA[0][2] = NULL;
+					decrypt_packets(csakeyA[0], packetClusterA[0]);
+				}
+			}
+		}
+		else
+		{
+			deskey = NULL;
+
+			if (pid == data->video_pid)
+			{
+				deskey = keydata->pvu_des_ks[PVU_CW_VID][oddKeyUsed];
+			}
+			else
+			{
+				for (j = 0; j < data->audio_pid_count; j++)
+				{
+					if (pid == data->audio_pids[j])
+					{
+						deskey = keydata->pvu_des_ks[PVU_CW_A1 + j][oddKeyUsed];
+					}
+				}
+			}
+
+			if (deskey == NULL)
+			{
+				deskey = keydata->pvu_des_ks[PVU_CW_HSD][oddKeyUsed];
+			}
+
+			for (j = offset; j + 7 < 188; j += 8)
+			{
+				pdata = stream_buf + i + j;
+				des(pdata, deskey, 0);
+			}
+
+			stream_buf[i + 3] &= 0x3F;
+		}
+
+		if (!stream_server_has_ecm[data->connid])
+		{
+			SAFE_MUTEX_UNLOCK(&emu_fixed_key_data_mutex[data->connid]);
+		}
+	}
+}
+
+static void DescrambleTsPacketsRosscrypt1(emu_stream_client_data *data, uint8_t *stream_buf, uint32_t bufLength, uint16_t packetSize)
+{
+	int8_t can_decode = 0;
+	int32_t j;
+
+	uint8_t scramblingControl;
+	uint16_t pid, offset;
+	uint32_t i, tsHeader;
+
+	for (i = 0; i < bufLength; i += packetSize)
+	{
+		tsHeader = b2i(4, stream_buf + i);
+		pid = (tsHeader & 0x1FFF00) >> 8;
+		scramblingControl = tsHeader & 0xC0;
+
+		if (tsHeader & 0x20)
+		{
+			offset = 4 + stream_buf[i + 4] + 1;
+		}
+		else
+		{
+			offset = 4;
+		}
+
+		if (packetSize - offset < 1)
+			{ continue; }
+
+		if (scramblingControl == 0)
+			{ continue; }
+
+		if (!(stream_buf[i + 3] & 0x10))
+		{
+			stream_buf[i + 3] &= 0x3F;
+			continue;
+		}
+
+		if (pid == data->video_pid)
+		{
+			can_decode = 1;
+		}
+		else
+		{
+			for (j = 0; j < data->audio_pid_count; j++)
+			{
+					if (pid == data->audio_pids[j])
+					{
+						can_decode = 1;
+						break;
+					}
+			}
+		}
+
+		if (can_decode)
+		{
+			static uint8_t dyn_key[184];
+			static uint8_t last_packet[184];
+
+			if (memcmp(last_packet, stream_buf + i + offset, 184) == 0)
+			{
+				if (memcmp(dyn_key, stream_buf + i + offset, 184) != 0)
+				{
+					memcpy(dyn_key, stream_buf + i + offset, 184);
+				}
+			}
+			else
+			{
+				memcpy(last_packet, stream_buf + i + offset, 184);
+			}
+
+			for (j = 0; j < 184; j++)
+			{
+				stream_buf[i + offset + j] ^= dyn_key[j];
+			}
+
+			stream_buf[i + 3] &= 0x3F;
+		}
+	}
+}
+
+static void DescrambleTsPacketsCompel(emu_stream_client_data *data, uint8_t *stream_buf, uint32_t bufLength, uint16_t packetSize)
+{
+	int8_t can_decode = 0;
+	int32_t j;
+
+	uint8_t scramblingControl;
+	uint16_t pid, offset;
+	uint32_t i, tsHeader;
+
+	for (i = 0; i < bufLength; i += packetSize)
+	{
+		tsHeader = b2i(4, stream_buf + i);
+		pid = (tsHeader & 0x1FFF00) >> 8;
+		scramblingControl = tsHeader & 0xC0;
+
+		if (tsHeader & 0x20)
+		{
+			offset = 4 + stream_buf[i + 4] + 1;
+		}
+		else
+		{
+			offset = 4;
+		}
+
+		if (packetSize - offset < 1)
+			{ continue; }
+
+		if (scramblingControl == 0)
+			{ continue; }
+
+		if (!(stream_buf[i + 3] & 0x10))
+		{
+			stream_buf[i + 3] &= 0x3F;
+			continue;
+		}
+
+		if (pid == data->video_pid)
+		{
+			can_decode = 1;
+		}
+		else
+		{
+			for (j = 0; j < data->audio_pid_count; j++)
+			{
+					if (pid == data->audio_pids[j])
+					{
+						can_decode = 1;
+						break;
+					}
+			}
+		}
+
+		if (can_decode)
+		{
+			static uint8_t dyn_key[184];
+
+			int8_t matches00 = 0;
+			int8_t matchesFF = 0;
+			int8_t last00_was_good = 0;
+			int8_t lastFF_was_good = 0;
+			int8_t limit = 64;
+
+			for (j = 0; j < 184; j++)
+			{
+				if (stream_buf[i + offset + j] == 0x00)
+				{
+					last00_was_good = 1;
+					matches00++;
+					if (matches00 > limit) dyn_key[j] = 0x00;
+				}
+				else if (stream_buf[i + offset + j] == 0x3F)
+				{
+					last00_was_good = 1;
+					matches00++;
+					if (matches00 > limit) dyn_key[j] = 0x3F;
+				}
+				else
+				{
+					if (last00_was_good) matches00--;
+					else matches00 -= 2;
+
+					if (matches00 < 0) matches00 = 0;
+					last00_was_good = 0;
+				}
+
+				if (stream_buf[i + offset + j] == 0xC0)
+				{
+					lastFF_was_good = 1;
+					matchesFF++;
+					if (matchesFF > limit) dyn_key[j] = 0x3F;
+				}
+				else if (stream_buf[i + offset + j] == 0xFF)
+				{
+					lastFF_was_good = 1;
+					matchesFF++;
+					if (matchesFF > limit) dyn_key[j] = 0x00;
+				}
+				else
+				{
+					if (lastFF_was_good) matchesFF--;
+					else matchesFF -= 2;
+
+					if (matchesFF < 0) matchesFF = 0;
+					lastFF_was_good = 0;
+				}
+			}
+
+			for (j = 183; j >= 0; j--)
+			{
+				if (stream_buf[i + offset + j] == 0x00)
+				{
+					last00_was_good = 1;
+					matches00++;
+					if (matches00 > limit) dyn_key[j] = 0x00;
+				}
+				else if (stream_buf[i + offset + j] == 0x3F)
+				{
+					last00_was_good = 1;
+					matches00++;
+					if (matches00 > limit) dyn_key[j] = 0x3F;
+				}
+				else
+				{
+					if (last00_was_good) matches00--;
+					else matches00 -= 2;
+
+					if (matches00 < 0) matches00 = 0;
+					last00_was_good = 0;
+				}
+
+				if (stream_buf[i + offset + j] == 0xC0)
+				{
+					lastFF_was_good = 1;
+					matchesFF++;
+					if (matchesFF > limit) dyn_key[j] = 0x3F;
+				}
+				else if (stream_buf[i + offset + j] == 0xFF)
+				{
+					lastFF_was_good = 1;
+					matchesFF++;
+					if (matchesFF > limit) dyn_key[j] = 0x00;
+				}
+				else
+				{
+					if (lastFF_was_good) matchesFF--;
+					else matchesFF -= 2;
+
+					if (matchesFF < 0) matchesFF = 0;
+					lastFF_was_good = 0;
+				}
+			}
+
+			for (j = 0; j < 184; j++)
+			{
+				stream_buf[i + offset + j] ^= dyn_key[j];
+			}
+
+			stream_buf[i + 3] &= 0x3F;
+		}
+	}
+}
+
+static int32_t connect_to_stream(char *http_buf, int32_t http_buf_len, char *stream_path)
+{
+	struct sockaddr_in cservaddr;
+	IN_ADDR_T in_addr;
+
+	int32_t streamfd = socket(AF_INET, SOCK_STREAM, 0);
+	if (streamfd == -1)
+		{ return -1; }
+
+	struct timeval tv;
+	tv.tv_sec = 2;
+	tv.tv_usec = 0;
+	if (setsockopt(streamfd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof tv))
+	{
+		cs_log("ERROR: setsockopt() failed for SO_RCVTIMEO");
+		return -1;
+	}
+
+	bzero(&cservaddr, sizeof(cservaddr));
+	cservaddr.sin_family = AF_INET;
+	cs_resolve(emu_stream_source_host, &in_addr, NULL, NULL);
+	SIN_GET_ADDR(cservaddr) = in_addr;
+	cservaddr.sin_port = htons(emu_stream_source_port);
+
+	if (connect(streamfd, (struct sockaddr *)&cservaddr, sizeof(cservaddr)) == -1)
+		{ return -1; }
+
+	if (emu_stream_source_auth)
+	{
+		snprintf(http_buf, http_buf_len, "GET %s HTTP/1.1\nHost: %s:%u\n"
+				"User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0\n"
+				"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n"
+				"Accept-Language: en-US\n"
+				"Authorization: Basic %s\n"
+				"Connection: keep-alive\n\n", stream_path, emu_stream_source_host, emu_stream_source_port, emu_stream_source_auth);
+	}
+	else
+	{
+		snprintf(http_buf, http_buf_len, "GET %s HTTP/1.1\nHost: %s:%u\n"
+				"User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0\n"
+				"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n"
+				"Accept-Language: en-US\n"
+				"Connection: keep-alive\n\n", stream_path, emu_stream_source_host, emu_stream_source_port);
+	}
+
+	if (send(streamfd, http_buf, strlen(http_buf), 0) == -1)
+		{ return -1; }
+
+	return streamfd;
+}
+
+static void stream_client_disconnect(emu_stream_client_conn_data *conndata)
+{
+	int32_t i;
+
+	SAFE_MUTEX_LOCK(&emu_fixed_key_srvid_mutex);
+	emu_stream_cur_srvid[conndata->connid] = NO_SRVID_VALUE;
+	stream_server_has_ecm[conndata->connid] = 0;
+	SAFE_MUTEX_UNLOCK(&emu_fixed_key_srvid_mutex);
+
+	SAFE_MUTEX_LOCK(&emu_stream_server_mutex);
+	for (i = 0; i < EMU_STREAM_SERVER_MAX_CONNECTIONS; i++)
+	{
+		if (gconnfd[i] == conndata->connfd)
+		{
+			gconnfd[i] = -1;
+			gconncount--;
+		}
+	}
+	SAFE_MUTEX_UNLOCK(&emu_stream_server_mutex);
+
+	shutdown(conndata->connfd, 2);
+	close(conndata->connfd);
+
+	cs_log("Stream client %i disconnected",conndata->connid);
+
+	NULLFREE(conndata);
+}
+
+static void *stream_client_handler(void *arg)
+{
+	emu_stream_client_conn_data *conndata = (emu_stream_client_conn_data *)arg;
+	emu_stream_client_data *data;
+
+	char *http_buf, stream_path[255], stream_path_copy[255];
+	char *saveptr, *token, http_version[4];
+
+	int8_t streamConnectErrorCount = 0, streamDataErrorCount = 0;
+	int32_t bytesRead = 0, http_status_code = 0;
+	int32_t clientStatus, streamStatus, streamfd;
+	int32_t cur_dvb_buffer_size, cur_dvb_buffer_wait, i, srvidtmp;
+
+	uint8_t *stream_buf;
+	uint16_t packetCount = 0, packetSize = 0, startOffset = 0;
+	uint32_t remainingDataPos, remainingDataLength;
+
+	cs_log("Stream client %i connected", conndata->connid);
+
+	if (!cs_malloc(&http_buf, 1024))
+	{
+		stream_client_disconnect(conndata);
+		return NULL;
+	}
+
+	if (!cs_malloc(&stream_buf, EMU_DVB_BUFFER_SIZE))
+	{
+		NULLFREE(http_buf);
+		stream_client_disconnect(conndata);
+		return NULL;
+	}
+
+	if (!cs_malloc(&data, sizeof(emu_stream_client_data)))
+	{
+		NULLFREE(http_buf);
+		NULLFREE(stream_buf);
+		stream_client_disconnect(conndata);
+		return NULL;
+	}
+
+	clientStatus = recv(conndata->connfd, http_buf, 1024, 0);
+	if (clientStatus < 1)
+	{
+		NULLFREE(http_buf);
+		NULLFREE(stream_buf);
+		NULLFREE(data);
+		stream_client_disconnect(conndata);
+		return NULL;
+	}
+
+	http_buf[1023] = '\0';
+	if (sscanf(http_buf, "GET %254s ", stream_path) < 1)
+	{
+		NULLFREE(http_buf);
+		NULLFREE(stream_buf);
+		NULLFREE(data);
+		stream_client_disconnect(conndata);
+		return NULL;
+	}
+
+	cs_strncpy(stream_path_copy, stream_path, sizeof(stream_path));
+
+	token = strtok_r(stream_path_copy, ":", &saveptr);
+
+	for (i = 0; token != NULL && i < 3; i++)
+	{
+		token = strtok_r(NULL, ":", &saveptr);
+		if (token == NULL)
+			{ break; }
+	}
+
+	if (token != NULL)
+	{
+		if (sscanf(token, "%x", &srvidtmp) < 1)
+		{
+			token = NULL;
+		}
+		else
+		{
+			data->srvid = srvidtmp & 0xFFFF;
+		}
+	}
+
+	if (token == NULL)
+	{
+		NULLFREE(http_buf);
+		NULLFREE(stream_buf);
+		NULLFREE(data);
+		stream_client_disconnect(conndata);
+		return NULL;
+	}
+
+	SAFE_MUTEX_LOCK(&emu_fixed_key_srvid_mutex);
+	emu_stream_cur_srvid[conndata->connid] = data->srvid;
+	stream_server_has_ecm[conndata->connid] = 0;
+	SAFE_MUTEX_UNLOCK(&emu_fixed_key_srvid_mutex);
+
+	cs_log("Stream client %i request %s", conndata->connid, stream_path);
+
+	snprintf(http_buf, 1024, "HTTP/1.0 200 OK\nConnection: Close\nContent-Type: video/mpeg\nServer: stream_enigma2\n\n");
+	clientStatus = send(conndata->connfd, http_buf, strlen(http_buf), 0);
+
+	data->connid = conndata->connid;
+	data->caid = NO_CAID_VALUE;
+
+	while (!exit_oscam && clientStatus != -1 && streamConnectErrorCount < 3
+			&& streamDataErrorCount < 15)
+	{
+		streamfd = connect_to_stream(http_buf, 1024, stream_path);
+		if (streamfd == -1)
+		{
+			cs_log("WARNING: stream client %i cannot connect to stream source", conndata->connid);
+			streamConnectErrorCount++;
+			cs_sleepms(500);
+			continue;
+		}
+
+		streamStatus = 0;
+		bytesRead = 0;
+
+		while (!exit_oscam && clientStatus != -1 && streamStatus != -1
+				&& streamConnectErrorCount < 3 && streamDataErrorCount < 15)
+		{
+			if (data->key.pvu_csa_used)
+			{
+				cur_dvb_buffer_size = EMU_DVB_BUFFER_SIZE_CSA;
+				cur_dvb_buffer_wait = EMU_DVB_BUFFER_WAIT_CSA;
+			}
+			else
+			{
+				cur_dvb_buffer_size = EMU_DVB_BUFFER_SIZE_DES;
+				cur_dvb_buffer_wait = EMU_DVB_BUFFER_WAIT_DES;
+			}
+
+			streamStatus = recv(streamfd, stream_buf + bytesRead, cur_dvb_buffer_size - bytesRead, MSG_WAITALL);
+			if (streamStatus == 0) // socket closed
+			{
+				cs_log("WARNING: stream client %i - stream source closed connection", conndata->connid);
+				streamConnectErrorCount++;
+				cs_sleepms(100);
+				break;
+			}
+
+			if (streamStatus < 0) // error
+			{
+				if ((errno == EWOULDBLOCK) | (errno == EAGAIN))
+				{
+					cs_log("WARNING: stream client %i no data from stream source", conndata->connid);
+					streamDataErrorCount++; // 2 sec timeout * 15 = 30 seconds no data -> close
+					cs_sleepms(100);
+					continue;
+				}
+
+				cs_log("WARNING: stream client %i error receiving data from stream source", conndata->connid);
+				streamConnectErrorCount++;
+				cs_sleepms(100);
+				break;
+			}
+
+			if (streamStatus < cur_dvb_buffer_size - bytesRead) // probably just received header but no stream
+			{
+				if (!bytesRead && streamStatus > 13 &&
+					sscanf((const char*)stream_buf, "HTTP/%3s %d ", http_version , &http_status_code) == 2 &&
+					http_status_code != 200)
+				{
+					cs_log("ERROR: stream client %i got %d response from stream source", conndata->connid, http_status_code);
+					streamConnectErrorCount++;
+					cs_sleepms(100);
+					break;
+				}
+				else
+				{
+					cs_log_dbg(0, "WARNING: stream client %i non-full buffer from stream source", conndata->connid);
+					streamDataErrorCount++;
+					cs_sleepms(100);
+				}
+			}
+			else
+			{
+				streamDataErrorCount = 0;
+			}
+
+			streamConnectErrorCount = 0;
+			bytesRead += streamStatus;
+
+			if (bytesRead >= cur_dvb_buffer_wait)
+			{
+				startOffset = 0;
+
+				// only search if not starting on ts packet or unknown packet size
+				if (stream_buf[0] != 0x47 || packetSize == 0)
+				{
+					SearchTsPackets(stream_buf, bytesRead, &packetSize, &startOffset);
+				}
+
+				if (packetSize == 0)
+				{
+					bytesRead = 0;
+				}
+				else
+				{
+					packetCount = ((bytesRead - startOffset) / packetSize);
+
+					// We have both PAT and PMT data - We can start descrambling
+					if (data->have_pat_data == 1 && data->have_pmt_data == 1)
+					{
+						if (chk_ctab_ex(data->caid, &cfg.emu_stream_relay_ctab))
+						{
+							if (caid_is_powervu(data->caid))
+							{
+								DescrambleTsPacketsPowervu(data, stream_buf + startOffset, packetCount * packetSize, packetSize);
+							}
+							else if (data->caid == 0xA101) // Rosscrypt1
+							{
+								DescrambleTsPacketsRosscrypt1(data, stream_buf + startOffset, packetCount * packetSize, packetSize);
+							}
+							else if (data->caid == NO_CAID_VALUE) // Compel
+							{
+								DescrambleTsPacketsCompel(data, stream_buf + startOffset, packetCount * packetSize, packetSize);
+							}
+						}
+						else
+						{
+							cs_log_dbg(D_READER, "Stream client %i caid %04X not enabled in stream relay config",
+										conndata->connid, data->caid);
+						}
+					}
+					else // Search PAT and PMT packets for service information
+					{
+						ParseTsPackets(data, stream_buf + startOffset, packetCount * packetSize, packetSize);
+					}
+
+					clientStatus = send(conndata->connfd, stream_buf + startOffset, packetCount * packetSize, 0);
+
+					remainingDataPos = startOffset + (packetCount * packetSize);
+					remainingDataLength = bytesRead - remainingDataPos;
+
+					if (remainingDataPos < remainingDataLength)
+					{
+						memmove(stream_buf, stream_buf + remainingDataPos, remainingDataLength);
+					}
+					else
+					{
+						memcpy(stream_buf, stream_buf + remainingDataPos, remainingDataLength);
+					}
+
+					bytesRead = remainingDataLength;
+				}
+			}
+		}
+
+		close(streamfd);
+	}
+
+	NULLFREE(http_buf);
+	NULLFREE(stream_buf);
+
+	for (i = 0; i < 8; i++)
+	{
+		if (data->key.pvu_csa_ks[i])
+		{
+			free_key_struct(data->key.pvu_csa_ks[i]);
+		}
+	}
+	NULLFREE(data);
+
+	stream_client_disconnect(conndata);
+	return NULL;
+}
+
+void *stream_server(void *UNUSED(a))
+{
+	struct sockaddr_in servaddr, cliaddr;
+	socklen_t clilen;
+	int32_t connfd, reuse = 1, i;
+	int8_t connaccepted;
+	emu_stream_client_conn_data *conndata;
+
+	cluster_size = get_internal_parallelism();
+	cs_log("INFO: FFDecsa parallel mode = %d", cluster_size);
+
+	if (!emu_stream_server_mutex_init)
+	{
+		SAFE_MUTEX_INIT(&emu_stream_server_mutex, NULL);
+		emu_stream_server_mutex_init = 1;
+	}
+
+	SAFE_MUTEX_LOCK(&emu_fixed_key_srvid_mutex);
+	for (i = 0; i < EMU_STREAM_SERVER_MAX_CONNECTIONS; i++)
+	{
+		emu_stream_cur_srvid[i] = NO_SRVID_VALUE;
+		stream_server_has_ecm[i] = 0;
+	}
+	SAFE_MUTEX_UNLOCK(&emu_fixed_key_srvid_mutex);
+
+	for (i = 0; i < EMU_STREAM_SERVER_MAX_CONNECTIONS; i++)
+	{
+		gconnfd[i] = -1;
+	}
+
+	glistenfd = socket(AF_INET, SOCK_STREAM, 0);
+	if (glistenfd == -1)
+	{
+		cs_log("ERROR: cannot create stream server socket");
+		return NULL;
+	}
+
+	bzero(&servaddr,sizeof(servaddr));
+	servaddr.sin_family = AF_INET;
+	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	servaddr.sin_port = htons(emu_stream_relay_port);
+	setsockopt(glistenfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
+
+	if (bind(glistenfd,(struct sockaddr *)&servaddr, sizeof(servaddr)) == -1)
+	{
+		cs_log("ERROR: cannot bind to stream server socket");
+		close(glistenfd);
+		return NULL;
+	}
+
+	if (listen(glistenfd, 3) == -1)
+	{
+		cs_log("ERROR: cannot listen to stream server socket");
+		close(glistenfd);
+		return NULL;
+	}
+
+	while (!exit_oscam)
+	{
+		clilen = sizeof(cliaddr);
+		connfd = accept(glistenfd,(struct sockaddr *)&cliaddr, &clilen);
+
+		if (connfd == -1)
+		{
+			cs_log("ERROR: accept() failed");
+			break;
+		}
+
+		connaccepted = 0;
+
+		if (cs_malloc(&conndata, sizeof(emu_stream_client_conn_data)))
+		{
+			SAFE_MUTEX_LOCK(&emu_stream_server_mutex);
+			if (gconncount < EMU_STREAM_SERVER_MAX_CONNECTIONS)
+			{
+				for (i = 0; i < EMU_STREAM_SERVER_MAX_CONNECTIONS; i++)
+				{
+					if (gconnfd[i] == -1)
+					{
+						gconnfd[i] = connfd;
+						gconncount++;
+						connaccepted = 1;
+
+						conndata->connfd = connfd;
+						conndata->connid = i;
+
+						break;
+					}
+				}
+			}
+			SAFE_MUTEX_UNLOCK(&emu_stream_server_mutex);
+		}
+
+		if (connaccepted)
+		{
+			int on = 1;
+			if (setsockopt(connfd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) < 0)
+			{
+				cs_log("ERROR: stream client %i setsockopt() failed for TCP_NODELAY", conndata->connid);
+			}
+
+			start_thread("emu stream client", stream_client_handler, (void*)conndata, NULL, 1, 0);
+		}
+		else
+		{
+			shutdown(connfd, 2);
+			close(connfd);
+			cs_log("ERROR: stream server client dropped because of too many connections (%i)", EMU_STREAM_SERVER_MAX_CONNECTIONS);
+		}
+
+		cs_sleepms(20);
+	}
+
+	close(glistenfd);
+
+	return NULL;
+}
+
+void *stream_key_delayer(void *UNUSED(arg))
+{
+	int32_t i, j;
+	emu_stream_client_key_data *cdata;
+	LL_ITER it;
+	emu_stream_cw_item *item;
+	struct timeb t_now;
+
+	while (!exit_oscam)
+	{
+		cs_ftime(&t_now);
+
+		for (i = 0; i < EMU_STREAM_SERVER_MAX_CONNECTIONS; i++)
+		{
+			it = ll_iter_create(ll_emu_stream_delayed_keys[i]);
+
+			while ((item = ll_iter_next(&it)))
+			{
+				if (comp_timeb(&t_now, &item->write_time) < 0)
+				{
+					break;
+				}
+
+				SAFE_MUTEX_LOCK(&emu_fixed_key_data_mutex[i]);
+
+				cdata = &emu_fixed_key_data[i];
+
+				for (j = 0; j < 8; j++)
+				{
+					if (item->csa_used)
+					{
+						if (cdata->pvu_csa_ks[j] == NULL)
+						{
+							cdata->pvu_csa_ks[j] = get_key_struct();
+						}
+
+						if (item->is_even)
+						{
+							set_even_control_word(cdata->pvu_csa_ks[j], item->cw[j]);
+						}
+						else
+						{
+							set_odd_control_word(cdata->pvu_csa_ks[j], item->cw[j]);
+						}
+
+						cdata->pvu_csa_used = 1;
+					}
+					else
+					{
+						if (item->is_even)
+						{
+							des_set_key(item->cw[j], cdata->pvu_des_ks[j][0]);
+						}
+						else
+						{
+							des_set_key(item->cw[j], cdata->pvu_des_ks[j][1]);
+						}
+
+						cdata->pvu_csa_used = 0;
+					}
+				}
+				SAFE_MUTEX_UNLOCK(&emu_fixed_key_data_mutex[i]);
+
+				ll_iter_remove_data(&it);
+			}
+		}
+
+		cs_sleepms(25);
+	}
+
+	return NULL;
+}
+
+void stop_stream_server(void)
+{
+	int32_t i;
+
+	SAFE_MUTEX_LOCK(&emu_stream_server_mutex);
+	for (i = 0; i < EMU_STREAM_SERVER_MAX_CONNECTIONS; i++)
+	{
+		if (gconnfd[i] != -1)
+		{
+			shutdown(gconnfd[i], 2);
+			close(gconnfd[i]);
+			gconnfd[i] = -1;
+		}
+	}
+
+	gconncount = 0;
+	SAFE_MUTEX_UNLOCK(&emu_stream_server_mutex);
+
+	shutdown(glistenfd, 2);
+	close(glistenfd);
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-streamserver.h b/module-emulator-streamserver.h
new file mode 100644
index 0000000..a16bb5b
--- /dev/null
+++ b/module-emulator-streamserver.h
@@ -0,0 +1,85 @@
+#ifndef MODULE_EMULATOR_STREAMSERVER_H_
+#define MODULE_EMULATOR_STREAMSERVER_H_
+
+#ifdef WITH_EMU
+
+#define EMU_STREAM_SERVER_MAX_CONNECTIONS 8
+#define EMU_STREAM_MAX_AUDIO_SUB_TRACKS 16
+
+#define EMU_DVB_MAX_TS_PACKETS 278
+#define EMU_DVB_BUFFER_SIZE_CSA 188*EMU_DVB_MAX_TS_PACKETS
+#define EMU_DVB_BUFFER_WAIT_CSA 188*(EMU_DVB_MAX_TS_PACKETS-128)
+#define EMU_DVB_BUFFER_SIZE_DES 188*32
+#define EMU_DVB_BUFFER_WAIT_DES 188*29
+#define EMU_DVB_BUFFER_SIZE EMU_DVB_BUFFER_SIZE_CSA
+
+typedef struct
+{
+	uint32_t pvu_des_ks[8][2][32];
+	int8_t pvu_csa_used;
+	void* pvu_csa_ks[8];
+} emu_stream_client_key_data;
+
+typedef struct
+{
+	int32_t connid;
+	int8_t have_cat_data;
+	int8_t have_pat_data;
+	int8_t have_pmt_data;
+	int8_t have_ecm_data;
+	int8_t have_emm_data;
+	uint8_t cat_data[1024+208];
+	uint8_t pat_data[1024+208];
+	uint8_t pmt_data[1024+208];
+	uint8_t ecm_data[1024+208];
+	uint8_t emm_data[1024+208];
+	uint16_t cat_data_pos;
+	uint16_t pat_data_pos;
+	uint16_t pmt_data_pos;
+	uint16_t ecm_data_pos;
+	uint16_t emm_data_pos;
+	uint16_t srvid;
+	uint16_t caid;
+	uint16_t pmt_pid;
+	uint16_t ecm_pid;
+	uint16_t emm_pid;
+	uint16_t video_pid;
+	uint16_t pcr_pid;
+	uint16_t audio_pids[EMU_STREAM_MAX_AUDIO_SUB_TRACKS];
+	uint8_t audio_pid_count;
+	int16_t ecm_nb;
+	emu_stream_client_key_data key;
+} emu_stream_client_data;
+
+extern char emu_stream_source_host[256];
+extern int32_t emu_stream_source_port;
+extern char *emu_stream_source_auth;
+extern int32_t emu_stream_relay_port;
+extern int8_t emu_stream_emm_enabled;
+
+extern int8_t stream_server_thread_init;
+
+void *stream_server(void *a);
+void stop_stream_server(void);
+
+typedef struct
+{
+	struct timeb write_time;
+	int8_t csa_used;
+	int8_t is_even;
+	uint8_t cw[8][8];
+} emu_stream_cw_item;
+
+extern pthread_mutex_t emu_fixed_key_srvid_mutex;
+extern uint16_t emu_stream_cur_srvid[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+extern int8_t stream_server_has_ecm[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+
+extern pthread_mutex_t emu_fixed_key_data_mutex[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+extern emu_stream_client_key_data emu_fixed_key_data[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+extern LLIST *ll_emu_stream_delayed_keys[EMU_STREAM_SERVER_MAX_CONNECTIONS];
+
+void *stream_key_delayer(void *arg);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_STREAMSERVER_H_
diff --git a/module-emulator-viaccess.c b/module-emulator-viaccess.c
new file mode 100644
index 0000000..0b7bb70
--- /dev/null
+++ b/module-emulator-viaccess.c
@@ -0,0 +1,886 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "cscrypt/des.h"
+#include "module-emulator-osemu.h"
+#include "module-newcamd-des.h"
+#include "oscam-aes.h"
+#include "oscam-string.h"
+
+// from reader-viaccess.c:
+void hdSurEncPhase1_D2_0F_11(uint8_t *CWs);
+void hdSurEncPhase2_D2_0F_11(uint8_t *CWs);
+void hdSurEncPhase1_D2_13_15(uint8_t *cws);
+void hdSurEncPhase2_D2_13_15(uint8_t *cws);
+
+// Viaccess EMU
+static int8_t GetViaKey(uint8_t *buf, uint32_t ident, char keyName, uint32_t keyIndex, uint32_t keyLength, uint8_t isCriticalKey)
+{
+
+	char keyStr[EMU_MAX_CHAR_KEYNAME];
+	snprintf(keyStr, EMU_MAX_CHAR_KEYNAME, "%c%X", keyName, keyIndex);
+	if(FindKey('V', ident, 0, keyStr, buf, keyLength, isCriticalKey, 0, 0, NULL)) {
+		return 1;
+	}
+
+	if(ident == 0xD00040 && FindKey('V', 0x030B00, 0, keyStr, buf, keyLength, isCriticalKey, 0, 0, NULL)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static void Via1Mod(const uint8_t* key2, uint8_t* data)
+{
+	int32_t kb, db;
+	for (db=7; db>=0; db--) {
+		for (kb=7; kb>3; kb--) {
+			int32_t a0=kb^db;
+			int32_t pos=7;
+			if (a0&4) {
+				a0^=7;
+				pos^=7;
+			}
+			a0=(a0^(kb&3)) + (kb&3);
+			if (!(a0&4)) {
+				data[db]^=(key2[kb] ^ ((data[kb^pos]*key2[kb^4]) & 0xFF));
+			}
+		}
+	}
+	for (db=0; db<8; db++) {
+		for (kb=0; kb<4; kb++) {
+			int32_t a0=kb^db;
+			int32_t pos=7;
+			if (a0&4) {
+				a0^=7;
+				pos^=7;
+			}
+			a0=(a0^(kb&3)) + (kb&3);
+			if (!(a0&4)) {
+				data[db]^=(key2[kb] ^ ((data[kb^pos]*key2[kb^4]) & 0xFF));
+			}
+		}
+	}
+}
+
+static void Via1Decode(uint8_t *data, uint8_t *key)
+{
+	Via1Mod(key+8, data);
+	nc_des(key, DES_ECM_CRYPT, data);
+	Via1Mod(key+8, data);
+}
+
+static void Via1Hash(uint8_t *data, uint8_t *key)
+{
+	Via1Mod(key+8, data);
+	nc_des(key, DES_ECM_HASH, data);
+	Via1Mod(key+8, data);
+}
+
+static inline void Via1DoHash(uint8_t *hashbuffer, uint8_t *pH, uint8_t data, uint8_t *hashkey)
+{
+	hashbuffer[*pH] ^= data;
+	(*pH)++;
+
+	if(*pH == 8) {
+		Via1Hash(hashbuffer, hashkey);
+		*pH = 0;
+	}
+}
+
+static int8_t Via1Decrypt(uint8_t* ecm, uint8_t* dw, uint32_t ident, uint8_t desKeyIndex)
+{
+	uint8_t work_key[16];
+	uint8_t *data, *des_data1, *des_data2;
+	uint16_t ecmLen = GetEcmLen(ecm);
+	int32_t msg_pos;
+	int32_t encStart = 0, hash_start, i;
+	uint8_t signature[8], hashbuffer[8], prepared_key[16], hashkey[16];
+	uint8_t tmp, k, pH, foundData = 0;
+
+	if (ident == 0) {
+		return 4;
+	}
+	memset(work_key, 0, 16);
+	if(!GetViaKey(work_key, ident, '0', desKeyIndex, 8, 1)) {
+		return 2;
+	}
+
+	if(ecmLen < 11) {
+		return 1;
+	}
+	data = ecm+9;
+	des_data1 = dw;
+	des_data2 = dw+8;
+
+	msg_pos = 0;
+	pH = 0;
+	memset(hashbuffer, 0, sizeof(hashbuffer));
+	memcpy(hashkey, work_key, sizeof(hashkey));
+	memset(signature, 0, 8);
+
+	while(9+msg_pos+2 < ecmLen) {
+		switch (data[msg_pos]) {
+		case 0xea:
+			if(9+msg_pos+2+15 < ecmLen) {
+				encStart = msg_pos + 2;
+				memcpy(des_data1, &data[msg_pos+2], 8);
+				memcpy(des_data2, &data[msg_pos+2+8], 8);
+				foundData |= 1;
+			}
+			break;
+		case 0xf0:
+			if(9+msg_pos+2+7 < ecmLen) {
+				memcpy(signature, &data[msg_pos+2], 8);
+				foundData |= 2;
+			}
+			break;
+		}
+		msg_pos += data[msg_pos+1]+2;
+	}
+
+	if(foundData != 3) {
+		return 1;
+	}
+
+	pH=i=0;
+
+	if(data[0] == 0x9f && 10+data[1] <= ecmLen) {
+		Via1DoHash(hashbuffer, &pH, data[i++], hashkey);
+		Via1DoHash(hashbuffer, &pH, data[i++], hashkey);
+
+		for (hash_start=0; hash_start < data[1]; hash_start++) {
+			Via1DoHash(hashbuffer, &pH, data[i++], hashkey);
+		}
+
+		while (pH != 0) {
+			Via1DoHash(hashbuffer, &pH, 0, hashkey);
+		}
+	}
+
+	if (work_key[7] == 0) {
+		for (; i < encStart + 16; i++) {
+			Via1DoHash(hashbuffer, &pH, data[i], hashkey);
+		}
+		memcpy(prepared_key, work_key, 8);
+	}
+	else {
+		prepared_key[0] = work_key[2];
+		prepared_key[1] = work_key[3];
+		prepared_key[2] = work_key[4];
+		prepared_key[3] = work_key[5];
+		prepared_key[4] = work_key[6];
+		prepared_key[5] = work_key[0];
+		prepared_key[6] = work_key[1];
+		prepared_key[7] = work_key[7];
+		memcpy(prepared_key+8, work_key+8, 8);
+
+		if (work_key[7] & 1) {
+			for (; i < encStart; i++) {
+				Via1DoHash(hashbuffer, &pH, data[i], hashkey);
+			}
+
+			k = ((work_key[7] & 0xf0) == 0) ? 0x5a : 0xa5;
+
+			for (i=0; i<8; i++) {
+				tmp = des_data1[i];
+				des_data1[i] = (k & hashbuffer[pH] ) ^ tmp;
+				Via1DoHash(hashbuffer, &pH, tmp, hashkey);
+			}
+
+			for (i = 0; i < 8; i++) {
+				tmp = des_data2[i];
+				des_data2[i] = (k & hashbuffer[pH] ) ^ tmp;
+				Via1DoHash(hashbuffer, &pH, tmp, hashkey);
+			}
+		}
+		else {
+			for (; i < encStart + 16; i++) {
+				Via1DoHash(hashbuffer, &pH, data[i], hashkey);
+			}
+		}
+	}
+	Via1Decode(des_data1, prepared_key);
+	Via1Decode(des_data2, prepared_key);
+	Via1Hash(hashbuffer, hashkey);
+	if(memcmp(signature, hashbuffer, 8)) {
+		return 6;
+	}
+	return 0;
+}
+
+static int8_t Via26ProcessDw(uint8_t *indata, uint32_t ident, uint8_t desKeyIndex)
+{
+	uint8_t pv1,pv2, i;
+	uint8_t Tmp[8], T1Key[300], P1Key[8], KeyDes1[16], KeyDes2[16], XorKey[8];
+	uint32_t ks1[32], ks2[32];
+
+	if(!GetViaKey(T1Key, ident, 'T', 1, 300, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(P1Key, ident, 'P', 1, 8, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(KeyDes1, ident, 'D', 1, 16, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(KeyDes2, ident, '0', desKeyIndex, 16, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(XorKey, ident, 'X', 1, 8, 1)) {
+		return 2;
+	}
+
+	for (i=0; i<8; i++) {
+		pv1 = indata[i];
+		Tmp[i] = T1Key[pv1];
+	}
+	for (i=0; i<8; i++) {
+		pv1 = P1Key[i];
+		pv2 = Tmp[pv1];
+		indata[i]=pv2;
+	}
+	
+	des_set_key(KeyDes1, ks1);
+	des(indata, ks1, 1);
+	
+	for (i=0; i<8; i++) {
+		indata[i] ^= XorKey[i];
+	}
+	
+	des_set_key(KeyDes2, ks1);
+	des_set_key(KeyDes2+8, ks2);
+	des(indata, ks1, 0);
+	des(indata, ks2, 1);
+	des(indata, ks1, 0);
+	
+	for (i=0; i<8; i++) {
+		indata[i] ^= XorKey[i];
+	}
+	
+	des_set_key(KeyDes1, ks1);
+	des(indata, ks1, 0);
+
+	for (i=0; i<8; i++) {
+		pv1 = indata[i];
+		pv2 = P1Key[i];
+		Tmp[pv2] = pv1;
+	}
+	for (i=0; i<8; i++) {
+		pv1 = Tmp[i];
+		pv2 = T1Key[pv1];
+		indata[i] = pv2;
+	}
+	return 0;
+}
+
+static int8_t Via26Decrypt(uint8_t* source, uint8_t* dw, uint32_t ident, uint8_t desKeyIndex)
+{
+	uint8_t tmpData[8], C1[8];
+	uint8_t *pXorVector;
+	int32_t i,j;
+
+	if (ident == 0) {
+		return 4;
+	}
+	if(!GetViaKey(C1, ident, 'C', 1, 8, 1)) {
+		return 2;
+	}
+
+	for (i=0; i<2; i++) {
+		memcpy(tmpData, source+ i*8, 8);
+		Via26ProcessDw(tmpData, ident, desKeyIndex);
+		if (i!=0) {
+			pXorVector = source;
+		}
+		else {
+			pXorVector = &C1[0];
+		}
+		for (j=0; j<8; j++) {
+			dw[i*8+j] = tmpData[j]^pXorVector[j];
+		}
+	}
+	return 0;
+}
+
+static void Via3Core(uint8_t *data, uint8_t Off, uint32_t ident, uint8_t* XorKey, uint8_t* T1Key)
+{
+	uint8_t i;
+	uint32_t lR2, lR3, lR4, lR6, lR7;
+
+	switch (ident) {
+	case 0x032820: {
+		for (i=0; i<4; i++) {
+			data[i]^= XorKey[(Off+i) & 0x07];
+		}
+		lR2 = (data[0]^0xBD)+data[0];
+		lR3 = (data[3]^0xEB)+data[3];
+		lR2 = (lR2-lR3)^data[2];
+		lR3 = ((0x39*data[1])<<2);
+		data[4] = (lR2|lR3)+data[2];
+		lR3 = ((((data[0]+6)^data[0]) | (data[2]<<1))^0x65)+data[0];
+		lR2 = (data[1]^0xED)+data[1];
+		lR7 = ((data[3]+0x29)^data[3])*lR2;
+		data[5] = lR7+lR3;
+		lR2 = ((data[2]^0x33)+data[2]) & 0x0A;
+		lR3 = (data[0]+0xAD)^data[0];
+		lR3 = lR3+lR2;
+		lR2 = data[3]*data[3];
+		lR7 = (lR2 | 1) + data[1];
+		data[6] = (lR3|lR7)+data[1];
+		lR3 = data[1] & 0x07;
+		lR2 = (lR3-data[2]) & (data[0] | lR2 |0x01);
+		data[7] = lR2+data[3];
+		for (i=0; i<4; i++) {
+			data[i+4] = T1Key[data[i+4]];
+		}
+	}
+	break;
+	case 0x030B00: {
+		for (i=0; i<4; i++) {
+			data[i]^= XorKey[(Off+i) & 0x07];
+		}
+		lR6 = (data[3] + 0x6E) ^ data[3];
+		lR6 = (lR6*(data[2] << 1)) + 0x17;
+		lR3 = (data[1] + 0x77) ^ data[1];
+		lR4 = (data[0] + 0xD7) ^ data[0];
+		data[4] = ((lR4 & lR3) | lR6) + data[0];
+		lR4 = ((data[3] + 0x71) ^ data[3]) ^ 0x90;
+		lR6 = (data[1] + 0x1B) ^ data[1];
+		lR4 = (lR4*lR6) ^ data[0];
+		data[5] = (lR4 ^ (data[2] << 1)) + data[1];
+		lR3 = (data[3] * data[3])| 0x01;
+		lR4 = (((data[2] ^ 0x35) + data[2]) | lR3) + data[2];
+		lR6 = data[1] ^ (data[0] + 0x4A);
+		data[6] = lR6 + lR4;
+		lR3 = (data[0] * (data[2] << 1)) | data[1];
+		lR4 = 0xFE - data[3];
+		lR3 = lR4 ^ lR3;
+		data[7] = lR3 + data[3];
+		for (i=0; i<4; i++) {
+			data[4+i] = T1Key[data[4+i]];
+		}
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+static void Via3Fct1(uint8_t *data, uint32_t ident, uint8_t* XorKey, uint8_t* T1Key)
+{
+	uint8_t t;
+	Via3Core(data, 0, ident, XorKey, T1Key);
+
+	switch (ident) {
+	case 0x032820: {
+		t = data[4];
+		data[4] = data[7];
+		data[7] = t;
+	}
+	break;
+	case 0x030B00: {
+		t = data[5];
+		data[5] = data[7];
+		data[7] = t;
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+static void Via3Fct2(uint8_t *data, uint32_t ident, uint8_t* XorKey, uint8_t* T1Key)
+{
+	uint8_t t;
+	Via3Core(data, 4, ident, XorKey, T1Key);
+
+	switch (ident) {
+	case 0x032820: {
+		t = data[4];
+		data[4] = data[7];
+		data[7] = data[5];
+		data[5] = data[6];
+		data[6] = t;
+	}
+	break;
+	case 0x030B00: {
+		t = data[6];
+		data[6] = data[7];
+		data[7] = t;
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+static int8_t Via3ProcessDw(uint8_t *data, uint32_t ident, uint8_t desKeyIndex)
+{
+	uint8_t i;
+	uint8_t tmp[8], T1Key[300], P1Key[8], KeyDes[16], XorKey[8];
+	uint32_t ks1[32], ks2[32];
+
+	if(!GetViaKey(T1Key, ident, 'T', 1, 300, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(P1Key, ident, 'P', 1, 8, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(KeyDes, ident, '0', desKeyIndex, 16, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(XorKey, ident, 'X', 1, 8, 1)) {
+		return 2;
+	}
+
+	for (i=0; i<4; i++) {
+		tmp[i] = data[i+4];
+	}
+	Via3Fct1(tmp, ident, XorKey, T1Key);
+	for (i=0; i<4; i++) {
+		tmp[i] = data[i]^tmp[i+4];
+	}
+	Via3Fct2(tmp, ident, XorKey, T1Key);
+	for (i=0; i<4; i++) {
+		tmp[i]^= XorKey[i+4];
+	}
+	for (i=0; i<4; i++) {
+		data[i] = data[i+4]^tmp[i+4];
+		data[i+4] = tmp[i];
+	}
+	
+	des_set_key(KeyDes, ks1);
+	des_set_key(KeyDes+8, ks2);
+	
+	des(data, ks1, 0);
+	des(data, ks2, 1);
+	des(data, ks1, 0);
+	
+	for (i=0; i<4; i++) {
+		tmp[i] = data[i+4];
+	}
+	Via3Fct2(tmp, ident, XorKey, T1Key);
+	for (i=0; i<4; i++) {
+		tmp[i] = data[i]^tmp[i+4];
+	}
+	Via3Fct1(tmp, ident, XorKey, T1Key);
+	for (i=0; i<4; i++) {
+		tmp[i]^= XorKey[i];
+	}
+	for (i=0; i<4; i++) {
+		data[i] = data[i+4]^tmp[i+4];
+		data[i+4] = tmp[i];
+	}
+	return 0;
+}
+
+static void Via3FinalMix(uint8_t *dw)
+{
+	uint8_t tmp[4];
+
+	memcpy(tmp, dw, 4);
+	memcpy(dw, dw + 4, 4);
+	memcpy(dw + 4, tmp, 4);
+
+	memcpy(tmp, dw + 8, 4);
+	memcpy(dw + 8, dw + 12, 4);
+	memcpy(dw + 12, tmp, 4);
+}
+
+static int8_t Via3Decrypt(uint8_t* source, uint8_t* dw, uint32_t ident, uint8_t desKeyIndex, uint8_t aesKeyIndex, uint8_t aesMode, int8_t doFinalMix)
+{
+	int8_t aesAfterCore = 0;
+	int8_t needsAES = (aesKeyIndex != 0xFF);
+	uint8_t tmpData[8], C1[8];
+	uint8_t *pXorVector;
+	char aesKey[16];
+	int32_t i, j;
+
+	if(ident == 0) {
+		return 4;
+	}
+	if(!GetViaKey(C1, ident, 'C', 1, 8, 1)) {
+		return 2;
+	}
+	if(needsAES && !GetViaKey((uint8_t*)aesKey, ident, 'E', aesKeyIndex, 16, 1)) {
+		return 2;
+	}
+	if(aesMode == 0x0D || aesMode == 0x11 || aesMode == 0x15) {
+		aesAfterCore = 1;
+	}
+
+	if(needsAES && !aesAfterCore) {
+		if(aesMode == 0x0F) {
+			hdSurEncPhase1_D2_0F_11(source);
+			hdSurEncPhase2_D2_0F_11(source);
+		}
+		else if(aesMode == 0x13) {
+			hdSurEncPhase1_D2_13_15(source);
+		}
+		struct aes_keys aes;
+		aes_set_key(&aes, aesKey);
+		aes_decrypt(&aes, source, 16);
+		if(aesMode == 0x0F) {
+			hdSurEncPhase1_D2_0F_11(source);
+		}
+		else if(aesMode == 0x13) {
+			hdSurEncPhase2_D2_13_15(source);
+		}
+	}
+
+	for(i=0; i<2; i++) {
+		memcpy(tmpData, source+i*8, 8);
+		Via3ProcessDw(tmpData, ident, desKeyIndex);
+		if (i!=0) {
+			pXorVector = source;
+		}
+		else {
+			pXorVector = &C1[0];
+		}
+		for (j=0; j<8; j++) {
+			dw[i*8+j] = tmpData[j]^pXorVector[j];
+		}
+	}
+
+	if(needsAES && aesAfterCore) {
+		if(aesMode == 0x11) {
+			hdSurEncPhase1_D2_0F_11(dw);
+			hdSurEncPhase2_D2_0F_11(dw);
+		}
+		else if(aesMode == 0x15) {
+			hdSurEncPhase1_D2_13_15(dw);
+		}
+		struct aes_keys aes;
+		aes_set_key(&aes, aesKey);
+		aes_decrypt(&aes, dw, 16);
+		if(aesMode == 0x11) {
+			hdSurEncPhase1_D2_0F_11(dw);
+		}
+		if(aesMode == 0x15) {
+			hdSurEncPhase2_D2_13_15(dw);
+		}
+	}
+
+	if(ident == 0x030B00) {
+		if(doFinalMix) {
+			Via3FinalMix(dw);
+		}
+		if (!isValidDCW(dw) || !isValidDCW(dw + 8))
+		{
+			return 6;
+		}
+	}
+	return 0;
+}
+
+int8_t ViaccessECM(uint8_t *ecm, uint8_t *dw)
+{
+	uint32_t currentIdent = 0;
+	uint8_t nanoCmd = 0, nanoLen = 0, version = 0, providerKeyLen = 0, desKeyIndex = 0, aesMode = 0, aesKeyIndex = 0xFF;
+	int8_t doFinalMix = 0, result = 1;
+	uint16_t i = 0, keySelectPos = 0, ecmLen = GetEcmLen(ecm);
+
+	for (i=4; i+2<ecmLen; ) {
+		nanoCmd = ecm[i++];
+		nanoLen = ecm[i++];
+		if(i+nanoLen > ecmLen) {
+			return 1;
+		}
+
+		switch (nanoCmd) {
+		case 0x40:
+			if (nanoLen < 0x03) {
+				break;
+			}
+			version = ecm[i];
+			if (nanoLen == 3) {
+				currentIdent = ((ecm[i]<<16)|(ecm[i+1]<<8))|(ecm[i+2]&0xF0);
+				desKeyIndex  = ecm[i+2]&0x0F;
+				keySelectPos = i+3;
+			}
+			else {
+				currentIdent = (ecm[i]<<16)|(ecm[i+1]<<8)|((ecm[i+2]>>4)&0x0F);
+				desKeyIndex  = ecm[i+3];
+				keySelectPos = i+4;
+			}
+			providerKeyLen = nanoLen;
+			break;
+		case 0x90:
+			if (nanoLen < 0x03) {
+				break;
+			}
+			version = ecm[i];
+			currentIdent = ((ecm[i]<<16)|(ecm[i+1]<<8))|(ecm[i+2]&0xF0);
+			desKeyIndex  = ecm[i+2]&0x0F;
+			keySelectPos = i+4;
+			if((version == 3) && (nanoLen > 3)) {
+				desKeyIndex = ecm[i+(nanoLen-4)]&0x0F;
+			}
+			providerKeyLen = nanoLen;
+			break;
+		case 0x80:
+			nanoLen = 0;
+			break;
+		case 0xD2:
+			if (nanoLen < 0x02) {
+				break;
+			}
+			aesMode = ecm[i];
+			aesKeyIndex = ecm[i+1];
+			break;
+		case 0xDD:
+			nanoLen = 0;
+			break;
+		case 0xEA:
+			if (nanoLen < 0x10) {
+				break;
+			}
+
+			if (version < 2) {
+				return Via1Decrypt(ecm, dw, currentIdent, desKeyIndex);
+			}
+			else if (version == 2) {
+				return Via26Decrypt(ecm + i, dw, currentIdent, desKeyIndex);
+			}
+			else if (version == 3) {
+				doFinalMix = 0;
+				if (currentIdent == 0x030B00 && providerKeyLen>3) {
+					if(keySelectPos+2 >= ecmLen) {
+						break;
+					}
+					if (ecm[keySelectPos] == 0x05 && ecm[keySelectPos+1] == 0x67 && (ecm[keySelectPos+2] == 0x00 || ecm[keySelectPos+2] == 0x01)) {
+						if(ecm[keySelectPos+2] == 0x01) {
+							doFinalMix = 1;
+						}
+					}
+					else {
+						break;
+					}
+				}
+				return Via3Decrypt(ecm + i, dw, currentIdent, desKeyIndex, aesKeyIndex, aesMode, doFinalMix);
+			}
+			break;
+		default:
+			break;
+		}
+		i += nanoLen;
+	}
+	return result;
+}
+
+// Viaccess EMM EMU
+int8_t ViaccessEMM(uint8_t *emm, uint32_t *keysAdded)
+{
+	uint8_t nanoCmd = 0, subNanoCmd = 0, *tmp;
+	uint16_t i = 0, j = 0, k = 0, emmLen = GetEcmLen(emm);
+	uint8_t ecmKeys[6][16], keyD0[2], emmKey[16], emmXorKey[16], provName[17];
+	uint8_t ecmKeyCount = 0, emmKeyIndex = 0, aesMode = 0x0D;
+	uint8_t nanoLen = 0, subNanoLen = 0, haveEmmXorKey = 0, haveNewD0 = 0;
+	uint32_t ui1, ui2, ui3, ecmKeyIndex[6], provider = 0, ecmProvider = 0;
+	char keyName[EMU_MAX_CHAR_KEYNAME], keyValue[36];
+	struct aes_keys aes;
+
+	memset(keyD0, 0, 2);
+	memset(ecmKeyIndex, 0, sizeof(uint32_t)*6);
+
+	for(i=3; i+2<emmLen; ) {
+		nanoCmd = emm[i++];
+		nanoLen = emm[i++];
+		if(i+nanoLen > emmLen) {
+			return 1;
+		}
+
+		switch(nanoCmd) {
+		case 0x90: {
+			if(nanoLen < 3) {
+				break;
+			}
+			ui1 = emm[i+2];
+			ui2 = emm[i+1];
+			ui3 = emm[i];
+			provider = (ui1 | (ui2 << 8) | (ui3 << 16));
+			if(provider == 0x00D00040) {
+				ecmProvider = 0x030B00;
+			}
+			else {
+				return 1;
+			}
+			break;
+		}
+		case 0xD2: {
+			if(nanoLen < 2) {
+				break;
+			}
+			emmKeyIndex = emm[i+1];
+			break;
+		}
+		case 0x41: {
+			if(nanoLen < 1) {
+				break;
+			}
+			if(!GetViaKey(emmKey, provider, 'M', emmKeyIndex, 16, 1)) {
+				return 2;
+			}
+			memset(provName, 0, 17);
+			memset(emmXorKey, 0, 16);
+			k = nanoLen < 16 ? nanoLen : 16;
+			memcpy(provName, &emm[i], k);
+			aes_set_key(&aes, (char*)emmKey);
+			aes_decrypt(&aes, emmXorKey, 16);
+			for(j=0; j<16; j++) {
+				provName[j] ^= emmXorKey[j];
+			}
+			provName[k] = 0;
+
+			if(strcmp((char*)provName, "TNTSAT") != 0 && strcmp((char*)provName, "TNTSATPRO") != 0
+					&&strcmp((char*)provName, "CSAT V") != 0) {
+				return 1;
+			}
+			break;
+		}
+		case 0xBA: {
+			if(nanoLen < 2) {
+				break;
+			}
+			GetViaKey(keyD0, ecmProvider, 'D', 0, 2, 0);
+			ui1 = (emm[i] << 8) | emm[i+1];
+			if( (uint32_t)((keyD0[0] << 8) | keyD0[1]) < ui1 || (keyD0[0] == 0x00 && keyD0[1] == 0x00)) {
+				keyD0[0] = emm[i];
+				keyD0[1] = emm[i+1];
+				haveNewD0 = 1;
+				break;
+			}
+			return 0;
+		}
+		case 0xBC: {
+			break;
+		}
+		case 0x43: {
+			if(nanoLen < 16) {
+				break;
+			}
+			memcpy(emmXorKey, &emm[i], 16);
+			haveEmmXorKey = 1;
+			break;
+		}
+		case 0x44: {
+			if(nanoLen < 3) {
+				break;
+			}
+			if (!haveEmmXorKey) {
+				memset(emmXorKey, 0, 16);
+			}
+			tmp = (uint8_t*)malloc(((nanoLen/16)+1)*16*sizeof(uint8_t));
+			if(tmp == NULL) {
+				return 7;
+			}
+			memcpy(tmp, &emm[i], nanoLen);
+			aes_set_key(&aes, (char*)emmKey);
+			for(j=0; j<nanoLen; j+=16) {
+				aes_decrypt(&aes, emmXorKey, 16);
+				for(k=0; k<16; k++) {
+					tmp[j+k] ^= emmXorKey[k];
+				}
+			}
+			memcpy(&emm[i-2], tmp, nanoLen);
+			free(tmp);
+			nanoLen = 0;
+			i -= 2;
+			break;
+		}
+		case 0x68: {
+			if(ecmKeyCount > 5) {
+				break;
+			}
+			for(j=i; j+2<i+nanoLen; ) {
+				subNanoCmd = emm[j++];
+				subNanoLen = emm[j++];
+				if(j+subNanoLen > i+nanoLen) {
+					break;
+				}
+				switch(subNanoCmd) {
+				case 0xD2: {
+					if(nanoLen < 2) {
+						break;
+					}
+					aesMode = emm[j];
+					emmKeyIndex = emm[j+1];
+					break;
+				}
+				case 0x01: {
+					if(nanoLen < 17) {
+						break;
+					}
+					ecmKeyIndex[ecmKeyCount] = emm[j];
+					memcpy(&ecmKeys[ecmKeyCount], &emm[j+1], 16);
+					if(!GetViaKey(emmKey, provider, 'M', emmKeyIndex, 16, 1)) {
+						break;
+					}
+
+					if(aesMode == 0x0F || aesMode == 0x11) {
+						hdSurEncPhase1_D2_0F_11(ecmKeys[ecmKeyCount]);
+						hdSurEncPhase2_D2_0F_11(ecmKeys[ecmKeyCount]);
+					}
+					else if(aesMode == 0x13 || aesMode == 0x15) {
+						hdSurEncPhase1_D2_13_15(ecmKeys[ecmKeyCount]);
+					}
+					aes_set_key(&aes, (char*)emmKey);
+					aes_decrypt(&aes, ecmKeys[ecmKeyCount], 16);
+					if(aesMode == 0x0F || aesMode == 0x11) {
+						hdSurEncPhase1_D2_0F_11(ecmKeys[ecmKeyCount]);
+					}
+					else if(aesMode == 0x13 || aesMode == 0x15) {
+						hdSurEncPhase2_D2_13_15(ecmKeys[ecmKeyCount]);
+					}
+
+					ecmKeyCount++;
+					break;
+				}
+				default:
+					break;
+				}
+				j += subNanoLen;
+			}
+			break;
+		}
+		case 0xF0: {
+			if(nanoLen != 4) {
+				break;
+			}
+			ui1 = ((emm[i+2] << 8) | (emm[i+1] << 16) | (emm[i] << 24) | emm[i+3]);
+			if(fletcher_crc32(emm + 3, emmLen - 11) != ui1) {
+				return 4;
+			}
+
+			if(haveNewD0) {
+				
+				SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+				SetKey('V', ecmProvider, "D0", keyD0, 2, 1, NULL, NULL);
+				
+				for(j=0; j<ecmKeyCount; j++) {
+					
+					snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "E%X", ecmKeyIndex[j]);
+					SetKey('V', ecmProvider, keyName, ecmKeys[j], 16, 1, NULL, NULL);
+					
+					(*keysAdded)++;
+					cs_hexdump(0, ecmKeys[j], 16, keyValue, sizeof(keyValue));
+					cs_log("Key found in EMM: V %06X %s %s", ecmProvider, keyName, keyValue);
+				}
+
+				SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+			}
+			break;
+		}
+		default:
+			break;
+		}
+		i += nanoLen;
+	}
+	return 0;
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-viaccess.h b/module-emulator-viaccess.h
new file mode 100644
index 0000000..80f629d
--- /dev/null
+++ b/module-emulator-viaccess.h
@@ -0,0 +1,11 @@
+#ifndef MODULE_EMULATOR_VIACCESS_H
+#define MODULE_EMULATOR_VIACCESS_H
+
+#ifdef WITH_EMU
+
+int8_t ViaccessECM(uint8_t *ecm, uint8_t *dw);
+int8_t ViaccessEMM(uint8_t *emm, uint32_t *keysAdded);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_VIACCESS_H
diff --git a/module-emulator-videoguard.c b/module-emulator-videoguard.c
new file mode 100644
index 0000000..652c08e
--- /dev/null
+++ b/module-emulator-videoguard.c
@@ -0,0 +1,100 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "cscrypt/md5.h"
+#include "module-emulator-osemu.h"
+
+// VideoGuard (aka NDS) emulator
+
+static const uint8_t nds_const[] = { 0x0F, 0x1E, 0x2D, 0x3C, 0x4B, 0x5A, 0x69, 0x78,
+									 0x87, 0x96, 0xA5, 0xB4, 0xC3, 0xD2, 0xE1, 0xF0 };
+
+uint8_t viasat_const[] = { 0x15, 0x85, 0xC5, 0xE4, 0xB8, 0x52, 0xEC, 0xF7,
+						   0xC3, 0xD9, 0x08, 0xBA, 0x22, 0x4A, 0x66, 0xF2,
+						   0x82, 0x15, 0x4F, 0xB2, 0x18, 0x48, 0x63, 0x97,
+						   0xDC, 0x19, 0xD8, 0x51, 0x9A, 0x39, 0xFC, 0xCA,
+						   0x1C, 0x24, 0xD0, 0x65, 0xA9, 0x66, 0x2D, 0xD6,
+						   0x53, 0x3B, 0x86, 0xBA, 0x40, 0xEA, 0x4C, 0x6D,
+						   0xD9, 0x1E, 0x41, 0x14, 0xFE, 0x15, 0xAF, 0xC3,
+						   0x18, 0xC5, 0xF8, 0xA7, 0xA8, 0x01, 0x00, 0x01 };
+
+int8_t SoftNDSECM(uint16_t caid, uint8_t *ecm, uint8_t *dw)
+{
+	int32_t i;
+	uint8_t *tDW, irdEcmLen, offsetCw = 0, offsetP2 = 0;
+	uint8_t digest[16], md5_const[64];
+	MD5_CTX mdContext;
+	uint16_t ecmLen = GetEcmLen(ecm);
+
+	if (ecmLen < 7)
+	{
+		return 1;
+	}
+
+	if (ecm[3] != 0x00 || ecm[4] != 0x00 || ecm[5] != 0x01)
+	{
+		return 1;
+	}
+
+	irdEcmLen = ecm[6];
+
+	if (irdEcmLen < (10 + 3 + 8 + 4) || irdEcmLen + 6 >= ecmLen)
+	{
+		return 1;
+	}
+
+	for (i = 0; 10 + i + 2 < irdEcmLen; i++)
+	{
+		if (ecm[17 + i] == 0x0F && ecm[17 + i + 1] == 0x40 && ecm[17 + i + 2] == 0x00)
+		{
+			offsetCw = 17 + i + 3;
+			offsetP2 = offsetCw + 9;
+		}
+	}
+
+	if (offsetCw == 0 || offsetP2 == 0)
+	{
+		return 1;
+	}
+
+	if (offsetP2 - 7 + 4 > irdEcmLen)
+	{
+		return 1;
+	}
+
+	if (caid == 0x090F || caid == 0x093E)
+	{
+		memcpy(md5_const, viasat_const, 64);
+	}
+	else if (!FindKey('S', caid, 0, "00", md5_const, 64, 1, 0, 0, NULL))
+	{
+		return 2;
+	}
+
+	memset(dw,0,16);
+	tDW = &dw[ecm[0] == 0x81 ? 8 : 0];
+
+	MD5_Init(&mdContext);
+	MD5_Update(&mdContext, ecm + 7, 10);
+	MD5_Update(&mdContext, ecm + offsetP2, 4);
+	MD5_Update(&mdContext, md5_const, 64);
+	MD5_Update(&mdContext, nds_const, 16);
+	MD5_Final(digest, &mdContext);
+
+	for (i = 0; i < 8; i++)
+	{
+		tDW[i] = digest[i + 8] ^ ecm[offsetCw + i];
+	}
+
+	if (!isValidDCW(tDW))
+	{
+		return 6;
+	}
+
+	return 0;
+}
+
+#endif // WITH_EMU
diff --git a/module-emulator-videoguard.h b/module-emulator-videoguard.h
new file mode 100644
index 0000000..72401bc
--- /dev/null
+++ b/module-emulator-videoguard.h
@@ -0,0 +1,10 @@
+#ifndef MODULE_EMULATOR_VIDEOGUARD_H
+#define MODULE_EMULATOR_VIDEOGUARD_H
+
+#ifdef WITH_EMU
+
+int8_t SoftNDSECM(uint16_t caid, uint8_t *ecm, uint8_t *dw);
+
+#endif // WITH_EMU
+
+#endif // MODULE_EMULATOR_VIDEOGUARD_H
diff --git a/module-emulator.c b/module-emulator.c
new file mode 100644
index 0000000..a618a5b
--- /dev/null
+++ b/module-emulator.c
@@ -0,0 +1,974 @@
+#define MODULE_LOG_PREFIX "emu"
+
+#include "globals.h"
+
+#ifdef WITH_EMU
+
+#include "module-emulator-osemu.h"
+#include "module-emulator-streamserver.h"
+#include "module-emulator-drecrypt.h"
+#include "module-emulator-irdeto.h"
+#include "module-emulator-powervu.h"
+#include "oscam-conf-chk.h"
+#include "oscam-config.h"
+#include "oscam-reader.h"
+#include "oscam-string.h"
+
+/*
+ * Readers in OSCam consist of 2 basic parts.
+ * The hardware or the device part. This is where physical smart cards are inserted
+ * and made available to OSCam.
+ * The software or the emulation part. This is where the actual card reading is done,
+ * including ecm and emm processing (i.e emulation of the various cryptosystems).
+ * In the Emu reader, the device part has no meaning, but we have to create it in
+ * order to be compatible with OSCam's reader structure.
+*/
+
+/*
+ * Create the Emu "emulation" part. This is of type s_cardsystem.
+ * Similar structures are found in the main sources folder (files reader-xxxxxx.c)
+ * for every cryptosystem supported by OSCam.
+ * Here we read keys from our virtual card (aka the SoftCam.Key file) and we inform
+ * OSCam about them. This is done with the emu_card_info() function. Keep in mind
+ * that Emu holds all its keys to separate structures for faster access.
+ * In addition, ECM and EMM requests are processed here, with the emu_do_ecm() and
+ * emu_do_emm() functions.
+*/
+
+#define CS_OK     1
+#define CS_ERROR  0
+
+extern char cs_confdir[128];
+static int8_t emu_key_data_mutex_init = 0;
+pthread_mutex_t emu_key_data_mutex;
+
+// Version info
+
+static inline uint32_t GetOSemuVersion(void)
+{
+	return atoi("$Version: 785 $" + 10);
+}
+
+static void set_hexserial_to_version(struct s_reader *rdr)
+{
+	char cVersion[32];
+	uint32_t version = GetOSemuVersion();
+	uint8_t hversion[2];
+	memset(hversion, 0, 2);
+	snprintf(cVersion, sizeof(cVersion), "%04d", version);
+	CharToBin(hversion, cVersion, 4);
+	rdr->hexserial[3] = hversion[0];
+	rdr->hexserial[4] = hversion[1];
+}
+
+static void set_prids(struct s_reader *rdr)
+{
+	int32_t i, j;
+
+	rdr->nprov = 0;
+
+	for (i = 0; (i < rdr->emu_auproviders.nfilts) && (rdr->nprov < CS_MAXPROV); i++)
+	{
+		for (j = 0; (j < rdr->emu_auproviders.filts[i].nprids) && (rdr->nprov < CS_MAXPROV); j++)
+		{
+			i2b_buf(4, rdr->emu_auproviders.filts[i].prids[j], rdr->prid[i]);
+			rdr->nprov++;
+		}
+	}
+}
+
+static void emu_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint8_t *key, char *keyName, uint32_t keyLength, uint8_t isData)
+{
+	if (!rdr->ll_entitlements)
+	{
+		rdr->ll_entitlements = ll_create("ll_entitlements");
+	}
+
+	S_ENTITLEMENT *item;
+	if (cs_malloc(&item, sizeof(S_ENTITLEMENT)))
+	{
+		// fill item
+		item->caid = caid;
+		item->provid = provid;
+		item->id = 0;
+		item->class = 0;
+		item->start = 0;
+		item->end = 2147472000;
+		item->type = 0;
+		item->isKey = 1;
+		memcpy(item->name, keyName, 8);
+		item->key = key;
+		item->keyLength = keyLength;
+		item->isData = isData;
+
+		// add item
+		ll_append(rdr->ll_entitlements, item);
+	}
+}
+
+static void refresh_entitlements(struct s_reader *rdr)
+{
+	uint32_t i;
+	KeyData *tmpKeyData;
+
+	cs_clear_entitlement(rdr);
+
+	for (i = 0; i < ViKeys.keyCount; i++)
+	{
+		emu_add_entitlement(rdr, 0x0500, ViKeys.EmuKeys[i].provider, ViKeys.EmuKeys[i].key,
+							ViKeys.EmuKeys[i].keyName, ViKeys.EmuKeys[i].keyLength, 0);
+	}
+
+	for (i = 0; i < IrdetoKeys.keyCount; i++)
+	{
+		tmpKeyData = &IrdetoKeys.EmuKeys[i];
+		do
+		{
+			emu_add_entitlement(rdr, tmpKeyData->provider >> 8, tmpKeyData->provider & 0xFF,
+								tmpKeyData->key, tmpKeyData->keyName, tmpKeyData->keyLength, 0);
+
+			tmpKeyData = tmpKeyData->nextKey;
+		}
+		while (tmpKeyData != NULL);
+	}
+
+	for (i = 0; i < NDSKeys.keyCount; i++)
+	{
+		emu_add_entitlement(rdr, NDSKeys.EmuKeys[i].provider, 0, NDSKeys.EmuKeys[i].key,
+							NDSKeys.EmuKeys[i].keyName, NDSKeys.EmuKeys[i].keyLength, 0);
+	}
+
+	emu_add_entitlement(rdr, 0x090F, 0, viasat_const, "00", 64, 1);
+	emu_add_entitlement(rdr, 0x093E, 0, viasat_const, "00", 64, 1);
+
+	for (i = 0; i < CwKeys.keyCount; i++)
+	{
+		emu_add_entitlement(rdr, CwKeys.EmuKeys[i].provider >> 8, CwKeys.EmuKeys[i].provider & 0xFF,
+							CwKeys.EmuKeys[i].key, CwKeys.EmuKeys[i].keyName, CwKeys.EmuKeys[i].keyLength, 0);
+	}
+
+	for (i = 0; i < PowervuKeys.keyCount; i++)
+	{
+		emu_add_entitlement(rdr, 0x0E00, PowervuKeys.EmuKeys[i].provider, PowervuKeys.EmuKeys[i].key,
+							PowervuKeys.EmuKeys[i].keyName, PowervuKeys.EmuKeys[i].keyLength, 0);
+	}
+
+	for (i = 0; i < TandbergKeys.keyCount; i++)
+	{
+		emu_add_entitlement(rdr, 0x1010, TandbergKeys.EmuKeys[i].provider, TandbergKeys.EmuKeys[i].key,
+							TandbergKeys.EmuKeys[i].keyName, TandbergKeys.EmuKeys[i].keyLength, 0);
+	}
+
+	for (i = 0; i < NagraKeys.keyCount; i++)
+	{
+		emu_add_entitlement(rdr, 0x1801, NagraKeys.EmuKeys[i].provider, NagraKeys.EmuKeys[i].key,
+							NagraKeys.EmuKeys[i].keyName, NagraKeys.EmuKeys[i].keyLength, 0);
+	}
+
+	for (i = 0; i < BissKeys.keyCount; i++)
+	{
+		emu_add_entitlement(rdr, 0x2600, BissKeys.EmuKeys[i].provider, BissKeys.EmuKeys[i].key,
+							BissKeys.EmuKeys[i].keyName, BissKeys.EmuKeys[i].keyLength, 0);
+	}
+
+	for (i = 0; i < DreKeys.keyCount; i++)
+	{
+		emu_add_entitlement(rdr, 0x4AE1, DreKeys.EmuKeys[i].provider, DreKeys.EmuKeys[i].key,
+							DreKeys.EmuKeys[i].keyName, DreKeys.EmuKeys[i].keyLength, 0);
+	}
+}
+
+static int32_t emu_do_ecm(struct s_reader *rdr, const ECM_REQUEST *er, struct s_ecm_answer *ea)
+{
+
+	if (!ProcessECM(rdr, er->ecmlen, er->caid, er->prid, er->ecm, ea->cw, er->srvid, er->pid, &ea->cw_ex))
+	{
+		return CS_OK;
+	}
+
+	return CS_ERROR;
+}
+
+static int32_t emu_do_emm(struct s_reader *rdr, EMM_PACKET *emm)
+{
+	uint32_t keysAdded = 0;
+
+	if (emm->emmlen < 3)
+	{
+		return CS_ERROR;
+	}
+
+	if (SCT_LEN(emm->emm) > emm->emmlen)
+	{
+		return CS_ERROR;
+	}
+
+	if (!ProcessEMM(rdr, b2i(2, emm->caid), b2i(4, emm->provid), emm->emm, &keysAdded))
+	{
+		if (keysAdded > 0)
+		{
+			refresh_entitlements(rdr);
+		}
+
+		return CS_OK;
+	}
+
+	return CS_ERROR;
+}
+
+static int32_t emu_card_info(struct s_reader *rdr)
+{
+	SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+
+	// Delete keys from Emu's memory
+	clear_emu_keydata();
+
+	// Read keys built in the OSCam-Emu binary
+#if !defined(__APPLE__) && !defined(__ANDROID__)
+	read_emu_keymemory(rdr);
+#endif
+
+	// Read keys from SoftCam.Key file
+	set_emu_keyfile_path(cs_confdir);
+
+	if (!read_emu_keyfile(rdr, cs_confdir))
+	{
+		if (read_emu_keyfile(rdr, "/var/keys/"))
+		{
+			set_emu_keyfile_path("/var/keys/");
+		}
+	}
+
+	// Load keys from external files (set via the webif or the reader config directly)
+	read_emu_eebin(rdr->extee36, "ee36.bin");           // Read "ee36.bin"
+	read_emu_eebin(rdr->extee56, "ee56.bin");           // Read "ee56.bin"
+	read_emu_deskey(rdr->des_key, rdr->des_key_length); // Read overcrypt keys for DreCrypt ADEC
+
+	cs_log("Total keys in memory: W:%d V:%d N:%d I:%d S:%d F:%d P:%d D:%d T:%d", \
+					CwKeys.keyCount, ViKeys.keyCount, NagraKeys.keyCount, \
+					IrdetoKeys.keyCount, NDSKeys.keyCount, BissKeys.keyCount, \
+					PowervuKeys.keyCount, DreKeys.keyCount, TandbergKeys.keyCount);
+
+	// Inform OSCam about all available keys.
+	// This is used for listing the "entitlements" in the webif's reader page.
+	refresh_entitlements(rdr);
+
+	SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+
+	set_prids(rdr);
+
+	set_hexserial_to_version(rdr);
+
+	return CS_OK;
+}
+
+/*
+static int32_t emu_card_init(struct s_reader *UNUSED(rdr), struct s_ATR *UNUSED(atr))
+{
+	return CS_ERROR;
+}
+*/
+
+int32_t emu_get_via3_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
+{
+	uint32_t provid = 0;
+
+	if(ep->emm[3] == 0x90 && ep->emm[4] == 0x03)
+	{
+		provid = b2i(3, ep->emm+5);
+		provid &=0xFFFFF0;
+		i2b_buf(4, provid, ep->provid);
+	}
+
+	switch(ep->emm[0])
+	{
+	case 0x88:
+		ep->type = UNIQUE;
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 4, 4);
+		rdr_log_dbg(rdr, D_EMM, "UNIQUE");
+		return 1;
+
+	case 0x8A:
+	case 0x8B:
+		ep->type = GLOBAL;
+		rdr_log_dbg(rdr, D_EMM, "GLOBAL");
+		return 1;
+
+	case 0x8C:
+	case 0x8D:
+		ep->type = SHARED;
+		rdr_log_dbg(rdr, D_EMM, "SHARED (part)");
+		// We need those packets to pass otherwise we would never
+		// be able to complete EMM reassembly
+		return 1;
+
+	case 0x8E:
+		ep->type = SHARED;
+		rdr_log_dbg(rdr, D_EMM, "SHARED");
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 3, 3);
+		return 1;
+
+	default:
+		ep->type = UNKNOWN;
+		rdr_log_dbg(rdr, D_EMM, "UNKNOWN");
+		return 1;
+	}
+}
+
+int32_t emu_get_ird2_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
+{
+	int32_t l = (ep->emm[3] & 0x07);
+	int32_t base = (ep->emm[3] >> 3);
+	char dumprdrserial[l * 3], dumpemmserial[l * 3];
+
+	switch(l)
+	{
+
+	case 0:
+		// global emm, 0 bytes addressed
+		ep->type = GLOBAL;
+		rdr_log_dbg(rdr, D_EMM, "GLOBAL base = %02x", base);
+		return 1;
+
+	case 2:
+		// shared emm, 2 bytes addressed
+		ep->type = SHARED;
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 4, l);
+		cs_hexdump(1, rdr->hexserial, l, dumprdrserial, sizeof(dumprdrserial));
+		cs_hexdump(1, ep->hexserial, l, dumpemmserial, sizeof(dumpemmserial));
+		rdr_log_dbg_sensitive(rdr, D_EMM, "SHARED l = %d ep = {%s} rdr = {%s} base = %02x", l,
+								 dumpemmserial, dumprdrserial, base);
+		return 1;
+
+	case 3:
+		// unique emm, 3 bytes addressed
+		ep->type = UNIQUE;
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 4, l);
+		cs_hexdump(1, rdr->hexserial, l, dumprdrserial, sizeof(dumprdrserial));
+		cs_hexdump(1, ep->hexserial, l, dumpemmserial, sizeof(dumpemmserial));
+		rdr_log_dbg_sensitive(rdr, D_EMM, "UNIQUE l = %d ep = {%s} rdr = {%s} base = %02x", l,
+								 dumpemmserial, dumprdrserial, base);
+		return 1;
+
+	default:
+		ep->type = UNKNOWN;
+		rdr_log_dbg(rdr, D_EMM, "UNKNOWN");
+		return 1;
+	}
+}
+
+int32_t emu_get_pvu_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
+{
+	if(ep->emm[0] == 0x82)
+	{
+		ep->type = UNIQUE;
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 12, 4);
+	}
+	else
+	{
+		ep->type = UNKNOWN;
+		rdr_log_dbg(rdr, D_EMM, "UNKNOWN");
+	}
+	return 1;
+}
+
+int32_t emu_get_dre2_emm_type(EMM_PACKET *ep, struct s_reader *UNUSED(rdr))
+{
+	switch (ep->emm[0])
+	{
+		case 0x82:
+			ep->type = GLOBAL;
+			return 1;
+
+		case 0x86:
+			ep->type = SHARED;
+			memset(ep->hexserial, 0, 8);
+			ep->hexserial[0] = ep->emm[3];
+			return 1;
+
+		//case 0x87:
+		//	ep->type = UNIQUE;
+		//	return 1; //FIXME: no filling of ep->hexserial
+
+		case 0x88:
+			ep->type = UNIQUE;
+			return 1; //FIXME: no filling of ep->hexserial
+
+		case 0x91:
+			ep->type = GLOBAL;
+			return 1;
+
+		default:
+			ep->type = UNKNOWN;
+			return 1;
+	}
+}
+
+int32_t emu_get_tan_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
+{
+	if(ep->emm[0] == 0x82 || ep->emm[0] == 0x83)
+	{
+		ep->type = GLOBAL;
+	}
+	else
+	{
+		ep->type = UNKNOWN;
+		rdr_log_dbg(rdr, D_EMM, "UNKNOWN");
+	}
+	return 1;
+}
+
+int32_t emu_get_biss_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
+{
+	switch (ep->emm[0])
+	{
+		case 0x81: // Spec say this is for EMM, but oscam (and all other crypto systems) use it for ECM
+		case 0x82:
+		case 0x83:
+		case 0x84:
+		case 0x85:
+		case 0x86:
+		case 0x87:
+		case 0x88:
+		case 0x89:
+		case 0x8A:
+		case 0x8B:
+		case 0x8C:
+		case 0x8D:
+		case 0x8E:
+		case 0x8F:
+			ep->type = GLOBAL;
+			return 1;
+
+		default:
+			ep->type = UNKNOWN;
+			rdr_log_dbg(rdr, D_EMM, "UNKNOWN");
+			return 1;
+	}
+}
+
+static int32_t emu_get_emm_type(struct emm_packet_t *ep, struct s_reader *rdr)
+{
+	uint16_t caid = b2i(2, ep->caid);
+
+	if (caid_is_viaccess(caid))     return emu_get_via3_emm_type(ep, rdr);
+	if (caid_is_irdeto(caid))       return emu_get_ird2_emm_type(ep, rdr);
+	if (caid_is_powervu(caid))      return emu_get_pvu_emm_type(ep, rdr);
+	if (caid_is_director(caid))     return emu_get_tan_emm_type(ep, rdr);
+	if (caid_is_biss_dynamic(caid)) return emu_get_biss_emm_type(ep, rdr);
+	if (caid_is_dre(caid))          return emu_get_dre2_emm_type(ep, rdr);
+
+	return CS_ERROR;
+}
+
+FILTER* get_emu_prids_for_caid(struct s_reader *rdr, uint16_t caid)
+{
+	int32_t i;
+
+	for(i = 0; i < rdr->emu_auproviders.nfilts; i++)
+	{
+		if(caid == rdr->emu_auproviders.filts[i].caid)
+		{
+			return &rdr->emu_auproviders.filts[i];
+		}
+	}
+
+	return NULL;
+}
+
+static int32_t emu_get_via3_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t UNUSED(caid), uint32_t UNUSED(provid))
+{
+	if(*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = 1;
+
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		int32_t idx = 0;
+
+		filters[idx].type = EMM_GLOBAL;
+		filters[idx].enabled   = 1;
+		filters[idx].filter[0] = 0x8A;
+		filters[idx].mask[0]   = 0xFE;
+		filters[idx].filter[3] = 0x80;
+		filters[idx].mask[3]   = 0x80;
+		idx++;
+
+		*filter_count = idx;
+	}
+
+	return CS_OK;
+}
+
+static int32_t emu_get_ird2_emm_filter(struct s_reader* rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t caid, uint32_t UNUSED(provid))
+{
+	uint8_t hexserial[3], prid[4];
+	FILTER* emu_provids;
+	int8_t have_provid = 0, have_serial = 0;
+	int32_t i;
+
+	SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+	if(GetIrdeto2Hexserial(caid, hexserial))
+		{ have_serial = 1; }
+	SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+
+	emu_provids = get_emu_prids_for_caid(rdr, caid);
+	if(emu_provids != NULL && emu_provids->nprids > 0)
+		{ have_provid = 1; }
+
+	if(*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = have_serial + (2*(have_provid ? emu_provids->nprids : 0));
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		unsigned int idx = 0;
+
+		if(have_serial)
+		{
+			filters[idx].type = EMM_UNIQUE;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].mask[0]   = 0xFF;
+			filters[idx].filter[1] = 0xFB;
+			filters[idx].mask[1]   = 0x07;
+			memcpy(&filters[idx].filter[2], hexserial, 3);
+			memset(&filters[idx].mask[2], 0xFF, 3);
+			idx++;
+		}
+
+		for(i=0; have_provid && i<emu_provids->nprids; i++)
+		{
+			i2b_buf(4, emu_provids->prids[i], prid);
+
+			filters[idx].type = EMM_UNIQUE;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].mask[0]   = 0xFF;
+			filters[idx].filter[1] = 0xFB;
+			filters[idx].mask[1]   = 0x07;
+			memcpy(&filters[idx].filter[2], &prid[1], 3);
+			memset(&filters[idx].mask[2], 0xFF, 3);
+			idx++;
+
+			filters[idx].type = EMM_SHARED;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].mask[0]   = 0xFF;
+			filters[idx].filter[1] = 0xFA;
+			filters[idx].mask[1]   = 0x07;
+			memcpy(&filters[idx].filter[2], &prid[1], 2);
+			memset(&filters[idx].mask[2], 0xFF, 2);
+			idx++;
+		}
+
+		*filter_count = idx;
+	}
+
+	return CS_OK;
+}
+
+static int32_t emu_get_pvu_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t UNUSED(caid), uint32_t UNUSED(provid), uint16_t srvid)
+{
+	uint8_t hexserials[32][4];
+	uint32_t i, count = 0;
+
+	SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+	if(!PowervuGetHexserials(srvid, hexserials, 32, &count))
+		{ return CS_ERROR; }
+	SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+
+	if(*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = count;
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		int32_t idx = 0;
+
+		for(i=0; i<count; i++)
+		{
+			filters[idx].type = EMM_UNIQUE;
+			filters[idx].enabled    = 1;
+			filters[idx].filter[0]  = 0x82;
+			filters[idx].filter[10] = hexserials[i][0];
+			filters[idx].filter[11] = hexserials[i][1];
+			filters[idx].filter[12] = hexserials[i][2];
+			filters[idx].filter[13] = hexserials[i][3];
+			filters[idx].mask[0]    = 0xFF;
+			filters[idx].mask[10]   = 0xFF;
+			filters[idx].mask[11]   = 0xFF;
+			filters[idx].mask[12]   = 0xFF;
+			filters[idx].mask[13]   = 0xFF;
+			idx++;
+		}
+
+		*filter_count = idx;
+	}
+
+	return CS_OK;
+}
+
+static int32_t emu_get_dre2_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t caid, uint32_t provid)
+{
+	uint8_t hexserials[16];
+	int32_t i, count = 0;
+
+	SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+	if(!GetDrecryptHexserials(caid, provid, hexserials, 16, &count))
+		{ count = 0; }
+	SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+
+	if(*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = 1 + count + 1;
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		int32_t idx = 0;
+
+		if(provid == 0xFE)
+		{
+			filters[idx].type = EMM_GLOBAL;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x91;
+			filters[idx].mask[0]   = 0xFF;
+			idx++;
+		}
+
+		for(i=0; i<count; i++)
+		{
+			filters[idx].type = EMM_SHARED;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x86;
+			filters[idx].filter[1] = hexserials[i];
+			filters[idx].mask[0]   = 0xFF;
+			filters[idx].mask[1]   = 0xFF;
+			idx++;
+		}
+
+		//filters[idx].type = EMM_UNIQUE;
+		//filters[idx].enabled   = 1;
+		//filters[idx].filter[0] = 0x87;
+		//filters[idx].mask[0]   = 0xFF;
+		//idx++;
+
+		filters[idx].type = EMM_UNIQUE;
+		filters[idx].enabled   = 1;
+		filters[idx].filter[0] = 0x88;
+		filters[idx].mask[0]   = 0xFF;
+		idx++;
+
+		*filter_count = idx;
+	}
+
+	return CS_OK;
+}
+
+static int32_t emu_get_tan_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t UNUSED(caid), uint32_t UNUSED(provid))
+{
+	if(*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = 2;
+		uint8_t buf[8];
+
+		if(!FindKey('T', 0x40, 0, "MK", buf, 8, 0, 0, 0, NULL) && !FindKey('T', 0x40, 0, "MK01", buf, 8, 0, 0, 0, NULL))
+			{ return CS_ERROR; }
+
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		int32_t idx = 0;
+
+		filters[idx].type = EMM_GLOBAL;
+		filters[idx].enabled   = 1;
+		filters[idx].filter[0] = 0x82;
+		filters[idx].mask[0]   = 0xFF;
+		idx++;
+
+		filters[idx].type = EMM_GLOBAL;
+		filters[idx].enabled   = 1;
+		filters[idx].filter[0] = 0x83;
+		filters[idx].mask[0]   = 0xFF;
+		idx++;
+
+		*filter_count = idx;
+	}
+
+	return CS_OK;
+}
+
+static int32_t emu_get_biss_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t UNUSED(caid), uint32_t UNUSED(provid))
+{
+	if (*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = 15;
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		int32_t idx = 0;
+		uint8_t i;
+
+		for (i = 0; i < max_filter_count; i++)
+		{
+			filters[idx].type = EMM_GLOBAL;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x81 + i; // What about table 0x81?
+			filters[idx].mask[0]   = 0xFF;
+			idx++;
+
+			*filter_count = idx;
+		}
+	}
+	return CS_OK;
+}
+
+static int32_t emu_get_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **UNUSED(emm_filters), unsigned int *UNUSED(filter_count))
+{
+	return CS_ERROR;
+}
+
+static int32_t emu_get_emm_filter_adv(struct s_reader *rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t caid, uint32_t provid, uint16_t srvid)
+{
+	if (caid_is_viaccess(caid))     return emu_get_via3_emm_filter(rdr, emm_filters, filter_count, caid, provid);
+	if (caid_is_irdeto(caid))       return emu_get_ird2_emm_filter(rdr, emm_filters, filter_count, caid, provid);
+	if (caid_is_powervu(caid))      return emu_get_pvu_emm_filter(rdr, emm_filters, filter_count, caid, provid, srvid);
+	if (caid_is_director(caid))     return emu_get_tan_emm_filter(rdr, emm_filters, filter_count, caid, provid);
+	if (caid_is_biss_dynamic(caid)) return emu_get_biss_emm_filter(rdr, emm_filters, filter_count, caid, provid);
+	if (caid_is_dre(caid))          return emu_get_dre2_emm_filter(rdr, emm_filters, filter_count, caid, provid);
+
+	return CS_ERROR;
+}
+
+const struct s_cardsystem reader_emu =
+{
+	.desc = "emu",
+	.caids = (uint16_t[]){ 0x05, 0x06, 0x09, 0x0D, 0x0E, 0x10, 0x18, 0x26, 0x4A, 0 },
+	.do_ecm = emu_do_ecm,
+	.do_emm = emu_do_emm,
+	.card_info = emu_card_info,
+	//.card_init = emu_card_init, // apparently this is not needed at all
+	.get_emm_type = emu_get_emm_type,
+	.get_emm_filter = emu_get_emm_filter, // needed to pass checks
+	.get_emm_filter_adv = emu_get_emm_filter_adv,
+};
+
+/*
+ * Create the Emu virtual "device" part. This is of type s_cardreader.
+ * Similar structures are found in the csctapi (Card System Card Terminal API)
+ * folder for every IFD (InterFace Device), aka smart card reader.
+ * Since we have no hardware to initialize, we start our Stream Relay server
+ * with the emu_reader_init() function.
+ * At Emu shutdown, we remove keys from memory with the emu_close() function.
+*/
+
+#define CR_OK     0
+#define CR_ERROR  1
+
+static int32_t emu_reader_init(struct s_reader *UNUSED(reader))
+{
+	int32_t i;
+	char authtmp[128];
+
+	if (cfg.emu_stream_relay_enabled && (stream_server_thread_init == 0))
+	{
+		stream_server_thread_init = 1;
+		SAFE_MUTEX_INIT(&emu_fixed_key_srvid_mutex, NULL);
+
+		for (i = 0; i < EMU_STREAM_SERVER_MAX_CONNECTIONS; i++)
+		{
+			SAFE_MUTEX_INIT(&emu_fixed_key_data_mutex[i], NULL);
+			ll_emu_stream_delayed_keys[i] = ll_create("ll_emu_stream_delayed_keys");
+			memset(&emu_fixed_key_data[i], 0, sizeof(emu_stream_client_key_data));
+		}
+
+		start_thread("stream_key_delayer", stream_key_delayer, NULL, NULL, 1, 1);
+		cs_log("Stream key delayer initialized");
+
+		cs_strncpy(emu_stream_source_host, cfg.emu_stream_source_host, sizeof(emu_stream_source_host));
+		emu_stream_source_port = cfg.emu_stream_source_port;
+		emu_stream_relay_port = cfg.emu_stream_relay_port;
+		emu_stream_emm_enabled = cfg.emu_stream_emm_enabled;
+
+		if (cfg.emu_stream_source_auth_user && cfg.emu_stream_source_auth_password)
+		{
+			snprintf(authtmp, sizeof(authtmp), "%s:%s", cfg.emu_stream_source_auth_user, cfg.emu_stream_source_auth_password);
+			b64encode(authtmp, strlen(authtmp), &emu_stream_source_auth);
+		}
+		else
+		{
+			NULLFREE(emu_stream_source_auth);
+		}
+
+		start_thread("stream_server", stream_server, NULL, NULL, 1, 1);
+		cs_log("Stream relay server initialized");
+	}
+
+	// Initialize mutex for exclusive access to key database and key file
+	if (!emu_key_data_mutex_init)
+	{
+		SAFE_MUTEX_INIT(&emu_key_data_mutex, NULL);
+		emu_key_data_mutex_init = 1;
+	}
+
+	return CR_OK;
+}
+
+static int32_t emu_close(struct s_reader *UNUSED(reader))
+{
+	cs_log("Reader is shutting down");
+
+	// Delete keys from Emu's memory
+	SAFE_MUTEX_LOCK(&emu_key_data_mutex);
+	clear_emu_keydata();
+	SAFE_MUTEX_UNLOCK(&emu_key_data_mutex);
+
+	return CR_OK;
+}
+
+static int32_t emu_get_status(struct s_reader *UNUSED(reader), int32_t *in) { *in = 1; return CR_OK; }
+static int32_t emu_activate(struct s_reader *UNUSED(reader), struct s_ATR *UNUSED(atr)) { return CR_OK; }
+static int32_t emu_transmit(struct s_reader *UNUSED(reader), uint8_t *UNUSED(buffer), uint32_t UNUSED(size), uint32_t UNUSED(expectedlen), uint32_t UNUSED(delay), uint32_t UNUSED(timeout)) { return CR_OK; }
+static int32_t emu_receive(struct s_reader *UNUSED(reader), uint8_t *UNUSED(buffer), uint32_t UNUSED(size), uint32_t UNUSED(delay), uint32_t UNUSED(timeout)) { return CR_OK; }
+static int32_t emu_write_settings(struct s_reader *UNUSED(reader), struct s_cardreader_settings *UNUSED(s)) { return CR_OK; }
+static int32_t emu_card_write(struct s_reader *UNUSED(pcsc_reader),const uchar *UNUSED(buf) ,uint8_t *UNUSED(cta_res), uint16_t *UNUSED(cta_lr),int32_t UNUSED(l)) { return CR_OK; }
+static int32_t emu_set_protocol(struct s_reader *UNUSED(rdr),uint8_t *UNUSED(params),uint32_t *UNUSED(length), uint32_t UNUSED(len_request)) { return CR_OK; }
+
+const struct s_cardreader cardreader_emu =
+{
+	.desc                   = "emu",
+	.typ                    = R_EMU,
+	.skip_extra_atr_parsing = 1,
+	.reader_init            = emu_reader_init,
+	.get_status             = emu_get_status,
+	.activate               = emu_activate,
+	.transmit               = emu_transmit,
+	.receive                = emu_receive,
+	.close                  = emu_close,
+	.write_settings         = emu_write_settings,
+	.card_write             = emu_card_write,
+	.set_protocol           = emu_set_protocol,
+};
+
+void add_emu_reader(void)
+{
+	// This function is called inside oscam.c and creates an emu [reader] with default
+	// settings in oscam.server file. If an emu [reader] already exists, it uses that.
+
+	LL_ITER itr;
+	struct s_reader *rdr;
+	int8_t haveEmuReader = 0;
+	char *emuName = "emulator";
+	char *ctab, *ftab, *emu_auproviders, *disablecrccws_only_for;
+
+	// Check if emu [reader] entry already exists in oscam.server file and get it
+	itr = ll_iter_create(configured_readers);
+	while ((rdr = ll_iter_next(&itr)))
+	{
+		if (rdr->typ == R_EMU)
+		{
+			haveEmuReader = 1;
+			break;
+		}
+	}
+
+	rdr = NULL;
+
+	// If there's no emu [reader] in oscam.server, create one with default settings
+	if (!haveEmuReader)
+	{
+		if (!cs_malloc(&rdr, sizeof(struct s_reader)))
+		{
+			return;
+		}
+
+		reader_set_defaults(rdr);
+
+		rdr->enable = 1;
+		rdr->typ = R_EMU;
+		strncpy(rdr->label, emuName, strlen(emuName));
+		strncpy(rdr->device, emuName, strlen(emuName));
+
+		// CAIDs
+		ctab = strdup("0500,0604,090F,0E00,1010,1801,2600,2602,2610,4AE1,A101");
+		chk_caidtab(ctab, &rdr->ctab);
+		NULLFREE(ctab);
+
+		// Idents
+		ftab = strdup("0500:000000,007400,007800,021110,023800;"
+					  "0604:000000;"
+					  "090F:000000;"
+					  "0E00:000000;"
+					  "1010:000000;"
+					  "1801:000000,001101,002111,007301;"
+					  "2600:000000;"
+					  "2602:000000;"
+					  "2610:000000;"
+					  "4AE1:000011,000014,0000FE;"
+					  "A101:000000;"
+					 );
+		chk_ftab(ftab, &rdr->ftab);
+		NULLFREE(ftab);
+
+		// AU providers
+		emu_auproviders = strdup("0604:010200;0E00:000000;1010:000000;2610:000000;4AE1:000011,000014,0000FE;");
+		chk_ftab(emu_auproviders, &rdr->emu_auproviders);
+		NULLFREE(emu_auproviders);
+
+		// EMM cache
+		rdr->cachemm = 2;
+		rdr->rewritemm = 1;
+		rdr->logemm = 2;
+		rdr->deviceemm = 1;
+
+		// User group
+		rdr->grp = 0x1ULL;
+
+		// Add the "device" part to our emu reader
+		rdr->crdr = &cardreader_emu;
+
+		// Disable CW checksum test for PowerVu
+		disablecrccws_only_for = strdup("0E00:000000");
+		chk_ftab(disablecrccws_only_for, &rdr->disablecrccws_only_for);
+		NULLFREE(disablecrccws_only_for);
+
+		reader_fixups_fn(rdr);
+		ll_append(configured_readers, rdr);
+	}
+
+	// Set DVB Api delayer option
+#ifdef HAVE_DVBAPI
+	if (cfg.dvbapi_enabled && cfg.dvbapi_delayer < 60)
+	{
+		cfg.dvbapi_delayer = 60;
+	}
+#endif
+
+	cs_log("OSCam-Emu version %d", GetOSemuVersion());
+}
+
+#endif // WITH_EMU
diff --git a/module-newcamd-des.c b/module-newcamd-des.c
index 3e687d8..5c310fb 100644
--- a/module-newcamd-des.c
+++ b/module-newcamd-des.c
@@ -5,10 +5,7 @@
 #define DES_IP              1
 #define DES_IP_1            2
 #define DES_RIGHT           4
-#define DES_HASH            8
 
-#define DES_ECM_CRYPT       0
-#define DES_ECM_HASH        DES_HASH
 #define DES_ECS2_DECRYPT    (DES_IP | DES_IP_1 | DES_RIGHT)
 #define DES_ECS2_CRYPT      (DES_IP | DES_IP_1)
 
@@ -356,7 +353,7 @@ static void desRound(unsigned char left[], unsigned char right[], unsigned char
 	swap(data - 4, data);
 }
 
-static void nc_des(unsigned char key[], unsigned char mode, unsigned char data[])
+void nc_des(unsigned char key[], unsigned char mode, unsigned char data[])
 {
 	unsigned char i;
 	unsigned char left[8];
diff --git a/module-newcamd-des.h b/module-newcamd-des.h
index a63f0d5..ebb38ad 100644
--- a/module-newcamd-des.h
+++ b/module-newcamd-des.h
@@ -1,8 +1,15 @@
 #ifndef MODULE_NEWCAMD_DES_H_
 #define MODULE_NEWCAMD_DES_H_
 
+#define DES_HASH            8
+
+#define DES_ECM_CRYPT       0
+#define DES_ECM_HASH        DES_HASH
+
 	int nc_des_encrypt(unsigned char *buffer, int len, unsigned char *deskey);
 	int nc_des_decrypt(unsigned char *buffer, int len, unsigned char *deskey);
 	unsigned char *nc_des_login_key_get(unsigned char *key1, unsigned char *key2, int len, unsigned char *des16);
 
+	void nc_des(unsigned char key[], unsigned char mode, unsigned char data[]);
+
 #endif
diff --git a/module-newcamd.c b/module-newcamd.c
index f4cff8b..773897b 100644
--- a/module-newcamd.c
+++ b/module-newcamd.c
@@ -919,6 +919,13 @@ static int8_t newcamd_auth_client(IN_ADDR_T ip, uint8_t *deskey)
 			// set userfilter for au enabled clients
 			if(aureader)
 			{
+#ifdef WITH_EMU
+				if(aureader->typ == R_EMU)
+				{
+					usr_filter = * get_emu_prids_for_caid(aureader, cfg.ncd_ptab.ports[cl->port_idx].ncd->ncd_ftab.filts[0].caid);
+				}
+				else
+#endif
 				mk_user_au_ftab(aureader, &usr_filter);
 			}
 			
@@ -948,6 +955,12 @@ static int8_t newcamd_auth_client(IN_ADDR_T ip, uint8_t *deskey)
 			else
 				{ memset(&mbuf[8], 0, 6); } //mbuf[8] - mbuf[13]
 
+#ifdef WITH_EMU
+			if(aureader && aureader->typ == R_EMU && caid_is_dre(pufilt->caid))
+			{
+				mbuf[10] = aureader->dre36_force_group;
+			}
+#endif
 			mbuf[14] = pufilt->nprids;
 			for(j = 0; j < pufilt->nprids; j++)
 			{
@@ -973,7 +986,7 @@ static int8_t newcamd_auth_client(IN_ADDR_T ip, uint8_t *deskey)
 					int32_t k, found;
 					uint32_t rprid;
 					found = 0;
-					if(pufilt->caid == aureader->caid)
+					if(pufilt->caid == aureader->caid && aureader->typ != R_EMU)
 					{
 						for(k = 0; (k < aureader->nprov); k++)
 						{
@@ -999,6 +1012,31 @@ static int8_t newcamd_auth_client(IN_ADDR_T ip, uint8_t *deskey)
 							}
 						}
 					}
+#ifdef WITH_EMU
+					else if(aureader->typ == R_EMU)
+					{
+						if(caid_is_dre(pufilt->caid))
+						{
+							found = 1;
+							memset(&mbuf[22 + 11 * j] ,0 ,4);
+							switch((uchar)(pufilt->prids[j]))
+							{
+								case 0x11:
+									mbuf[22 + 11 * j] = aureader->dre36_force_group;
+									break;
+								case 0x14:
+									mbuf[22 + 11 * j] = aureader->dre56_force_group;
+									break;
+								case 0xfe:
+									mbuf[22 + 11 * j] = 0xED;
+									mbuf[25 + 11 * j] = 0x02;
+									break;
+								default:
+									found = 0;
+							}
+						}
+					}
+#endif
 					if(!found)
 					{
 						mbuf[22 + 11 * j] = 0x00;
diff --git a/module-stat.c b/module-stat.c
index d94ff91..a599548 100644
--- a/module-stat.c
+++ b/module-stat.c
@@ -903,7 +903,7 @@ void check_lb_auto_betatunnel_mode(ECM_REQUEST *er)
 
 uint16_t get_rdr_caid(struct s_reader *rdr)
 {
-	if(is_network_reader(rdr))
+	if(is_network_reader(rdr) || rdr->typ == R_EMU)
 	{
 		return 0; //reader caid is not real caid
 	}
@@ -1301,7 +1301,7 @@ void stat_get_best_reader(ECM_REQUEST *er)
 		for(ea = er->matching_rdr; ea; ea = ea->next)
 		{
 			rdr = ea->reader;
-			if(is_network_reader(rdr))    //reader caid is not real caid
+			if(is_network_reader(rdr) || rdr->typ == R_EMU)    //reader caid is not real caid
 			{
 				prv = ea;
 				continue; // proxy can convert or reject
diff --git a/module-webif-tpl.c b/module-webif-tpl.c
index ee317db..bfca5b5 100644
--- a/module-webif-tpl.c
+++ b/module-webif-tpl.c
@@ -459,6 +459,7 @@ char *tpl_getUnparsedTpl(const char *name, int8_t removeHeader, const char *subd
 											check_conf(WITH_SSL, ptr2);
 											check_conf(WITH_STAPI, ptr2);
 											check_conf(WITH_STAPI5, ptr2);
+											check_conf(WITH_EMU, ptr2);
 										} // for
 										if(ok == 0)
 										{
diff --git a/module-webif.c b/module-webif.c
index 70a6b62..6fd0895 100644
--- a/module-webif.c
+++ b/module-webif.c
@@ -103,6 +103,7 @@ static bool use_srvid2 = false;
 #define MNU_CFG_LCD			14
 #define MNU_CFG_MONITOR		15
 #define MNU_CFG_WEBIF		16
+#define MNU_CFG_STREAMRELAY	17
 
 /* constants for files.html submenuactivating */
 #define MNU_CFG_FVERSION	0
@@ -136,8 +137,9 @@ static bool use_srvid2 = false;
 #define MNU_GBX_FSTAINF     	27
 #define MNU_GBX_FEXPINF     	28
 #define MNU_GBX_INFOLOG     	29
+#define MNU_CFG_FSOFTCAMKEY	30
 
-#define MNU_CFG_TOTAL_ITEMS 	30 // sum of items above. Use it for "All inactive" in function calls too.
+#define MNU_CFG_TOTAL_ITEMS 	31 // sum of config or files items above. Use it for "All inactive" in function calls too.
 
 static void set_status_info_var(struct templatevars *vars, char *varname, int no_data, char *fmt, double value) {
 	if (no_data)
@@ -1225,6 +1227,40 @@ static char *send_oscam_config_scam(struct templatevars *vars, struct uriparams
 }
 #endif
 
+#ifdef WITH_EMU
+#include "module-emulator-streamserver.h"
+
+static char *send_oscam_config_streamrelay(struct templatevars *vars, struct uriparams *params)
+{
+	char *value;
+
+	setActiveSubMenu(vars, MNU_CFG_STREAMRELAY);
+
+	webif_save_config("streamrelay", vars, params);
+
+	tpl_printf(vars, TPLADD, "STREAM_SOURCE_HOST", "%s", cfg.emu_stream_source_host);
+	tpl_printf(vars, TPLADD, "STREAM_SOURCE_PORT", "%d", cfg.emu_stream_source_port);
+	if(cfg.emu_stream_source_auth_user)
+		{ tpl_printf(vars, TPLADD, "STREAM_SOURCE_AUTH_USER", "%s", cfg.emu_stream_source_auth_user); }
+	if(cfg.emu_stream_source_auth_password)
+		{ tpl_printf(vars, TPLADD, "STREAM_SOURCE_AUTH_PASSWORD", "%s", cfg.emu_stream_source_auth_password); }
+	tpl_printf(vars, TPLADD, "STREAM_RELAY_PORT", "%d", cfg.emu_stream_relay_port);
+	tpl_printf(vars, TPLADD, "STREAM_ECM_DELAY", "%d", cfg.emu_stream_ecm_delay);
+	
+	tpl_printf(vars, TPLADD, "TMP", "STREAMRELAYENABLEDSELECTED%d", cfg.emu_stream_relay_enabled);
+	tpl_addVar(vars, TPLADD, tpl_getVar(vars, "TMP"), "selected");
+
+	tpl_printf(vars, TPLADD, "TMP", "STREAMEMMENABLEDSELECTED%d", cfg.emu_stream_emm_enabled);
+	tpl_addVar(vars, TPLADD, tpl_getVar(vars, "TMP"), "selected");
+
+	value = mk_t_caidtab(&cfg.emu_stream_relay_ctab);
+	tpl_addVar(vars, TPLADD, "STREAM_RELAY_CTAB", value);
+	free_mk_t(value);
+
+	return tpl_getTpl(vars, "CONFIGSTREAMRELAY");
+}
+#endif
+
 #ifdef MODULE_CCCAM
 static char *send_oscam_config_cccam(struct templatevars *vars, struct uriparams *params)
 {
@@ -1571,6 +1607,10 @@ static char *send_oscam_config_dvbapi(struct templatevars *vars, struct uriparam
 	tpl_printf(vars, TPLADD, "TMP", "EXTENDEDCWAPISELECTED%d", cfg.dvbapi_extended_cw_api);
 	tpl_addVar(vars, TPLADD, tpl_getVar(vars, "TMP"), "selected");
 
+	//extended_cw_pids (pid limiter)
+	tpl_printf(vars, TPLADD, "TMP", "EXTENDEDCWPIDSSELECTED%d", cfg.dvbapi_extended_cw_pids);
+	tpl_addVar(vars, TPLADD, tpl_getVar(vars, "TMP"), "selected");
+
 	//write_sdt_prov
 	if(cfg.dvbapi_write_sdt_prov > 0)
 		{ tpl_addVar(vars, TPLADD, "WRITESDTPROVCHECKED", "checked"); }
@@ -1648,6 +1688,9 @@ static char *send_oscam_config(struct templatevars *vars, struct uriparams *para
 #ifdef MODULE_SCAM
 	else if(!strcmp(part, "scam")) { return send_oscam_config_scam(vars, params); }
 #endif
+#ifdef WITH_EMU
+	else if(!strcmp(part, "streamrelay")) { return send_oscam_config_streamrelay(vars, params); }
+#endif
 #ifdef MODULE_CCCAM
 	else if(!strcmp(part, "cccam")) { return send_oscam_config_cccam(vars, params); }
 #endif
@@ -2123,7 +2166,7 @@ static char *send_oscam_reader_config(struct templatevars *vars, struct uriparam
 		chk_reader("services", servicelabels, rdr);
 		chk_reader("lb_whitelist_services", servicelabelslb, rdr);
 
-		if(is_network_reader(rdr))    //physical readers make trouble if re-started
+		if(is_network_reader(rdr) || rdr->typ == R_EMU)    //physical readers make trouble if re-started
 		{
 			if(rdr)
 				{
@@ -2807,6 +2850,31 @@ static char *send_oscam_reader_config(struct templatevars *vars, struct uriparam
 	tpl_addVar(vars, TPLADD, "USERSCRIPT", rdr->userscript);
 #endif
 
+#ifdef WITH_EMU
+	//emu_auproviders
+	value = mk_t_ftab(&rdr->emu_auproviders);
+	tpl_addVar(vars, TPLADD, "EMUAUPROVIDERS", value);
+	free_mk_t(value);
+
+	// Date-coded BISS keys
+	if(!apicall)
+	{
+		tpl_addVar(vars, TPLADD, "EMUDATECODEDENABLED", (rdr->emu_datecodedenabled == 1) ? "checked" : "");
+	}
+	else
+	{
+		tpl_addVar(vars, TPLADD, "EMUDATECODEDENABLED", (rdr->emu_datecodedenabled == 1) ? "1" : "0");
+	}
+
+	//extee
+	tpl_addVar(vars, TPLADD, "EXTEE36", rdr->extee36);
+	tpl_addVar(vars, TPLADD, "EXTEE56", rdr->extee56);
+
+	//dre force group
+	tpl_printf(vars, TPLADD, "DRE36FORCEGROUP","%02X", rdr->dre36_force_group);
+	tpl_printf(vars, TPLADD, "DRE56FORCEGROUP","%02X", rdr->dre56_force_group);
+#endif
+
 	tpl_addVar(vars, TPLADD, "PROTOCOL", reader_get_type_desc(rdr, 0));
 
 	// Show only parameters which needed for the reader
@@ -2828,6 +2896,9 @@ static char *send_oscam_reader_config(struct templatevars *vars, struct uriparam
 	case R_CAMD35 :
 		tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGCAMD35BIT"));
 		break;
+	case R_EMU :
+		tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGEMUBIT"));
+		break;
 	case R_CS378X :
 		tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGCS378XBIT"));
 		break;
@@ -4564,9 +4635,34 @@ static char *send_oscam_entitlement(struct templatevars *vars, struct uriparams
 
 					tpl_addVar(vars, TPLAPPEND, "LOGHISTORY", "<BR><BR>New Structure:<BR>");
 					char tbuffer[83];
+#ifdef WITH_EMU
+					char keyBuffer[1024];
+#endif
 					int jsondelimiter = 0;
 					while((item = ll_iter_next(&itr)))
 					{
+#ifdef WITH_EMU
+						if(item->isKey)
+						{
+							tpl_addVar(vars, TPLADD, "ENTSTARTDATE", "");
+							tpl_addVar(vars, TPLADD, "ENTENDDATE", "");
+							cs_hexdump(0, item->key, item->keyLength, keyBuffer, sizeof(keyBuffer));
+							tpl_addVar(vars, TPLADD, "ENTEXPIERED", "e_valid");
+							tpl_printf(vars, TPLADD, "ENTCAID", "%04X", item->caid);
+							tpl_printf(vars, TPLADD, "ENTPROVID", "%08X", item->provid);
+							tpl_addVar(vars, TPLADD, "ENTID", item->name);
+							tpl_addVar(vars, TPLADD, "ENTCLASS", keyBuffer);
+							if(item->isData) { tpl_addVar(vars, TPLADD, "ENTTYPE", "data"); }
+							else { tpl_addVar(vars, TPLADD, "ENTTYPE", "key"); }
+							tpl_addVar(vars, TPLADD, "ENTRESNAME", "");
+							
+							if((strcmp(getParam(params, "hideexpired"), "1") != 0) || (item->end > now))
+								{ tpl_addVar(vars, TPLAPPEND, "READERENTENTRY", tpl_getTpl(vars, "ENTITLEMENTITEMBIT")); }
+							
+							continue;
+						}
+#endif
+
 						localtime_r(&item->start, &start_t);
 						localtime_r(&item->end, &end_t);
 
@@ -5055,6 +5151,9 @@ static char *send_oscam_status(struct templatevars * vars, struct uriparams * pa
 						filtered = (type == cl->typ) || (type == 'x' && (cl->typ == 'p' || cl->typ == 'r') && (cl->reader && cl->reader->cacheex.mode));
 #else
 						filtered = (type == cl->typ);
+#endif
+#ifdef WITH_EMU
+						if(type == 'e' && cl->typ == 'r' && cl->reader->typ == R_EMU) filtered = 1;
 #endif
 					}
 				}
@@ -6522,6 +6621,9 @@ static char *send_oscam_files(struct templatevars * vars, struct uriparams * par
 		{ "stats.info",      MNU_GBX_FSTAINF,   FTYPE_GBOX },     // id 27
 		{ "expired.info",    MNU_GBX_FEXPINF,   FTYPE_GBOX },     // id 28
 		{ "info.log",        MNU_GBX_INFOLOG,   FTYPE_GBOX },     // id 29
+#endif
+#ifdef WITH_EMU
+		{ "SoftCam.Key",     MNU_CFG_FSOFTCAMKEY,FTYPE_CONFIG },  // id 30
 #endif
 		{ NULL, 0, 0 },
 	};
@@ -6993,7 +7095,7 @@ static char *send_oscam_EMM_running(struct templatevars * vars, struct uriparams
 		else if(!proxy && rdr->csystem_active)     // local active reader
 		{
 			csystem = rdr->csystem;
-			caid = rdr->caid;
+			if(rdr->typ != R_EMU) caid = rdr->caid;
 		}
 
 		if(csystem)
@@ -8000,8 +8102,8 @@ static int32_t readRequest(FILE * f, IN_ADDR_T in, char **result, int8_t forcePl
 		memcpy(*result + bufsize, buf2, n);
 		bufsize += n;
 
-		//max request size 100kb
-		if(bufsize > 102400)
+		//max request size 200kb
+		if(bufsize > 204800)
 		{
 			cs_log("error: too much data received from %s", cs_inet_ntoa(in));
 			NULLFREE(*result);
diff --git a/oscam-aes.c b/oscam-aes.c
index 784f375..ce5f96e 100644
--- a/oscam-aes.c
+++ b/oscam-aes.c
@@ -37,6 +37,16 @@ void aes_encrypt_idx(struct aes_keys *aes, uchar *buf, int32_t n)
 	}
 }
 
+void aes_cbc_encrypt(struct aes_keys *aes, uchar *buf, int32_t n, uchar *iv)
+{
+	AES_cbc_encrypt(buf, buf, n, &aes->aeskey_encrypt, iv, AES_ENCRYPT);
+}
+
+void aes_cbc_decrypt(struct aes_keys *aes, uchar *buf, int32_t n, uchar *iv)
+{
+	AES_cbc_encrypt(buf, buf, n, &aes->aeskey_decrypt, iv, AES_DECRYPT);
+}
+
 /* Creates an AES_ENTRY and adds it to the given linked list. */
 void add_aes_entry(AES_ENTRY **list, uint16_t caid, uint32_t ident, int32_t keyid, uchar *aesKey)
 {
diff --git a/oscam-aes.h b/oscam-aes.h
index 952cb48..9b51705 100644
--- a/oscam-aes.h
+++ b/oscam-aes.h
@@ -5,6 +5,8 @@ void aes_set_key(struct aes_keys *aes, char *key);
 bool aes_set_key_alloc(struct aes_keys **aes, char *key);
 void aes_decrypt(struct aes_keys *aes, uchar *buf, int32_t n);
 void aes_encrypt_idx(struct aes_keys *aes, uchar *buf, int32_t n);
+void aes_cbc_encrypt(struct aes_keys *aes, uchar *buf, int32_t n, uchar *iv);
+void aes_cbc_decrypt(struct aes_keys *aes, uchar *buf, int32_t n, uchar *iv);
 
 void add_aes_entry(AES_ENTRY **list, uint16_t caid, uint32_t ident, int32_t keyid, uchar *aesKey);
 void parse_aes_entry(AES_ENTRY **list, char *label, char *value);
diff --git a/oscam-chk.c b/oscam-chk.c
index eec620a..d200304 100644
--- a/oscam-chk.c
+++ b/oscam-chk.c
@@ -758,7 +758,7 @@ int32_t matching_reader(ECM_REQUEST *er, struct s_reader *rdr)
 		return 0;
 	}
 
-	if(!is_network_reader(rdr) && ((rdr->caid >> 8) != ((er->caid >> 8) & 0xFF) && (rdr->caid >> 8) != ((er->ocaid >> 8) & 0xFF)))
+	if(!(rdr->typ == R_EMU) && !is_network_reader(rdr) && ((rdr->caid >> 8) != ((er->caid >> 8) & 0xFF) && (rdr->caid >> 8) != ((er->ocaid >> 8) & 0xFF)))
 	{
 		if (!rdr->csystem)
 			return 0;
@@ -794,7 +794,7 @@ int32_t matching_reader(ECM_REQUEST *er, struct s_reader *rdr)
 	}
 
 	//Checking ident:
-	if(!chk_rfilter(er, rdr))
+	if(!(rdr->typ == R_EMU && caid_is_biss(er->caid)) && !chk_rfilter(er, rdr))
 	{
 		cs_log_dbg(D_TRACE, "r-filter reader %s", rdr->label);
 		return (0);
@@ -853,7 +853,7 @@ int32_t matching_reader(ECM_REQUEST *er, struct s_reader *rdr)
 	}
 
 	//Checking entitlements:
-	if(ll_count(rdr->ll_entitlements) > 0)
+	if(ll_count(rdr->ll_entitlements) > 0 && !(rdr->typ == R_EMU))
 	{
 		LL_ITER itr = ll_iter_create(rdr->ll_entitlements);
 		S_ENTITLEMENT *item;
@@ -1024,7 +1024,7 @@ int32_t chk_caid(uint16_t caid, CAIDTAB *ctab)
 
 int32_t chk_caid_rdr(struct s_reader *rdr, uint16_t caid)
 {
-	if(is_network_reader(rdr))
+	if(is_network_reader(rdr) || rdr->typ == R_EMU)
 	{
 		return 1; //reader caid is not real caid
 	}
diff --git a/oscam-config-global.c b/oscam-config-global.c
index 222ca00..7fc1196 100644
--- a/oscam-config-global.c
+++ b/oscam-config-global.c
@@ -854,6 +854,31 @@ static const struct config_list scam_opts[] =
 #else
 static const struct config_list scam_opts[] = { DEF_LAST_OPT };
 #endif
+
+#ifdef WITH_EMU
+static bool streamrelay_should_save_fn(void *UNUSED(var))
+{
+	return 1;
+}
+static const struct config_list streamrelay_opts[] =
+{
+	DEF_OPT_SAVE_FUNC(streamrelay_should_save_fn),
+	DEF_OPT_STR("stream_source_host"          , OFS(emu_stream_source_host),          "127.0.0.1"),
+	DEF_OPT_INT32("stream_source_port"        , OFS(emu_stream_source_port),          8001),
+	DEF_OPT_STR("stream_source_auth_user"     , OFS(emu_stream_source_auth_user),     NULL),
+	DEF_OPT_STR("stream_source_auth_password" , OFS(emu_stream_source_auth_password), NULL),
+	DEF_OPT_INT32("stream_relay_port"         , OFS(emu_stream_relay_port),           17999),
+	DEF_OPT_UINT32("stream_ecm_delay"         , OFS(emu_stream_ecm_delay),            600),
+	DEF_OPT_INT8("stream_relay_enabled"       , OFS(emu_stream_relay_enabled),        1),
+	DEF_OPT_INT8("stream_emm_enabled"         , OFS(emu_stream_emm_enabled),          1),
+	DEF_OPT_FUNC("stream_relay_ctab"          , OFS(emu_stream_relay_ctab),           check_caidtab_fn),
+	DEF_LAST_OPT
+};
+#else
+static const struct config_list streamrelay_opts[] = { DEF_LAST_OPT };
+#endif
+
+
 #ifdef MODULE_RADEGAST
 static bool radegast_should_save_fn(void *UNUSED(var))
 {
@@ -1262,6 +1287,7 @@ static const struct config_list dvbapi_opts[] =
 	DEF_OPT_INT8("read_sdt"		, OFS(dvbapi_read_sdt),	0),
 	DEF_OPT_INT8("write_sdt_prov", OFS(dvbapi_write_sdt_prov),	0),
 	DEF_OPT_INT8("extended_cw_api", OFS(dvbapi_extended_cw_api),	0),
+	DEF_OPT_INT8("extended_cw_pids", OFS(dvbapi_extended_cw_pids),	64), // pid limiter
 	DEF_OPT_FUNC("boxtype"		, OFS(dvbapi_boxtype),		dvbapi_boxtype_fn),
 	DEF_OPT_FUNC("services"		, OFS(dvbapi_sidtabs.ok),	dvbapi_services_fn),
 	// OBSOLETE OPTIONS
@@ -1315,6 +1341,7 @@ static const struct config_sections oscam_conf[] =
 	{ "cccam",	cccam_opts },
 	{ "pandora",	pandora_opts },
 	{ "scam",	scam_opts },
+	{ "streamrelay",	streamrelay_opts },
 	{ "dvbapi",	dvbapi_opts },
 	{ "monitor",	monitor_opts },
 	{ "webif",	webif_opts },
diff --git a/oscam-config-reader.c b/oscam-config-reader.c
index 2207b2d..83a1aff 100644
--- a/oscam-config-reader.c
+++ b/oscam-config-reader.c
@@ -111,6 +111,7 @@ static void protocol_fn(const char *token, char *value, void *setting, FILE *f)
 			{ "newcamd525", R_NEWCAMD },
 			{ "newcamd524", R_NEWCAMD },
 			{ "drecas",		R_DRECAS },
+			{ "emu",        R_EMU },
 			{ NULL        , 0 }
 		}, *p;
 		int i;
@@ -704,6 +705,9 @@ void ftab_fn(const char *token, char *value, void *setting, long ftab_type, FILE
 		if(ftab_type & FTAB_FBPCAID)     { rdr = container_of(setting, struct s_reader, fallback_percaid); }
 		if(ftab_type & FTAB_LOCALCARDS)  { rdr = container_of(setting, struct s_reader, localcards); }
 		if(ftab_type & FTAB_IGNCHKSMCAID){ rdr = container_of(setting, struct s_reader, disablecrccws_only_for); }
+#ifdef WITH_EMU
+		if(ftab_type & FTAB_EMUAU)       { rdr = container_of(setting, struct s_reader, emu_auproviders); }
+#endif
 		if(rdr)
 			{ rdr->changes_since_shareupdate = 1; }
 	}
@@ -1035,7 +1039,7 @@ static void cooldowntime_fn(const char *UNUSED(token), char *value, void *settin
 }
 
 
-static void reader_fixups_fn(void *var)
+void reader_fixups_fn(void *var)
 {
 	struct s_reader *rdr = var;
 #ifdef WITH_LB
@@ -1190,6 +1194,14 @@ static const struct config_list reader_opts[] =
 #endif
 #ifdef READER_DRECAS
 	DEF_OPT_STR("stmkeys"               , OFS(stmkeys),                 NULL),
+#endif
+#ifdef WITH_EMU
+	DEF_OPT_FUNC_X("emu_auproviders"    , OFS(emu_auproviders),         ftab_fn, FTAB_READER | FTAB_EMUAU),
+	DEF_OPT_INT8("emu_datecodedenabled" , OFS(emu_datecodedenabled),    0),
+	DEF_OPT_STR("extee36"               , OFS(extee36),                 NULL),
+	DEF_OPT_STR("extee56"               , OFS(extee56),                 NULL),
+	DEF_OPT_HEX("dre36_force_group"     , OFS(dre36_force_group),       1),
+	DEF_OPT_HEX("dre56_force_group"     , OFS(dre56_force_group),       1),
 #endif
 	DEF_OPT_INT8("deprecated"           , OFS(deprecated),              0),
 	DEF_OPT_INT8("audisabled"           , OFS(audisabled),              0),
diff --git a/oscam-config.h b/oscam-config.h
index f8e088b..1671d0a 100644
--- a/oscam-config.h
+++ b/oscam-config.h
@@ -22,6 +22,7 @@ void    free_reader(struct s_reader *rdr);
 int32_t free_readerdb(void);
 int32_t write_server(void);
 void    reload_readerdb(void);
+void    reader_fixups_fn(void *var);
 
 void    chk_sidtab(char *token, char *value, struct s_sidtab *sidtab);
 int32_t init_sidtab(void);
@@ -63,7 +64,8 @@ enum ftab_fn
 	FTAB_FBPCAID				= 0x10,
 	FTAB_LOCALCARDS				= 0x20,
 	FTAB_IGNCHKSMCAID			= 0x40,
-	FTAB_IGNCRCCEX4USERONLYFOR	= 0x80
+	FTAB_IGNCRCCEX4USERONLYFOR	= 0x80,
+	FTAB_EMUAU					= 0x100
 };
 
 void ftab_fn(const char *token, char *value, void *setting, long ftab_type, FILE *f);
diff --git a/oscam-ecm.c b/oscam-ecm.c
index ac48393..8e279d3 100644
--- a/oscam-ecm.c
+++ b/oscam-ecm.c
@@ -2253,7 +2253,7 @@ void get_cw(struct s_client *client, ECM_REQUEST *er)
 	}
 
 	//checks for odd/even byte 
-	if(!caid_is_biss(er->caid) && !caid_is_fake(er->caid) && get_odd_even(er)==0){
+	if(!caid_is_biss_static(er->caid) && !caid_is_fake(er->caid) && get_odd_even(er)==0){
 		cs_log_dbg(D_TRACE, "warning: ecm with null odd/even byte from %s", (check_client(er->client)?er->client->account->usr:"-"));
 		er->rc = E_INVALID;
 	}
diff --git a/oscam-emm.c b/oscam-emm.c
index 311ad97..260b448 100644
--- a/oscam-emm.c
+++ b/oscam-emm.c
@@ -41,6 +41,7 @@ static int8_t cs_emmlen_is_blocked(struct s_reader *rdr, int16_t len)
 static int8_t do_simple_emm_filter(struct s_reader *rdr, const struct s_cardsystem *csystem, EMM_PACKET *ep, int8_t cl_dvbapi)
 {
 	if(is_network_reader(rdr)) { return 1; }  // dont evaluate on network readers, server with local reader will check it
+	if(rdr->typ == R_EMU) { return 1; } // don't evalutate on emu reader
 
 	//copied and enhanced from module-dvbapi.c
 	//dvbapi_start_emm_filter()
@@ -209,6 +210,24 @@ int32_t emm_reader_match(struct s_reader *reader, uint16_t caid, uint32_t provid
 		rdr_log_dbg(reader, D_EMM, "reader auprovid = %06X fixup to %06X (ignoring last digit)", reader->auprovid, prid); 
 	}
 	
+#ifdef WITH_EMU
+	if(reader->typ == R_EMU)
+	{
+		FILTER* emu_provids = get_emu_prids_for_caid(reader, caid);
+		if(emu_provids != NULL)
+		{
+			for(i = 0; i < emu_provids->nprids; i++)
+			{
+				if(provid == emu_provids->prids[i])
+				{
+					return 1;
+				}
+			}
+		}
+		return 0;
+	}
+#endif
+	
 	if(prid == provid)
 	{
 		rdr_log_dbg(reader, D_EMM, "reader auprovid = %06X matching with emm provid = %06X -> SEND!", prid, provid);
diff --git a/oscam-string.c b/oscam-string.c
index 8fe9d3b..5be7245 100644
--- a/oscam-string.c
+++ b/oscam-string.c
@@ -498,6 +498,62 @@ uint32_t crc32(uint32_t crc, const uint8_t *buf, uint32_t len)
 	return crc ^ 0xffffffffL;
 }
 
+static uint32_t fletcher_crc_table[256] = {
+	0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
+	0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
+	0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+	0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
+	0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
+	0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+	0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
+	0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
+	0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+	0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
+	0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
+	0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
+	0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
+	0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
+	0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
+	0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
+	0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
+	0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+	0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
+	0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
+	0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+	0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
+	0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
+	0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+	0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
+	0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
+	0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
+	0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
+	0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
+	0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
+	0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
+	0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4};
+
+uint32_t fletcher_crc32(uint8_t *data, uint32_t len)
+{
+	uint32_t i;
+	uint32_t crc = 0xffffffff;
+
+	for (i=0; i<len; i++)
+		crc = (crc << 8) ^ fletcher_crc_table[((crc >> 24) ^ *data++) & 0xff];
+
+	return crc;
+}
+
 static uint16_t ccitt_crc_table [256] =
 {
 	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5,
diff --git a/oscam-string.h b/oscam-string.h
index 0343879..12b8b04 100644
--- a/oscam-string.h
+++ b/oscam-string.h
@@ -37,6 +37,7 @@ void get_random_bytes_init(void);
 void get_random_bytes(uint8_t *dst, uint32_t dst_len);
 
 uint32_t crc32(uint32_t crc, const uint8_t *buf, uint32_t len);
+uint32_t fletcher_crc32(uint8_t *data, uint32_t len);
 uint16_t ccitt_crc(uint8_t *data, size_t length, uint16_t seed, uint16_t final);
 uint32_t ccitt32_crc(uint8_t *data, size_t len);
 uint32_t jhash(const char *key, size_t len);
diff --git a/oscam.c b/oscam.c
index 5d7e24e..5708a19 100644
--- a/oscam.c
+++ b/oscam.c
@@ -41,6 +41,11 @@
 #include "reader-common.h"
 #include "module-gbox.h"
 
+#ifdef WITH_EMU
+	void add_emu_reader(void);
+	void stop_stream_server(void);
+#endif
+
 #ifdef WITH_SSL
 #include <openssl/crypto.h>
 #include <openssl/ssl.h>
@@ -421,6 +426,7 @@ static void write_versionfile(bool use_stdout)
 	write_conf(CW_CYCLE_CHECK, "CW Cycle Check support");
 	write_conf(LCDSUPPORT, "LCD support");
 	write_conf(LEDSUPPORT, "LED support");
+	write_conf(WITH_EMU, "Emulator support");
 	switch (cs_getclocktype()) {
 		case CLOCK_TYPE_UNKNOWN  : write_conf(CLOCKFIX, "Clockfix with UNKNOWN clock"); break;
 		case CLOCK_TYPE_REALTIME : write_conf(CLOCKFIX, "Clockfix with realtime clock"); break;
@@ -1646,6 +1652,9 @@ const struct s_cardreader *cardreaders[] =
 #ifdef CARDREADER_STINGER
 	&cardreader_stinger,
 #endif
+#ifdef WITH_EMU
+	&cardreader_emu,
+#endif
 
 	NULL
 };
@@ -1818,6 +1827,9 @@ int32_t main(int32_t argc, char *argv[])
 
 	init_sidtab();
 	init_readerdb();
+#ifdef WITH_EMU
+	add_emu_reader();
+#endif
 	cfg.account = init_userdb();
 	init_signal();
 	init_provid();
@@ -1904,6 +1916,9 @@ int32_t main(int32_t argc, char *argv[])
 #ifdef MODULE_GBOX
  if(!cfg.gsms_dis)
 	{ stop_sms_sender(); }
+#endif
+#ifdef WITH_EMU
+	stop_stream_server();
 #endif
 	webif_close();
 	azbox_close();
diff --git a/reader-common.c b/reader-common.c
index a549418..a12ce56 100644
--- a/reader-common.c
+++ b/reader-common.c
@@ -15,6 +15,7 @@
 #include "reader-common.h"
 //#include "csctapi/atr.h"
 #include "csctapi/icc_async.h"
+#include "readers.h" // required by the emu reader
 
 extern const struct s_cardsystem *cardsystems[];
 extern char *RDR_CD_TXT[];
@@ -142,6 +143,19 @@ void cardreader_poll_status(struct s_reader *reader)
 static int32_t reader_get_cardsystem(struct s_reader *reader, ATR *atr)
 {
 	int32_t i;
+
+#ifdef WITH_EMU
+	if(reader->typ == R_EMU)
+	{
+		NULLFREE(reader->csystem_data);
+		rdr_log(reader, "found card system %s", reader_emu.desc);
+		reader->csystem = &reader_emu;
+		reader->csystem_active = true;
+		led_status_found_cardsystem();
+		return (reader->csystem_active);
+	}
+#endif
+
 	for(i = 0; cardsystems[i]; i++)
 	{
 		NULLFREE(reader->csystem_data);
diff --git a/readers.h b/readers.h
index eec350e..316c2be 100644
--- a/readers.h
+++ b/readers.h
@@ -17,5 +17,6 @@ extern const struct s_cardsystem reader_tongfang;
 extern const struct s_cardsystem reader_bulcrypt;
 extern const struct s_cardsystem reader_griffin;
 extern const struct s_cardsystem reader_dgcrypt;
+extern const struct s_cardsystem reader_emu;
 
 #endif
diff --git a/webif/config/dvbapi.html b/webif/config/dvbapi.html
index aafb74b..20d68dc 100644
--- a/webif/config/dvbapi.html
+++ b/webif/config/dvbapi.html
@@ -53,7 +53,7 @@
 			</TD>
 		</TR>
 		<TR><TD><A>Write detected prov name to srvid:</A></TD><TD><input name="write_sdt_prov" type="checkbox" value="1" ##WRITESDTPROVCHECKED##><label></label>
-		<!-- <TR><TD><A>API for extended CWs</A></TD>
+		<TR><TD><A>API for extended CWs</A></TD>
 			<TD>
 				<select name="extended_cw_api">
 					<option value="0" ##EXTENDEDCWAPISELECTED0##>0 - none (disabled)</option>
@@ -61,4 +61,19 @@
 					<option value="2" ##EXTENDEDCWAPISELECTED2##>2 - OE2.0</option>
 				</select>
 			</TD>
-		</TR> -->			
\ No newline at end of file
+		</TR>
+		</TR>
+		<TR><TD><A>Max pids for extended CWs</A></TD>
+			<TD>
+				<select name="extended_cw_pids">
+					<option value="2" ##EXTENDEDCWPIDSSELECTED2##>2</option>
+					<option value="3" ##EXTENDEDCWPIDSSELECTED3##>3</option>
+					<option value="4" ##EXTENDEDCWPIDSSELECTED4##>4</option>
+					<option value="5" ##EXTENDEDCWPIDSSELECTED5##>5</option>
+					<option value="6" ##EXTENDEDCWPIDSSELECTED6##>6</option>
+					<option value="7" ##EXTENDEDCWPIDSSELECTED7##>7</option>
+					<option value="8" ##EXTENDEDCWPIDSSELECTED8##>8</option>
+					<option value="64" ##EXTENDEDCWPIDSSELECTED64##>64</option>
+				</select>
+			</TD>
+		</TR>
\ No newline at end of file
diff --git a/webif/config/menu.html b/webif/config/menu.html
index e3ff1aa..d3733f8 100644
--- a/webif/config/menu.html
+++ b/webif/config/menu.html
@@ -16,6 +16,7 @@
 ##TPLCONFIGMENUDVBAPI##		<!-- CMENUACTIVE13 -->
 ##TPLCONFIGMENULCD##		<!-- CMENUACTIVE14 -->
 ##TPLCONFIGMENUMONITOR##	<!-- CMENUACTIVE15 -->
+##TPLCONFIGMENUSTREAMRELAY##	<!-- CMENUACTIVE17 -->
 			<LI CLASS="##CMENUACTIVE16##"><A HREF="config.html?part=webif">WebIf</A></LI>
 	</UL>
 </DIV>
diff --git a/webif/config/menu_streamrelay.html b/webif/config/menu_streamrelay.html
new file mode 100644
index 0000000..ae9a86e
--- /dev/null
+++ b/webif/config/menu_streamrelay.html
@@ -0,0 +1 @@
+			<LI CLASS="##CMENUACTIVE17##"><A HREF="config.html?part=streamrelay">Stream Relay</A></LI>
diff --git a/webif/config/streamrelay.html b/webif/config/streamrelay.html
new file mode 100644
index 0000000..6fe5387
--- /dev/null
+++ b/webif/config/streamrelay.html
@@ -0,0 +1,26 @@
+		<input name="part" type="hidden" value="streamrelay">
+		<TABLE CLASS="config">
+			<TR><TH COLSPAN="2">Edit Stream Relay Config</TH></TR>
+			<TR><TD><A>Mode (requires OSCam restart)</A></TD>
+				<TD>
+					<select name="stream_relay_enabled">
+						<option value="0" ##STREAMRELAYENABLEDSELECTED0##>0 - disabled</option>
+						<option value="1" ##STREAMRELAYENABLEDSELECTED1##>1 - enabled</option>
+					</select>
+				</TD>
+			</TR>
+			<TR><TD><A>Caid:</A></TD><TD><input name="stream_relay_ctab" type="text" maxlength="160" value="##STREAM_RELAY_CTAB##"></TD></TR>
+			<TR><TD><A>Source Stream Host:</A></TD><TD><input name="stream_source_host" type="text" maxlength="15" value="##STREAM_SOURCE_HOST##"></TD></TR>
+			<TR><TD><A>Source Stream Port:</A></TD><TD><input name="stream_source_port" class="short" type="text" maxlength="5" value="##STREAM_SOURCE_PORT##"></TD></TR>
+			<TR><TD><A>Source Stream User:</A></TD><TD><input name="stream_source_auth_user" type="text" value="##STREAM_SOURCE_AUTH_USER##"></TD></TR>
+			<TR><TD><A>Source Stream Password:</A></TD><TD><input name="stream_source_auth_password" type="text" value="##STREAM_SOURCE_AUTH_PASSWORD##"></TD></TR>
+			<TR><TD><A>Relay Port:</A></TD><TD><input name="stream_relay_port" class="short" type="text" maxlength="5" value="##STREAM_RELAY_PORT##"></TD></TR>
+			<TR><TD><A>ECM fix delay:</A></TD><TD><input name="stream_ecm_delay" class="short" type="text" maxlength="5" value="##STREAM_ECM_DELAY##"></TD></TR>
+			<TR><TD><A>Process EMM from stream:</A></TD>
+				<TD>
+					<select name="stream_emm_enabled">
+						<option value="0" ##STREAMEMMENABLEDSELECTED0##>0 - disabled</option>
+						<option value="1" ##STREAMEMMENABLEDSELECTED1##>1 - enabled</option>
+					</select>
+				</TD>
+			</TR>
\ No newline at end of file
diff --git a/webif/files/menu.html b/webif/files/menu.html
index 4dc6f02..2e4e6b6 100644
--- a/webif/files/menu.html
+++ b/webif/files/menu.html
@@ -10,7 +10,7 @@
 		<LI CLASS="##CMENUACTIVE7##"><A HREF="files.html?file=logfile">logfile</A></LI>
 		<LI CLASS="##CMENUACTIVE8##"><A HREF="files.html?file=userfile">userfile</A></LI>
 ##TPLFILEMENUGBOX##		<!-- CMENUACTIVE19-29 -->
-		<LI CLASS="##CMENUACTIVE9## ##CMENUACTIVE10## ##CMENUACTIVE11## ##CMENUACTIVE12## ##CMENUACTIVE13## ##CMENUACTIVE14## ##CMENUACTIVE15## ##CMENUACTIVE16## ##CMENUACTIVE17## ##CMENUACTIVE18##"><A HREF="#"  class="drop">other files<b class="subcaret"></b></A>
+		<LI CLASS="##CMENUACTIVE9## ##CMENUACTIVE10## ##CMENUACTIVE11## ##CMENUACTIVE12## ##CMENUACTIVE13## ##CMENUACTIVE14## ##CMENUACTIVE15## ##CMENUACTIVE16## ##CMENUACTIVE17## ##CMENUACTIVE18## ##CMENUACTIVE30##"><A HREF="#"  class="drop">other files<b class="subcaret"></b></A>
 			<UL CLASS="dropdown_nav">
 				<LI CLASS="##CMENUACTIVE9##"><A HREF="files.html?file=oscam.services">oscam.services</A></LI>
 				<LI CLASS="##CMENUACTIVE10##"><A HREF="files.html?file=oscam.provid">oscam.provid</A></LI>
@@ -22,6 +22,7 @@
 ##VIEW_FILEMENUCSS##		<!-- CMENUACTIVE16 -->
 ##TPLFILEMENUTWIN##		<!-- CMENUACTIVE17 -->
 ##TPLFILEMENUCONSTCW##  	<!-- CMENUACTIVE18 -->
+##TPLFILEMENUSOFTCAMKEY##		<!-- CMENUACTIVE30 -->
 			</UL>
 		</LI>
 	</UL>
diff --git a/webif/files/menu_softcamkey.html b/webif/files/menu_softcamkey.html
new file mode 100644
index 0000000..cf71877
--- /dev/null
+++ b/webif/files/menu_softcamkey.html
@@ -0,0 +1 @@
+			<LI CLASS="##CMENUACTIVE30##"><A HREF="files.html?file=SoftCam.Key">SoftCam.Key</A></LI>
diff --git a/webif/pages_index.txt b/webif/pages_index.txt
index 307fc43..ebf12a9 100644
--- a/webif/pages_index.txt
+++ b/webif/pages_index.txt
@@ -81,11 +81,13 @@ CONFIGMENUMONITOR             config/menu_monitor.html
 CONFIGMENUNEWCAMD             config/menu_newcamd.html                                    MODULE_NEWCAMD
 CONFIGMENURADEGAST            config/menu_radegast.html                                   MODULE_RADEGAST
 CONFIGMENUSCAM                config/menu_scam.html                                       MODULE_SCAM
+CONFIGMENUSTREAMRELAY         config/menu_streamrelay.html                                WITH_EMU
 CONFIGMENUSERIAL              config/menu_serial.html                                     MODULE_SERIAL
 CONFIGMONITOR                 config/monitor.html                                         MODULE_MONITOR
 CONFIGNEWCAMD                 config/newcamd.html                                         MODULE_NEWCAMD
 CONFIGRADEGAST                config/radegast.html                                        MODULE_RADEGAST
 CONFIGSCAM                    config/scam.html                                            MODULE_SCAM
+CONFIGSTREAMRELAY             config/streamrelay.html                                     WITH_EMU
 CONFIGSERIAL                  config/serial.html                                          MODULE_SERIAL
 CONFIGSERIALDEVICEBIT         config/serial_devices.html                                  MODULE_SERIAL
 CONFIGWEBIF                   config/webif.html
@@ -119,6 +121,7 @@ FILEMENUDVBAPI                files/menu_dvbapi.html
 FILEMENUFAKECWS               files/menu_fakecws.html                                     CS_CACHEEX
 FILEMENUGBOX                  files/menu_gbox.html                                        MODULE_GBOX
 FILEMENUTWIN                  files/menu_twin.html                                        MODULE_SERIAL
+FILEMENUSOFTCAMKEY            files/menu_softcamkey.html                                  WITH_EMU
 
 AUTOCONF                      ghttp/autoconf.html                                         MODULE_GHTTP
 PREAUTOCONF                   ghttp/pre_autoconf.html                                     MODULE_GHTTP
@@ -183,6 +186,7 @@ READERCONFIG                  readerconfig/readerconfig.html
 READEREDITCACHEEXBIT          readerconfig/readerconfig_cacheexbit.html                   CS_CACHEEX
 READERCONFIGCAMD35BIT         readerconfig/readerconfig_camd35bit.html                    MODULE_CAMD35
 READERCONFIGCCCAMBIT          readerconfig/readerconfig_cccambit.html                     MODULE_CCCAM
+READERCONFIGEMUBIT            readerconfig/readerconfig_emubit.html                       WITH_EMU
 READERCONFIGCS378XBIT         readerconfig/readerconfig_cs378xbit.html                    MODULE_CAMD35_TCP
 READERCONFIGGBOXBIT           readerconfig/readerconfig_gboxbit.html                      MODULE_GBOX
 READERINFOGBOXREMM            readerconfig/readerinfo_gbox_remm.html                      MODULE_GBOX
diff --git a/webif/readerconfig/readerconfig_emubit.html b/webif/readerconfig/readerconfig_emubit.html
new file mode 100644
index 0000000..3c169f4
--- /dev/null
+++ b/webif/readerconfig/readerconfig_emubit.html
@@ -0,0 +1,6 @@
+			<TR><TD><A>AU providers:</A></TD><TD><textarea name="emu_auproviders" rows="3" class="bt">##EMUAUPROVIDERS##</textarea></TD></TR>
+			<TR><TD><A>[BISS] Enable date-coded keys:</A></TD><TD><input name="emu_datecodedenabled" type="hidden" value="0"><input name="emu_datecodedenabled" type="checkbox" value="1" ##EMUDATECODEDENABLED##><label></label></TD></TR>
+			<TR><TD><A>[Drecrypt] Path to ee36.bin:</A></TD><TD><input name="extee36" type="text" maxlength="150" value="##EXTEE36##"></TD></TR>
+			<TR><TD><A>[Drecrypt] Path to ee56.bin:</A></TD><TD><input name="extee56" type="text" maxlength="150" value="##EXTEE56##"></TD></TR>
+			<TR><TD><A>[Drecrypt] Center force group:</A></TD><TD><input name="dre36_force_group" class="medium" type="text" maxlength="2" value="##DRE36FORCEGROUP##"></TD></TR>
+			<TR><TD><A>[Drecrypt] Siberia force group:</A></TD><TD><input name="dre56_force_group" class="medium" type="text" maxlength="2" value="##DRE56FORCEGROUP##"></TD></TR>
